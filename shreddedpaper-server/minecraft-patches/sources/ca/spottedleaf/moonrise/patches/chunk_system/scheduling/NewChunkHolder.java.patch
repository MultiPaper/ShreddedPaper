--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
@@ -29,11 +_,15 @@
 import com.google.gson.JsonNull;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
+import io.multipaper.shreddedpaper.ShreddedPaper;
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperChunkTicker;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ChunkLevel;
 import net.minecraft.server.level.FullChunkStatus;
@@ -53,6 +_,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Optional;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
@@ -777,13 +_,13 @@
             // ensure in unload queue
             if (!this.inUnloadQueue) {
                 this.inUnloadQueue = true;
-                this.scheduler.chunkHolderManager.unloadQueue.addChunk(this.chunkX, this.chunkZ);
+                world.chunkSource.tickingRegions.getOrCreate(RegionPos.forChunk(vanillaChunkHolder.getPos())).unloadQueue.add(vanillaChunkHolder.getPos().toLong()); // this.scheduler.chunkHolderManager.unloadQueue.addChunk(this.chunkX, this.chunkZ); // ShreddedPaper
             }
         } else {
             // ensure not in unload queue
             if (this.inUnloadQueue) {
                 this.inUnloadQueue = false;
-                this.scheduler.chunkHolderManager.unloadQueue.removeChunk(this.chunkX, this.chunkZ);
+                Optional.ofNullable(world.chunkSource.tickingRegions.get(RegionPos.forChunk(vanillaChunkHolder.getPos()))).ifPresent(v -> v.unloadQueue.remove(vanillaChunkHolder.getPos().toLong())); // this.scheduler.chunkHolderManager.unloadQueue.removeChunk(this.chunkX, this.chunkZ); // ShreddedPaper
             }
         }
     }
@@ -1194,6 +_,24 @@
         this.currentFullChunkStatus = to;
     }
 
+    // ShreddedPaper start - ensure write lock
+    public boolean ensureFullStatusChangeWithWriteLock() {
+        // Upgrading to a full loaded chunk is just a chunk load task, which does not require the write lock
+        // However, upgrading to block ticking or entity ticking is more than just loading a chunk, and requires us to have the write lock
+        ChunkPos chunkPos = this.vanillaChunkHolder.getPos();
+        RegionPos regionPos = RegionPos.forChunk(chunkPos);
+        if (!MinecraftServer.getServer().forceTicks && !this.world.chunkScheduler.getRegionLocker().hasWriteLock(regionPos)) {
+            ShreddedPaper.runSync(world, chunkPos, () -> {
+                List<NewChunkHolder> changedFullStatus2 = new ArrayList<>();
+                handleFullStatusChange(changedFullStatus2);
+                this.scheduler.chunkHolderManager.addChangedStatuses(changedFullStatus2);
+            });
+            return false;
+        }
+        return true;
+    }
+    // ShreddedPaper end - ensure write lock
+
     // only to be called on the main thread, no locks need to be held
     public boolean handleFullStatusChange(final List<NewChunkHolder> changedFullStatus) {
         TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot update full status thread off-main");
@@ -1256,6 +_,7 @@
                     }
 
                     if (!current.isOrAfter(FullChunkStatus.BLOCK_TICKING) && pending.isOrAfter(FullChunkStatus.BLOCK_TICKING)) {
+                        if (!ensureFullStatusChangeWithWriteLock()) return ret; // ShreddedPaper
                         this.updateCurrentState(FullChunkStatus.BLOCK_TICKING);
                         this.changeEntityChunkStatus(FullChunkStatus.BLOCK_TICKING);
                         PlatformHooks.get().onChunkTicking(chunk, this.vanillaChunkHolder);
@@ -1263,6 +_,7 @@
                     }
 
                     if (!current.isOrAfter(FullChunkStatus.ENTITY_TICKING) && pending.isOrAfter(FullChunkStatus.ENTITY_TICKING)) {
+                        if (!ensureFullStatusChangeWithWriteLock()) return ret; // ShreddedPaper
                         this.updateCurrentState(FullChunkStatus.ENTITY_TICKING);
                         this.changeEntityChunkStatus(FullChunkStatus.ENTITY_TICKING);
                         PlatformHooks.get().onChunkEntityTicking(chunk, this.vanillaChunkHolder);
