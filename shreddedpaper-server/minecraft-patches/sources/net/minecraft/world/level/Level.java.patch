--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -3,6 +_,7 @@
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -10,6 +_,10 @@
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
+
+import io.multipaper.shreddedpaper.region.LevelChunkRegion;
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.multipaper.shreddedpaper.threading.PerThreadNeighborUpdater;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -75,6 +_,7 @@
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.level.redstone.CollectingNeighborUpdater;
+import net.minecraft.world.level.redstone.NeighborUpdater;
 import net.minecraft.world.level.redstone.Orientation;
 import net.minecraft.world.level.saveddata.maps.MapId;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
@@ -112,9 +_,9 @@
         .add(new ExplosionParticleInfo(ParticleTypes.POOF, 0.5F, 1.0F))
         .add(new ExplosionParticleInfo(ParticleTypes.SMOKE, 1.0F, 1.0F))
         .build();
-    public final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList();
-    protected final CollectingNeighborUpdater neighborUpdater;
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList();
+    // public final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList(); // ShreddedPaper - handle block entities ourselves
+    protected final NeighborUpdater neighborUpdater; // ShreddedPaper - thread safe CollectingNeighborUpdater
+    // private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList(); // ShreddedPaper - handle block entities ourselves
     private boolean tickingBlockEntities;
     public final Thread thread;
     private final boolean isDebug;
@@ -143,12 +_,11 @@
     private final CraftWorld world;
     public org.bukkit.generator.@Nullable ChunkGenerator generator;
 
-    public boolean captureBlockStates = false;
-    public boolean captureTreeGeneration = false;
-    public Map<BlockPos, org.bukkit.craftbukkit.block.CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
-    public Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper - Retain block place order when capturing blockstates
-    @Nullable
-    public List<net.minecraft.world.entity.item.ItemEntity> captureDrops;
+    public ThreadLocal<Boolean> captureBlockStatesThreadLocal = ThreadLocal.withInitial(() -> false); // ShreddedPaper - use thread local
+    public ThreadLocal<Boolean> captureTreeGenerationThreadLocal = ThreadLocal.withInitial(() -> false); // ShreddedPaper - use thread local
+    public ThreadLocal<Map<BlockPos, org.bukkit.craftbukkit.block.CraftBlockState>> capturedBlockStatesThreadLocal = ThreadLocal.withInitial(() -> new java.util.LinkedHashMap<>()); // Paper // ShreddedPaper - use thread local
+    public ThreadLocal<Map<BlockPos, BlockEntity>> capturedTileEntitiesThreadLocal = ThreadLocal.withInitial(() -> new java.util.LinkedHashMap<>()); // Paper - Retain block place order when capturing blockstates // ShreddedPaper - use thread local
+    public ThreadLocal<@Nullable List<net.minecraft.world.entity.item.ItemEntity>> captureDropsThreadLocal = new ThreadLocal<>(); // ShreddedPaper - use thread local
     public final it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<SpawnCategory> ticksPerSpawnCategory = new it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<>();
     // Paper start - EAR 2
     public int wakeupInactiveRemainingAnimals;
@@ -156,7 +_,7 @@
     public int wakeupInactiveRemainingMonsters;
     public int wakeupInactiveRemainingVillagers;
     // Paper end - EAR 2
-    public boolean populating;
+    public final ThreadLocal<Boolean> populatingThreadLocal = ThreadLocal.withInitial(() -> false); // ShreddedPaper - thread local for populating
     public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
     // Paper start - add paper world config
     private final io.papermc.paper.configuration.WorldConfiguration paperConfig;
@@ -167,9 +_,9 @@
 
     public final org.purpurmc.purpur.PurpurWorldConfig purpurConfig; // Purpur - Purpur config files
     public static @Nullable BlockPos lastPhysicsProblem; // Spigot
-    private int tileTickPosition;
+    // private int tileTickPosition; // ShreddedPaper - removed tileTickPosition
     public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new java.util.HashMap<>(); // Paper - Optimize explosions
-    public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Faster redstone torch rapid clock removal; Move from Map in BlockRedstoneTorch to here
+    // public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Faster redstone torch rapid clock removal; Move from Map in BlockRedstoneTorch to here // ShreddedPaper - move to LevelChunkRegion
 
     // Purpur start - Add adjustable breeding cooldown to config
     private com.google.common.cache.Cache<BreedingCooldownPair, Object> playerBreedingCooldowns;
@@ -907,7 +_,7 @@
         this.thread = Thread.currentThread();
         this.biomeManager = new BiomeManager(this, biomeZoomSeed);
         this.isDebug = isDebug;
-        this.neighborUpdater = new CollectingNeighborUpdater(this, maxChainedNeighborUpdates);
+        this.neighborUpdater = new PerThreadNeighborUpdater(() -> new CollectingNeighborUpdater(this, maxChainedNeighborUpdates)); // ShreddedPaper - thread safe CollectingNeighborUpdater
         this.registryAccess = registryAccess;
         this.palettedContainerFactory = PalettedContainerFactory.create(registryAccess);
         this.damageSources = new DamageSources(registryAccess);
@@ -1025,8 +_,8 @@
     @Nullable
     public final BlockState getBlockStateIfLoaded(BlockPos pos) {
         // CraftBukkit start - tree generation
-        if (this.captureTreeGeneration) {
-            CraftBlockState previous = this.capturedBlockStates.get(pos);
+        if (this.captureTreeGenerationThreadLocal.get()) { // ShreddedPaper - use thread local
+            CraftBlockState previous = this.capturedBlockStatesThreadLocal.get().get(pos); // ShreddedPaper - use thread local
             if (previous != null) {
                 return previous.getHandle();
             }
@@ -1090,15 +_,15 @@
     @Override
     public boolean setBlock(BlockPos pos, BlockState state, @Block.UpdateFlags int flags, int recursionLeft) {
         // CraftBukkit start - tree generation
-        if (this.captureTreeGeneration) {
+        if (this.captureTreeGenerationThreadLocal.get()) { // ShreddedPaper - use thread local
             // Paper start - Protect Bedrock and End Portal/Frames from being destroyed
             BlockState type = getBlockState(pos);
             if (!type.isDestroyable()) return false;
             // Paper end - Protect Bedrock and End Portal/Frames from being destroyed
-            CraftBlockState blockstate = this.capturedBlockStates.get(pos);
+            CraftBlockState blockstate = this.capturedBlockStatesThreadLocal.get().get(pos); // ShreddedPaper - use thread local
             if (blockstate == null) {
                 blockstate = org.bukkit.craftbukkit.block.CapturedBlockState.getTreeBlockState(this, pos, flags);
-                this.capturedBlockStates.put(pos.immutable(), blockstate);
+                this.capturedBlockStatesThreadLocal.get().put(pos.immutable(), blockstate); // ShreddedPaper - use thread local
             }
             blockstate.setData(state);
             blockstate.setFlags(flags);
@@ -1114,14 +_,14 @@
             Block block = state.getBlock();
             // CraftBukkit start - capture blockstates
             boolean captured = false;
-            if (this.captureBlockStates) {
+            if (this.captureBlockStatesThreadLocal.get()) { // ShreddedPaper - use thread local
                 final CraftBlockState snapshot;
-                if (!this.capturedBlockStates.containsKey(pos)) {
+                if (!this.capturedBlockStatesThreadLocal.get().containsKey(pos)) { // ShreddedPaper - use thread local
                     snapshot = (CraftBlockState) org.bukkit.craftbukkit.block.CraftBlock.at(this, pos).getState(); // Paper - use CB getState to get a suitable snapshot
-                    this.capturedBlockStates.put(pos.immutable(), snapshot);
+                    this.capturedBlockStatesThreadLocal.get().put(pos.immutable(), snapshot); // ShreddedPaper - use thread local
                     captured = true;
                 } else {
-                    snapshot = this.capturedBlockStates.get(pos);
+                    snapshot = this.capturedBlockStatesThreadLocal.get().get(pos); // ShreddedPaper - use thread local
                 }
                 snapshot.setFlags(flags); // Paper - always set the flag of the most recent call to mitigate issues with multiple update at the same pos with different flags
             }
@@ -1130,8 +_,8 @@
             // CraftBukkit end
             if (blockState == null) {
                 // CraftBukkit start - remove blockstate if failed (or the same)
-                if (this.captureBlockStates && captured) {
-                    this.capturedBlockStates.remove(pos);
+                if (this.captureBlockStatesThreadLocal.get() && captured) { // ShreddedPaper - use thread local
+                    this.capturedBlockStatesThreadLocal.get().remove(pos); // ShreddedPaper - use thread local
                 }
                 // CraftBukkit end
                 return false;
@@ -1168,7 +_,7 @@
                 */
 
                 // CraftBukkit start
-                if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
+                if (!this.captureBlockStatesThreadLocal.get()) { // Don't notify clients or update physics while capturing blockstates // ShreddedPaper - use thread local
                     // Modularize client and physic updates
                     // Spigot start
                     try {
@@ -1334,8 +_,8 @@
     @Override
     public BlockState getBlockState(BlockPos pos) {
         // CraftBukkit start - tree generation
-        if (this.captureTreeGeneration) {
-            CraftBlockState previous = this.capturedBlockStates.get(pos); // Paper
+        if (this.captureTreeGenerationThreadLocal.get()) { // ShreddedPaper - use thread local
+            CraftBlockState previous = this.capturedBlockStatesThreadLocal.get().get(pos); // Paper // ShreddedPaper - use thread local
             if (previous != null) {
                 return previous.getHandle();
             }
@@ -1433,15 +_,25 @@
     }
 
     public void addBlockEntityTicker(TickingBlockEntity ticker) {
-        (this.tickingBlockEntities ? this.pendingBlockEntityTickers : this.blockEntityTickers).add(ticker);
+        // ShreddedPaper start - handle block entities ourselves
+        LevelChunkRegion region = ((ServerLevel) this).chunkSource.tickingRegions.getOrCreate(RegionPos.forChunk(new ChunkPos(ticker.getPos())));
+        synchronized (region.pendingBlockEntityTickers) {
+            region.pendingBlockEntityTickers.add(ticker);
+        }
+        // ShreddedPaper end - handle block entities ourselves
+//        (this.tickingBlockEntities ? this.pendingBlockEntityTickers : this.blockEntityTickers).add(ticker); // ShreddedPaper - handle block entities ourselves
     }
 
-    public void tickBlockEntities() {
+    public void tickBlockEntities(final List<TickingBlockEntity> blockEntityTickers, final List<TickingBlockEntity> pendingBlockEntityTickers) { // ShreddedPaper - handle block entities ourselves
         this.tickingBlockEntities = true;
-        if (!this.pendingBlockEntityTickers.isEmpty()) {
-            this.blockEntityTickers.addAll(this.pendingBlockEntityTickers);
-            this.pendingBlockEntityTickers.clear();
+        // ShreddedPaper start - handle block entities ourselves
+        if (!pendingBlockEntityTickers.isEmpty()) {
+            synchronized (pendingBlockEntityTickers) {
+                blockEntityTickers.addAll(pendingBlockEntityTickers);
+                pendingBlockEntityTickers.clear();
+            }
         }
+        // ShreddedPaper end - handle block entities ourselves
 
         // Spigot start
         boolean runsNormally = this.tickRateManager().runsNormally();
@@ -1449,8 +_,8 @@
         int tickedEntities = 0; // Paper - rewrite chunk system
         var toRemove = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<TickingBlockEntity>(); // Paper - Fix MC-117075; use removeAll
         toRemove.add(null); // Paper - Fix MC-117075
-        for (this.tileTickPosition = 0; this.tileTickPosition < this.blockEntityTickers.size(); this.tileTickPosition++) { // Paper - Disable tick limiters
-            TickingBlockEntity tickingBlockEntity = this.blockEntityTickers.get(this.tileTickPosition);
+        for (int tileTickPosition = 0; tileTickPosition < blockEntityTickers.size(); tileTickPosition++) { // Paper - Disable tick limiters // ShreddedPaper - handle block entities ourselves
+            TickingBlockEntity tickingBlockEntity = blockEntityTickers.get(tileTickPosition); // ShreddedPaper - handle block entities ourselves
             // Spigot end
             if (tickingBlockEntity.isRemoved()) {
                 toRemove.add(tickingBlockEntity); // Paper - Fix MC-117075; use removeAll
@@ -1463,7 +_,7 @@
                 // Paper end - rewrite chunk system
             }
         }
-        this.blockEntityTickers.removeAll(toRemove); // Paper - Fix MC-117075
+        blockEntityTickers.removeAll(toRemove); // Paper - Fix MC-117075 // ShreddedPaper - handle block entities ourselves
 
         this.tickingBlockEntities = false;
         this.spigotConfig.currentPrimedTnt = 0; // Spigot
@@ -1480,7 +_,7 @@
             entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
             // Paper end - Prevent block entity and entity crashes
         }
-        this.moonrise$midTickTasks(); // Paper - rewrite chunk system
+        // this.moonrise$midTickTasks(); // Paper - rewrite chunk system // ShreddedPaper - disable
     }
 
     // Paper start - Option to prevent armor stands from doing entity lookups
@@ -1623,7 +_,7 @@
     public @Nullable BlockEntity getBlockEntity(BlockPos pos) {
         // Paper start - Perf: Optimize capturedTileEntities lookup
         net.minecraft.world.level.block.entity.BlockEntity blockEntity;
-        if (!this.capturedTileEntities.isEmpty() && (blockEntity = this.capturedTileEntities.get(pos)) != null) {
+        if (!this.capturedTileEntitiesThreadLocal.get().isEmpty() && (blockEntity = this.capturedTileEntitiesThreadLocal.get().get(pos)) != null) { // ShreddedPaper - use thread local
             return blockEntity;
         }
         // Paper end - Perf: Optimize capturedTileEntities lookup
@@ -1640,8 +_,8 @@
         BlockPos blockPos = blockEntity.getBlockPos();
         if (this.isInValidBounds(blockPos)) {
             // CraftBukkit start
-            if (this.captureBlockStates) {
-                this.capturedTileEntities.put(blockPos.immutable(), blockEntity);
+            if (this.captureBlockStatesThreadLocal.get()) { // ShreddedPaper - use thread local
+                this.capturedTileEntitiesThreadLocal.get().put(blockPos.immutable(), blockEntity); // ShreddedPaper - use thread local
                 return;
             }
             // CraftBukkit end
