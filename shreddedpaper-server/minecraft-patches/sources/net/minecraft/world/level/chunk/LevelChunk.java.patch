--- a/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/net/minecraft/world/level/chunk/LevelChunk.java
@@ -6,6 +_,8 @@
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.shorts.ShortList;
+
+import java.lang.ref.Reference;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -22,6 +_,7 @@
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkPacketData;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.ProblemReporter;
@@ -85,7 +_,7 @@
             return "<null>";
         }
     };
-    private final Map<BlockPos, LevelChunk.RebindableTickingBlockEntityWrapper> tickersInLevel = Maps.newHashMap();
+    private final Map<BlockPos, LevelChunk.RebindableTickingBlockEntityWrapper> tickersInLevel = Maps.newConcurrentMap(); // ShreddedPaper - use concurrent map
     public boolean loaded;
     public final ServerLevel level; // CraftBukkit - type
     private @Nullable Supplier<FullChunkStatus> fullStatus;
@@ -93,6 +_,8 @@
     private final Int2ObjectMap<GameEventListenerRegistry> gameEventListenerRegistrySections;
     private final LevelChunkTicks<Block> blockTicks;
     private final LevelChunkTicks<Fluid> fluidTicks;
+    public @Nullable Reference<ClientboundLevelChunkWithLightPacket> cachedChunkPacket; // ShreddedPaper
+    public long cachedChunkPacketLastAccessed; // ShreddedPaper
     private LevelChunk.UnsavedListener unsavedListener = chunkPos -> {};
     // CraftBukkit start
     public boolean mustNotSave;
@@ -421,7 +_,7 @@
                 if (!section.getBlockState(i, i1, i2).is(block)) {
                     return null;
                 } else {
-                    if (!this.level.isClientSide() && (flags & Block.UPDATE_SKIP_ON_PLACE) == 0 && (!this.level.captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
+                    if (!this.level.isClientSide() && (flags & Block.UPDATE_SKIP_ON_PLACE) == 0 && (!this.level.captureBlockStates.get() || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled. // ShreddedPaper - thread local
                         state.onPlace(this.level, pos, blockState, flag1);
                     }
 
@@ -473,7 +_,7 @@
 
     public @Nullable BlockEntity getBlockEntity(BlockPos pos, LevelChunk.EntityCreationType creationType) {
         // CraftBukkit start
-        BlockEntity blockEntity = this.level.capturedTileEntities.get(pos);
+        BlockEntity blockEntity = this.level.capturedTileEntities.get().get(pos); // ShreddedPaper - thread local
         if (blockEntity == null) {
             blockEntity = this.blockEntities.get(pos);
         }
@@ -661,13 +_,13 @@
 
                 org.bukkit.World world = this.level.getWorld();
                 if (world != null) {
-                    this.level.populating = true;
+                    this.level.populatingThreadLocal.set(true); // ShreddedPaper - thread local for populating
                     try {
                         for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
                             populator.populate(world, random, bukkitChunk);
                         }
                     } finally {
-                        this.level.populating = false;
+                        this.level.populatingThreadLocal.remove(); // ShreddedPaper - thread local for populating
                     }
                 }
                 server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
