--- a/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -64,7 +_,7 @@
     private final Function<BlockState, VoxelShape> shapes;
     private final BlockState crossState;
     private final RedstoneWireEvaluator evaluator = new DefaultRedstoneWireEvaluator(this);
-    public boolean shouldSignal = true;
+    public final ThreadLocal<Boolean> shouldSignalThreadLocal = ThreadLocal.withInitial(() -> true); // ShreddedPaper - use thread local for shouldSignal
 
     @Override
     public MapCodec<RedStoneWireBlock> codec() {
@@ -266,7 +_,7 @@
 
     // Paper start - Optimize redstone (Eigencraft)
     // The bulk of the new functionality is found in RedstoneWireTurbo.java
-    io.papermc.paper.redstone.RedstoneWireTurbo turbo = new io.papermc.paper.redstone.RedstoneWireTurbo(this);
+    final ThreadLocal<io.papermc.paper.redstone.RedstoneWireTurbo> turboThreadLocal = ThreadLocal.withInitial(() -> new io.papermc.paper.redstone.RedstoneWireTurbo(this)); // ShreddedPaper - thread local for turbo
 
     /*
      * Modified version of pre-existing updateSurroundingRedstone, which is called from
@@ -282,7 +_,7 @@
             if (orientation != null) {
                 source = pos.relative(orientation.getFront().getOpposite());
             }
-            turbo.updateSurroundingRedstone(worldIn, pos, state, source);
+            turboThreadLocal.get().updateSurroundingRedstone(worldIn, pos, state, source); // ShreddedPaper - thread local for turbo
             return;
         }
         updatePowerStrength(worldIn, pos, state, orientation, blockAdded);
@@ -310,7 +_,7 @@
                 // [Space Walker] suppress shape updates and emit those manually to
                 // bypass the new neighbor update stack.
                 if (level.setBlock(pos, state, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_CLIENTS)) {
-                    turbo.updateNeighborShapes(level, pos, state);
+                    turboThreadLocal.get().updateNeighborShapes(level, pos, state); // ShreddedPaper - thread local for turbo
                 }
             }
         }
@@ -327,9 +_,9 @@
     }
 
     public int getBlockSignal(Level level, BlockPos pos) {
-        this.shouldSignal = false;
+        this.shouldSignalThreadLocal.set(false); // ShreddedPaper - use thread local for shouldSignal
         int bestNeighborSignal = level.getBestNeighborSignal(pos);
-        this.shouldSignal = true;
+        this.shouldSignalThreadLocal.remove(); // ShreddedPaper - use thread local for shouldSignal
         return bestNeighborSignal;
     }
 
@@ -421,12 +_,12 @@
 
     @Override
     protected int getDirectSignal(BlockState state, BlockGetter level, BlockPos pos, Direction side) {
-        return !this.shouldSignal ? 0 : state.getSignal(level, pos, side);
+        return !this.shouldSignalThreadLocal.get() ? 0 : state.getSignal(level, pos, side); // ShreddedPaper - use thread local for shouldSignal
     }
 
     @Override
     protected int getSignal(BlockState state, BlockGetter level, BlockPos pos, Direction side) {
-        if (this.shouldSignal && side != Direction.DOWN) {
+        if (this.shouldSignalThreadLocal.get() && side != Direction.DOWN) { // ShreddedPaper - use thread local for shouldSignal
             int powerValue = state.getValue(POWER);
             if (powerValue == 0) {
                 return 0;
@@ -458,7 +_,7 @@
 
     @Override
     protected boolean isSignalSource(BlockState state) {
-        return this.shouldSignal;
+        return this.shouldSignalThreadLocal.get(); // ShreddedPaper - use thread local for shouldSignal
     }
 
     public static int getColorForPower(int power) {
