--- a/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -219,11 +_,11 @@
 
     // Paper start - Perf: Optimize Hoppers
     public static boolean skipHopperEvents;
-    private static boolean skipPullModeEventFire;
-    private static boolean skipPushModeEventFire;
+    private static final ThreadLocal<Boolean> skipPullModeEventFireThreadLocal = ThreadLocal.withInitial(() -> false); // ShreddedPaper - use thread local for skipPullModeEventFire
+    private static final ThreadLocal<Boolean> skipPushModeEventFireThreadLocal = ThreadLocal.withInitial(() -> false); // ShreddedPaper - use thread local for skipPushModeEventFire
 
     private static boolean hopperPush(final Level level, final Container destination, final Direction direction, final HopperBlockEntity hopper) {
-        skipPushModeEventFire = skipHopperEvents;
+        skipPushModeEventFireThreadLocal.set(skipHopperEvents); // ShreddedPaper - use thread local for skipPushModeEventFire
         boolean foundItem = false;
         for (int i = 0; i < hopper.getContainerSize(); ++i) {
             final ItemStack item = hopper.getItem(i);
@@ -238,7 +_,7 @@
 
                 // We only need to fire the event once to give protection plugins a chance to cancel this event
                 // Because nothing uses getItem, every event call should end up the same result.
-                if (!skipPushModeEventFire) {
+                if (!skipPushModeEventFireThreadLocal.get()) { // ShreddedPaper - use thread local for skipPushModeEventFire
                     movedItem = callPushMoveEvent(destination, movedItem, hopper);
                     if (movedItem == null) { // cancelled
                         origItemStack.setCount(originalItemCount);
@@ -274,7 +_,7 @@
         container.setChanged(); // original logic always marks source inv as changed even if no move happens.
         movedItem.setCount(movedItemCount);
 
-        if (!skipPullModeEventFire) {
+        if (!skipPullModeEventFireThreadLocal.get()) { // ShreddedPaper - use thread local for skipPullModeEventFire
             movedItem = callPullMoveEvent(hopper, container, movedItem);
             if (movedItem == null) { // cancelled
                 origItemStack.setCount(originalItemCount);
@@ -294,9 +_,9 @@
                 origItemStack.setCount(originalItemCount - movedItemCount + remainingItemCount);
             }
 
-            ignoreBlockEntityUpdates = true;
+            ignoreBlockEntityUpdatesThreadLocal.set(true); // ShreddedPaper - use thread local for ignoreBlockEntityUpdates
             container.setItem(i, origItemStack);
-            ignoreBlockEntityUpdates = false;
+            ignoreBlockEntityUpdatesThreadLocal.remove(); // ShreddedPaper - use thread local for ignoreBlockEntityUpdates
             container.setChanged();
             return true;
         }
@@ -320,7 +_,7 @@
         );
         final boolean result = event.callEvent();
         if (!event.calledGetItem && !event.calledSetItem) {
-            skipPushModeEventFire = true;
+            skipPushModeEventFireThreadLocal.set(true); // ShreddedPaper - use thread local for skipPushModeEventFire
         }
         if (!result) {
             applyCooldown(hopper);
@@ -343,7 +_,7 @@
         final io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent event = new io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent(sourceInventory, org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack), destination, false);
         final boolean result = event.callEvent();
         if (!event.calledGetItem && !event.calledSetItem) {
-            skipPullModeEventFire = true;
+            skipPullModeEventFireThreadLocal.set(true); // ShreddedPaper - use thread local for skipPullModeEventFire
         }
         if (!result) {
             applyCooldown(hopper);
@@ -534,7 +_,7 @@
         Container sourceContainer = getSourceContainer(level, hopper, blockPos, blockState);
         if (sourceContainer != null) {
             Direction direction = Direction.DOWN;
-            skipPullModeEventFire = skipHopperEvents; // Paper - Perf: Optimize Hoppers
+            skipPullModeEventFireThreadLocal.set(skipHopperEvents); // Paper - Perf: Optimize Hoppers // ShreddedPaper - use thread local for skipPullModeEventFire
 
             for (int i : getSlots(sourceContainer, direction)) {
                 if (tryTakeInItemFromSlot(hopper, sourceContainer, i, direction, level)) { // Spigot
@@ -683,9 +_,9 @@
                     stack = stack.split(destination.getMaxStackSize());
                 }
                 // Spigot end
-                ignoreBlockEntityUpdates = true; // Paper - Perf: Optimize Hoppers
+                ignoreBlockEntityUpdatesThreadLocal.set(true); // Paper - Perf: Optimize Hoppers // ShreddedPaper - use thread local for ignoreBlockEntityUpdates
                 destination.setItem(slot, stack);
-                ignoreBlockEntityUpdates = false; // Paper - Perf: Optimize Hoppers
+                ignoreBlockEntityUpdatesThreadLocal.remove(); // Paper - Perf: Optimize Hoppers // ShreddedPaper - use thread local for ignoreBlockEntityUpdates
                 stack = leftover; // Paper - Make hoppers respect inventory max stack size
                 flag = true;
             } else if (canMergeItems(item, stack)) {
