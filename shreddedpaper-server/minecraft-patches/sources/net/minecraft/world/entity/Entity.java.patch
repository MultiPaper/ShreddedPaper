--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -1,11 +_,14 @@
 package net.minecraft.world.entity;
 
+import ca.spottedleaf.moonrise.common.util.TickThread;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.common.collect.ImmutableList.Builder;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Codec;
+import io.multipaper.shreddedpaper.ShreddedPaper;
+import io.multipaper.shreddedpaper.region.RegionPos;
 import it.unimi.dsi.fastutil.floats.FloatArraySet;
 import it.unimi.dsi.fastutil.floats.FloatArrays;
 import it.unimi.dsi.fastutil.floats.FloatSet;
@@ -24,6 +_,7 @@
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiConsumer;
 import java.util.function.Predicate;
@@ -148,6 +_,7 @@
 import net.minecraft.world.scores.ScoreHolder;
 import net.minecraft.world.scores.Team;
 import net.minecraft.world.waypoints.WaypointTransmitter;
+import org.bukkit.craftbukkit.util.CraftLocation;
 import org.jetbrains.annotations.Contract;
 import org.jspecify.annotations.Nullable;
 import org.slf4j.Logger;
@@ -283,6 +_,8 @@
     public double xOld;
     public double yOld;
     public double zOld;
+    public @Nullable ChunkPos previousTickingChunkPosRegion; // ShreddedPaper
+    public @Nullable ChunkPos previousTrackedChunkPosRegion; // ShreddedPaper
     public float maxUpStep; // Purpur - Add option to set armorstand step height
     public boolean noPhysics;
     public final RandomSource random; // Paper - Share random for entities to make them more random // Add toggle for RNG manipulation
@@ -709,7 +_,7 @@
     public void resendPossiblyDesyncedEntityData(net.minecraft.server.level.ServerPlayer player) {
         if (player.getBukkitEntity().canSee(this.getBukkitEntity())) {
             ServerLevel world = (net.minecraft.server.level.ServerLevel)this.level();
-            net.minecraft.server.level.ChunkMap.TrackedEntity tracker = world == null ? null : world.getChunkSource().chunkMap.entityMap.get(this.getId());
+            net.minecraft.server.level.ChunkMap.TrackedEntity tracker = this.moonrise$getTrackedEntity(); // world == null ? null : world.getChunkSource().chunkMap.entityMap.get(this.getId()); // ShreddedPaper - don't use map
             if (tracker == null) {
                 return;
             }
@@ -830,6 +_,14 @@
     }
 
     public void setPos(double x, double y, double z) {
+        // ShreddedPaper start
+        Vec3 vec3 = new Vec3(x, y, z);
+        if (!this.firstTick && (!TickThread.isTickThreadFor(level, vec3) || !TickThread.isTickThreadFor(this))) {
+            LOGGER.error("Trying to async move {} to {} {} {}", this, x, y, z);
+            TickThread.ensureTickThread(this, "Cannot async move entity");
+            TickThread.ensureTickThread(level, BlockPos.containing(vec3), "Cannot move entity to async destination");
+        }
+        // ShreddedPaper end
         this.setPosRaw(x, y, z, true); // Paper - Block invalid positions and bounding box; force update
         // this.setBoundingBox(this.makeBoundingBox()); // Paper - Block invalid positions and bounding box; move into setPosRaw
     }
@@ -1148,7 +_,9 @@
     public void move(MoverType type, Vec3 movement) {
         final Vec3 originalMovement = movement; // Paper - Expose pre-collision velocity
         // Paper start - detailed watchdog information
-        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot move an entity off-main");
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot move an entity off-main"); // ShreddedPaper
+        BlockPos newPos = new BlockPos((int) (this.getX() + movement.x), (int) (this.getY() + movement.y), (int) (this.getZ() + movement.z)); // ShreddedPaper - check destination region
+        TickThread.ensureTickThread((ServerLevel) this.level, newPos, "Cannot move an entity into off-main"); // ShreddedPaper - check destination region
         synchronized (this.posLock) {
             this.moveStartX = this.getX();
             this.moveStartY = this.getY();
@@ -1476,7 +_,7 @@
     }
 
     protected BlockPos getOnPos(float yOffset) {
-        if (this.mainSupportingBlockPos.isPresent() && this.level().getChunkIfLoadedImmediately(this.mainSupportingBlockPos.get()) != null) { // Paper - ensure no loads
+        if (this.mainSupportingBlockPos.isPresent() && this.level().getChunkIfLoadedImmediately(this.mainSupportingBlockPos.get()) != null && TickThread.isTickThreadFor((ServerLevel) this.level(), this.mainSupportingBlockPos.get())) { // Paper - ensure no loads // ShreddedPaper - ensure same region
             BlockPos blockPos = this.mainSupportingBlockPos.get();
             if (!(yOffset > 1.0E-5F)) {
                 return blockPos;
@@ -3546,7 +_,9 @@
         }
     }
 
+    private @Nullable CompletableFuture<Void> beingPortalled = null; // ShreddedPaper - async teleportation
     protected void handlePortal() {
+        if (this.beingPortalled != null && !this.beingPortalled.isDone()) return; // Currently being teleported by a portal // ShreddedPaper - async teleportation
         if (this.level() instanceof ServerLevel serverLevel) {
             this.processPortalCooldown();
             if (this.portalProcess != null) {
@@ -3554,15 +_,19 @@
                     ProfilerFiller profilerFiller = Profiler.get();
                     profilerFiller.push("portal");
                     this.setPortalCooldown();
-                    TeleportTransition portalDestination = this.portalProcess.getPortalDestination(serverLevel, this);
+                    this.beingPortalled = this.portalProcess.getPortalDestinationAsync(serverLevel, this).thenCompose(portalDestination -> { // ShreddedPaper - async teleportation
                     if (portalDestination != null) {
+                        return CompletableFuture.runAsync(() -> { // ShreddedPaper - async teleportation
                         ServerLevel level = portalDestination.newLevel();
                         if (serverLevel.isAllowedToEnterPortal(level) && (level.dimension() == serverLevel.dimension() || this.canTeleport(serverLevel, level))
                             )
                          {
                             this.teleport(portalDestination);
                         }
+                        }, r -> ShreddedPaper.ensureSync(this, portalDestination.newLevel(), ChunkPos.of(BlockPos.containing(portalDestination.position())), r)); // ShreddedPaper - async teleportation
                     }
+                    return CompletableFuture.completedFuture(null); // ShreddedPaper - async teleportation
+                    }).thenRun(() -> this.beingPortalled = null); // ShreddedPaper - async teleportation
 
                     profilerFiller.pop();
                 } else if (this.portalProcess.hasExpired()) {
@@ -4064,6 +_,11 @@
             PositionMoveRotation absolutePosition = PositionMoveRotation.calculateAbsolute(PositionMoveRotation.of(this), PositionMoveRotation.of(teleportTransition), teleportTransition.relatives());
             Vec3 velocity = absolutePosition.deltaMovement(); // Paper
             org.bukkit.Location to = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(absolutePosition.position(), teleportTransition.newLevel(), absolutePosition.yRot(), absolutePosition.xRot());
+            if (!TickThread.isTickThreadFor(this) || !TickThread.isTickThreadFor(teleportTransition.newLevel(), absolutePosition.position())) { // ShreddedPaper
+                LOGGER.error("Trying to teleport {} to {}", this, to); // ShreddedPaper
+                TickThread.ensureTickThread(this, "Cannot teleport entity async"); // ShreddedPaper
+                TickThread.ensureTickThread(teleportTransition.newLevel(), CraftLocation.toBlockPosition(to), "Cannot teleport entity to async destination"); // ShreddedPaper
+            } // ShreddedPaper
             // Paper start - gateway-specific teleport event
             final org.bukkit.event.entity.EntityTeleportEvent teleEvent;
             if (this.portalProcess != null && this.portalProcess.isSamePortal(((net.minecraft.world.level.block.EndGatewayBlock) Blocks.END_GATEWAY)) && this.level.getBlockEntity(this.portalProcess.getEntryPosition()) instanceof net.minecraft.world.level.block.entity.TheEndGatewayBlockEntity theEndGatewayBlockEntity) {
@@ -4996,6 +_,12 @@
 
     public void setDeltaMovement(Vec3 deltaMovement) {
         if (deltaMovement.isFinite()) {
+            // ShreddedPaper start - why is something setting the entity velocity to larger than one region...
+            if (deltaMovement.horizontalDistanceSqr() > RegionPos.MAX_DISTANCE_SQR + 1 && deltaMovement.horizontalDistanceSqr() > this.deltaMovement.horizontalDistanceSqr()) {
+                LOGGER.warn("Velocity is being set larger than the ShreddedPaper region size: {} for entity {}", deltaMovement, this, new Exception("Velocity larger than region size, limiting velocity to region size"));
+                deltaMovement = deltaMovement.normalize().scale(RegionPos.MAX_DISTANCE_SQR);
+            }
+            // ShreddedPaper end - why is something setting the entity velocity to larger than one region...
             synchronized (this.posLock) { // Paper - detailed watchdog information
             this.deltaMovement = deltaMovement;
             } // Paper - detailed watchdog information
