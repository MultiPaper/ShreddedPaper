--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -1,5 +_,6 @@
 package net.minecraft.world.entity;
 
+import ca.spottedleaf.moonrise.common.util.TickThread;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
@@ -148,6 +_,7 @@
 import net.minecraft.world.scores.ScoreHolder;
 import net.minecraft.world.scores.Team;
 import net.minecraft.world.waypoints.WaypointTransmitter;
+import org.bukkit.craftbukkit.util.CraftLocation;
 import org.jetbrains.annotations.Contract;
 import org.jspecify.annotations.Nullable;
 import org.slf4j.Logger;
@@ -283,6 +_,8 @@
     public double xOld;
     public double yOld;
     public double zOld;
+    public @Nullable ChunkPos previousTickingChunkPosRegion; // ShreddedPaper
+    public @Nullable ChunkPos previousTrackedChunkPosRegion; // ShreddedPaper
     public float maxUpStep; // Purpur - Add option to set armorstand step height
     public boolean noPhysics;
     public final RandomSource random; // Paper - Share random for entities to make them more random // Add toggle for RNG manipulation
@@ -708,7 +_,7 @@
     public void resendPossiblyDesyncedEntityData(net.minecraft.server.level.ServerPlayer player) {
         if (player.getBukkitEntity().canSee(this.getBukkitEntity())) {
             ServerLevel world = (net.minecraft.server.level.ServerLevel)this.level();
-            net.minecraft.server.level.ChunkMap.TrackedEntity tracker = world == null ? null : world.getChunkSource().chunkMap.entityMap.get(this.getId());
+            net.minecraft.server.level.ChunkMap.TrackedEntity tracker = this.moonrise$getTrackedEntity(); // world == null ? null : world.getChunkSource().chunkMap.entityMap.get(this.getId()); // ShreddedPaper - don't use map
             if (tracker == null) {
                 return;
             }
@@ -1147,7 +_,7 @@
     public void move(MoverType type, Vec3 movement) {
         final Vec3 originalMovement = movement; // Paper - Expose pre-collision velocity
         // Paper start - detailed watchdog information
-        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot move an entity off-main");
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot move an entity off-main"); // ShreddedPaper
         synchronized (this.posLock) {
             this.moveStartX = this.getX();
             this.moveStartY = this.getY();
@@ -4064,6 +_,11 @@
             PositionMoveRotation absolutePosition = PositionMoveRotation.calculateAbsolute(PositionMoveRotation.of(this), PositionMoveRotation.of(teleportTransition), teleportTransition.relatives());
             Vec3 velocity = absolutePosition.deltaMovement(); // Paper
             org.bukkit.Location to = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(absolutePosition.position(), teleportTransition.newLevel(), absolutePosition.yRot(), absolutePosition.xRot());
+            if (!TickThread.isTickThreadFor(this) || !TickThread.isTickThreadFor(teleportTransition.newLevel(), absolutePosition.position())) { // ShreddedPaper
+                LOGGER.error("Trying to teleport {} to {}", this, to); // ShreddedPaper
+                TickThread.ensureTickThread(this, "Cannot teleport entity async"); // ShreddedPaper
+                TickThread.ensureTickThread(teleportTransition.newLevel(), CraftLocation.toBlockPosition(to), "Cannot teleport entity to async destination"); // ShreddedPaper
+            } // ShreddedPaper
             // Paper start - gateway-specific teleport event
             final org.bukkit.event.entity.EntityTeleportEvent teleEvent;
             if (this.portalProcess != null && this.portalProcess.isSamePortal(((net.minecraft.world.level.block.EndGatewayBlock) Blocks.END_GATEWAY)) && this.level.getBlockEntity(this.portalProcess.getEntryPosition()) instanceof net.minecraft.world.level.block.entity.TheEndGatewayBlockEntity theEndGatewayBlockEntity) {
@@ -5085,6 +_,14 @@
     }
 
     public final void setPosRaw(double x, double y, double z, boolean forceBoundingBoxUpdate) {
+        // ShreddedPaper start
+        Vec3 vec3 = new Vec3(x, y, z);
+        if (!TickThread.isTickThreadFor(level, vec3) || !TickThread.isTickThreadFor(this)) {
+            LOGGER.error("Trying to async move {} to {} {} {}", this, x, y, z);
+            TickThread.ensureTickThread(this, "Cannot async move entity");
+            TickThread.ensureTickThread(level, vec3.floorToBlockPos(), "Cannot move entity to async destination");
+        }
+        // ShreddedPaper end
         // Paper start - rewrite chunk system
         if (this.updatingSectionStatus) {
             LOGGER.error(
@@ -5100,7 +_,7 @@
         // Paper end - Block invalid positions and bounding box
         if (this.position.x != x || this.position.y != y || this.position.z != z) {
             synchronized (this.posLock) { // Paper - detailed watchdog information
-            this.position = new Vec3(x, y, z);
+            this.position = vec3; // ShreddedPaper - already creating vec3 above, so reuse it
             } // Paper - detailed watchdog information
             int floor = Mth.floor(x);
             int floor1 = Mth.floor(y);
