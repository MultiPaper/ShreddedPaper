--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -1,11 +_,13 @@
 package net.minecraft.world.entity;
 
+import ca.spottedleaf.moonrise.common.util.TickThread;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.common.collect.ImmutableList.Builder;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Codec;
+import io.multipaper.shreddedpaper.ShreddedPaper;
 import it.unimi.dsi.fastutil.floats.FloatArraySet;
 import it.unimi.dsi.fastutil.floats.FloatArrays;
 import it.unimi.dsi.fastutil.floats.FloatSet;
@@ -24,6 +_,7 @@
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiConsumer;
 import java.util.function.Predicate;
@@ -148,6 +_,7 @@
 import net.minecraft.world.scores.ScoreHolder;
 import net.minecraft.world.scores.Team;
 import net.minecraft.world.waypoints.WaypointTransmitter;
+import org.bukkit.craftbukkit.util.CraftLocation;
 import org.jetbrains.annotations.Contract;
 import org.jspecify.annotations.Nullable;
 import org.slf4j.Logger;
@@ -283,6 +_,8 @@
     public double xOld;
     public double yOld;
     public double zOld;
+    public @Nullable ChunkPos previousTickingChunkPosRegion; // ShreddedPaper
+    public @Nullable ChunkPos previousTrackedChunkPosRegion; // ShreddedPaper
     public float maxUpStep; // Purpur - Add option to set armorstand step height
     public boolean noPhysics;
     public final RandomSource random; // Paper - Share random for entities to make them more random // Add toggle for RNG manipulation
@@ -708,7 +_,7 @@
     public void resendPossiblyDesyncedEntityData(net.minecraft.server.level.ServerPlayer player) {
         if (player.getBukkitEntity().canSee(this.getBukkitEntity())) {
             ServerLevel world = (net.minecraft.server.level.ServerLevel)this.level();
-            net.minecraft.server.level.ChunkMap.TrackedEntity tracker = world == null ? null : world.getChunkSource().chunkMap.entityMap.get(this.getId());
+            net.minecraft.server.level.ChunkMap.TrackedEntity tracker = this.moonrise$getTrackedEntity(); // world == null ? null : world.getChunkSource().chunkMap.entityMap.get(this.getId()); // ShreddedPaper - don't use map
             if (tracker == null) {
                 return;
             }
@@ -1147,7 +_,7 @@
     public void move(MoverType type, Vec3 movement) {
         final Vec3 originalMovement = movement; // Paper - Expose pre-collision velocity
         // Paper start - detailed watchdog information
-        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot move an entity off-main");
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot move an entity off-main"); // ShreddedPaper
         synchronized (this.posLock) {
             this.moveStartX = this.getX();
             this.moveStartY = this.getY();
@@ -3546,7 +_,9 @@
         }
     }
 
+    private @Nullable CompletableFuture<Void> beingPortalled = null; // ShreddedPaper - async teleportation
     protected void handlePortal() {
+        if (this.beingPortalled != null && !this.beingPortalled.isDone()) return; // Currently being teleported by a portal // ShreddedPaper - async teleportation
         if (this.level() instanceof ServerLevel serverLevel) {
             this.processPortalCooldown();
             if (this.portalProcess != null) {
@@ -3554,15 +_,19 @@
                     ProfilerFiller profilerFiller = Profiler.get();
                     profilerFiller.push("portal");
                     this.setPortalCooldown();
-                    TeleportTransition portalDestination = this.portalProcess.getPortalDestination(serverLevel, this);
+                    this.beingPortalled = this.portalProcess.getPortalDestinationAsync(serverLevel, this).thenCompose(portalDestination -> { // ShreddedPaper - async teleportation
                     if (portalDestination != null) {
+                        return CompletableFuture.runAsync(() -> { // ShreddedPaper - async teleportation
                         ServerLevel level = portalDestination.newLevel();
                         if (serverLevel.isAllowedToEnterPortal(level) && (level.dimension() == serverLevel.dimension() || this.canTeleport(serverLevel, level))
                             )
                          {
                             this.teleport(portalDestination);
                         }
+                        }, r -> ShreddedPaper.ensureSync(this, portalDestination.newLevel(), ChunkPos.of(BlockPos.containing(portalDestination.position())), r)); // ShreddedPaper - async teleportation
                     }
+                    return CompletableFuture.completedFuture(null); // ShreddedPaper - async teleportation
+                    }).thenRun(() -> this.beingPortalled = null); // ShreddedPaper - async teleportation
 
                     profilerFiller.pop();
                 } else if (this.portalProcess.hasExpired()) {
@@ -4064,6 +_,11 @@
             PositionMoveRotation absolutePosition = PositionMoveRotation.calculateAbsolute(PositionMoveRotation.of(this), PositionMoveRotation.of(teleportTransition), teleportTransition.relatives());
             Vec3 velocity = absolutePosition.deltaMovement(); // Paper
             org.bukkit.Location to = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(absolutePosition.position(), teleportTransition.newLevel(), absolutePosition.yRot(), absolutePosition.xRot());
+            if (!TickThread.isTickThreadFor(this) || !TickThread.isTickThreadFor(teleportTransition.newLevel(), absolutePosition.position())) { // ShreddedPaper
+                LOGGER.error("Trying to teleport {} to {}", this, to); // ShreddedPaper
+                TickThread.ensureTickThread(this, "Cannot teleport entity async"); // ShreddedPaper
+                TickThread.ensureTickThread(teleportTransition.newLevel(), CraftLocation.toBlockPosition(to), "Cannot teleport entity to async destination"); // ShreddedPaper
+            } // ShreddedPaper
             // Paper start - gateway-specific teleport event
             final org.bukkit.event.entity.EntityTeleportEvent teleEvent;
             if (this.portalProcess != null && this.portalProcess.isSamePortal(((net.minecraft.world.level.block.EndGatewayBlock) Blocks.END_GATEWAY)) && this.level.getBlockEntity(this.portalProcess.getEntryPosition()) instanceof net.minecraft.world.level.block.entity.TheEndGatewayBlockEntity theEndGatewayBlockEntity) {
@@ -5085,6 +_,14 @@
     }
 
     public final void setPosRaw(double x, double y, double z, boolean forceBoundingBoxUpdate) {
+        // ShreddedPaper start
+        Vec3 vec3 = new Vec3(x, y, z);
+        if (!TickThread.isTickThreadFor(level, vec3) || !TickThread.isTickThreadFor(this)) {
+            LOGGER.error("Trying to async move {} to {} {} {}", this, x, y, z);
+            TickThread.ensureTickThread(this, "Cannot async move entity");
+            TickThread.ensureTickThread(level, BlockPos.containing(vec3), "Cannot move entity to async destination");
+        }
+        // ShreddedPaper end
         // Paper start - rewrite chunk system
         if (this.updatingSectionStatus) {
             LOGGER.error(
@@ -5100,7 +_,7 @@
         // Paper end - Block invalid positions and bounding box
         if (this.position.x != x || this.position.y != y || this.position.z != z) {
             synchronized (this.posLock) { // Paper - detailed watchdog information
-            this.position = new Vec3(x, y, z);
+            this.position = vec3; // ShreddedPaper - already creating vec3 above, so reuse it
             } // Paper - detailed watchdog information
             int floor = Mth.floor(x);
             int floor1 = Mth.floor(y);
