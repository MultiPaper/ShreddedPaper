--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -1,5 +_,6 @@
 package net.minecraft.server;
 
+import ca.spottedleaf.moonrise.common.util.TickThread;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
@@ -10,6 +_,9 @@
 import com.mojang.jtracy.DiscontinuousFrame;
 import com.mojang.jtracy.TracyClient;
 import com.mojang.logging.LogUtils;
+import io.multipaper.shreddedpaper.ShreddedPaper;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperPlayerTicker;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperTickThread;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectArraySet;
 import java.io.File;
@@ -23,6 +_,7 @@
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.security.KeyPair;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -309,6 +_,7 @@
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
     public boolean lagging = false; // Purpur - Lagging threshold
     protected boolean upnp = false; // Purpur - UPnP Port Forwarding
+    public static boolean isBukkitSchedulerHearbeat = false;
     // Paper start - improve tick loop
     public final ca.spottedleaf.moonrise.common.time.TickData tickTimes1s  = new ca.spottedleaf.moonrise.common.time.TickData(java.util.concurrent.TimeUnit.SECONDS.toNanos(1L));
     public final ca.spottedleaf.moonrise.common.time.TickData tickTimes5s  = new ca.spottedleaf.moonrise.common.time.TickData(java.util.concurrent.TimeUnit.SECONDS.toNanos(5L));
@@ -437,6 +_,8 @@
         return executed;
     }
 
+    public final ThreadLocal<Boolean> executingMidTickTasks = ThreadLocal.withInitial(() -> false); // ShreddedPaper
+
     @Override
     public final void moonrise$executeMidTickTasks() {
         final long startTime = System.nanoTime();
@@ -446,6 +_,7 @@
             return;
         }
 
+        this.executingMidTickTasks.set(true); try { // ShreddedPaper
         for (;;) {
             final boolean moreTasks = this.tickMidTickTasks();
             final long currTime = System.nanoTime();
@@ -470,6 +_,7 @@
                 return;
             }
         }
+        } finally { this.executingMidTickTasks.set(false); } // ShreddedPaper
     }
 
    @Override
@@ -895,6 +_,8 @@
 
     // CraftBukkit start
     public void prepareLevel(ServerLevel serverLevel) {
+        if (!TickThread.isTickThread()) throw new IllegalStateException("Cannot load worlds async!!"); // ShreddedPaper
+        if (ShreddedPaperTickThread.isShreddedPaperTickThread()) throw new IllegalStateException("Must load worlds from the global scheduler!"); // ShreddedPaper
         this.forceTicks = true;
         // CraftBukkit end
         ChunkLoadCounter chunkLoadCounter = new ChunkLoadCounter();
@@ -1020,6 +_,7 @@
 
         LOGGER.info("Stopping server");
         Commands.COMMAND_SENDING_POOL.shutdownNow(); // Paper - Perf: Async command map building; Shutdown and don't bother finishing
+        ShreddedPaperTickThread.stopServer(); // ShreddedPaper
         // Purpur start - UPnP Port Forwarding
         if (upnp) {
             if (dev.omega24.upnp4j.UPnP4J.close(this.getPort(), dev.omega24.upnp4j.util.Protocol.TCP)) {
@@ -1059,7 +_,7 @@
 
             for (ServerLevel serverLevelx : this.getAllLevels()) {
                 serverLevelx.getChunkSource().deactivateTicketsOnClosing();
-                serverLevelx.getChunkSource().tick(() -> true, false);
+                serverLevelx.getChunkSource().tick(() -> true, false).join(); // ShreddedPaper - run async
             }
 
             this.waitUntilNextTick();
@@ -1624,7 +_,9 @@
                     this.autoSave();
                 }
 
+                MinecraftServer.isBukkitSchedulerHearbeat = true; // ShreddedPaper
                 this.server.getScheduler().mainThreadHeartbeat(); // CraftBukkit
+                MinecraftServer.isBukkitSchedulerHearbeat = false; // ShreddedPaper
                 // Paper start - avoid issues with certain tasks not processing during sleep
                 Runnable task;
                 while ((task = this.processQueue.poll()) != null) {
@@ -1632,7 +_,7 @@
                 }
                 for (final ServerLevel level : this.levels.values()) {
                     // process unloads
-                    level.getChunkSource().tick(() -> true, false);
+                    level.getChunkSource().tick(() -> true, false).join(); // ShreddedPaper - run async
                 }
                 // Paper end - avoid issues with certain tasks not processing during sleep
                 this.server.spark.executeMainThreadTasks(); // Paper - spark
@@ -1791,16 +_,20 @@
     protected void tickChildren(BooleanSupplier hasTimeLeft) {
         ProfilerFiller profilerFiller = Profiler.get();
         this.getPlayerList().getPlayers().forEach(serverPlayer1 -> serverPlayer1.connection.suspendFlushing());
+        MinecraftServer.isBukkitSchedulerHearbeat = true; // ShreddedPaper
         this.server.getScheduler().mainThreadHeartbeat(); // CraftBukkit
+        MinecraftServer.isBukkitSchedulerHearbeat = false; // ShreddedPaper
         // Paper start - optimise Folia entity scheduler
-        ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler)org.bukkit.Bukkit.getGlobalRegionScheduler()).tick();
-        for (io.papermc.paper.threadedregions.EntityScheduler scheduler : this.entitySchedulerTickList.getAllSchedulers()) {
-            if (scheduler.isRetired()) {
-                continue;
-            }
-
-            scheduler.executeTick();
-        }
+        // ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler)org.bukkit.Bukkit.getGlobalRegionScheduler()).tick(); // ShreddedPaper - moved global scheduler down
+        // ShreddedPaper start - moved to ShreddedPaperChunkTicker
+//        for (io.papermc.paper.threadedregions.EntityScheduler scheduler : this.entitySchedulerTickList.getAllSchedulers()) {
+//            if (scheduler.isRetired()) {
+//                continue;
+//            }
+//
+//            scheduler.executeTick();
+//        }
+        // ShreddedPaper end - moved to ShreddedPaperChunkTicker
         // Paper end - optimise Folia entity scheduler
         io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.ADVENTURE_CLICK_MANAGER.handleQueue(this.tickCount); // Paper
         io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.DIALOG_CLICK_MANAGER.handleQueue(this.tickCount); // Paper
@@ -1836,7 +_,23 @@
             }
         }
 
+        profilerFiller.popPush("connection"); // ShreddedPaper - moved up
+        this.tickConnection(); // ShreddedPaper - moved up
+        // ShreddedPaper start - some players aren't registered in their level if they're dead, let's manually add a task for them to process them
+        for (ServerPlayer player : this.playerList.getPlayers()) {
+            if (player.isRemoved()) {
+                ShreddedPaper.runSync((ServerLevel) player.level(), player.chunkPosition(), () -> {
+                    if (TickThread.isTickThreadFor(player)) {
+                        player.getBukkitEntity().taskScheduler.executeTick();
+                        ShreddedPaperPlayerTicker.tickPlayer(player);
+                    }
+                });
+            }
+        }
+        // ShreddedPaper end
+
         this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
+        List<CompletableFuture<Void>> futures = new ArrayList<>(); // ShreddedPaper - tick worlds async
         for (ServerLevel serverLevel : this.getAllLevels()) {
             serverLevel.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
             serverLevel.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
@@ -1855,7 +_,9 @@
             profilerFiller.push("tick");
 
             try {
-                serverLevel.tick(hasTimeLeft);
+                futures.add(CompletableFuture.supplyAsync(() -> serverLevel.tickAsync(hasTimeLeft), ShreddedPaperTickThread.getExecutor()).thenCompose(v -> v).thenRun(() -> { // ShreddedPaper - tick worlds async
+                    serverLevel.explosionDensityCache.clear(); // Paper - Optimize explosions // ShreddedPaper - moved up from below
+                })); // ShreddedPaper
             } catch (Throwable var7) {
                 CrashReport crashReport = CrashReport.forThrowable(var7, "Exception ticking world");
                 serverLevel.fillReportDetails(crashReport);
@@ -1864,12 +_,20 @@
 
             profilerFiller.pop();
             profilerFiller.pop();
-            serverLevel.explosionDensityCache.clear(); // Paper - Optimize explosions
+            // serverLevel.explosionDensityCache.clear(); // Paper - Optimize explosions // ShreddedPaper - moved up
         }
         this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
 
-        profilerFiller.popPush("connection");
-        this.tickConnection();
+        // ShreddedPaper start - tick worlds async
+        ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) org.bukkit.Bukkit.getGlobalRegionScheduler()).tick(); // Run global region scheduler async to world ticking
+        for (CompletableFuture<Void> future : futures) {
+            this.managedBlock(future::isDone);
+            future.join();
+        }
+        // ShreddedPaper end - tick worlds async
+
+        // profilerFiller.popPush("connection"); // ShreddedPaper - move up
+        // this.tickConnection(); // ShreddedPaper - move up
         profilerFiller.popPush("players");
         this.playerList.tick();
         profilerFiller.popPush("debugSubscribers");
@@ -1889,6 +_,7 @@
 
         for (ServerPlayer serverPlayer : this.playerList.getPlayers()) {
             serverPlayer.connection.chunkSender.sendNextChunks(serverPlayer);
+            serverPlayer.connection.keepConnectionAlive(); // ShreddedPaper - send the ping packet right before flushing
             serverPlayer.connection.resumeFlushing();
         }
 
