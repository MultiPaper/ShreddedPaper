--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -1,8 +_,13 @@
 package net.minecraft.server.level;
 
+import ca.spottedleaf.moonrise.common.util.TickThread;
 import com.google.common.annotations.VisibleForTesting;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.multipaper.shreddedpaper.region.LevelChunkRegionMap;
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperChunkTicker;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperTickThread;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
@@ -74,6 +_,8 @@
     private final @Nullable ChunkAccess[] lastChunk = new ChunkAccess[4];
     private final List<LevelChunk> spawningChunks = new ObjectArrayList<>();
     private final Set<ChunkHolder> chunkHoldersToBroadcast = new ReferenceOpenHashSet<>();
+    private final ShreddedPaperChunkTicker shreddedPaperChunkTicker = new ShreddedPaperChunkTicker(this); // ShreddedPaper
+    public final LevelChunkRegionMap tickingRegions; // ShreddedPaper
     @VisibleForDebug
     private NaturalSpawner.@Nullable SpawnState lastSpawnState;
     // Paper start
@@ -198,6 +_,7 @@
         Supplier<DimensionDataStorage> overworldDataStorage
     ) {
         this.level = level;
+        this.tickingRegions = new LevelChunkRegionMap(this.level); // ShreddedPaper
         this.mainThreadProcessor = new ServerChunkCache.MainThreadExecutor(level);
         this.mainThread = Thread.currentThread();
         Path path = levelStorageAccess.getDimensionPath(level.dimension()).resolve("data");
@@ -350,14 +_,14 @@
     }
 
     public CompletableFuture<ChunkResult<ChunkAccess>> getChunkFuture(int x, int z, ChunkStatus chunkStatus, boolean requireChunk) {
-        boolean flag = Thread.currentThread() == this.mainThread;
+        boolean flag = TickThread.isTickThreadFor(this.level, x, z); // ShreddedPaper - regions
         CompletableFuture<ChunkResult<ChunkAccess>> chunkFutureMainThread;
         if (flag) {
             chunkFutureMainThread = this.getChunkFutureMainThread(x, z, chunkStatus, requireChunk);
             this.mainThreadProcessor.managedBlock(chunkFutureMainThread::isDone);
         } else {
             chunkFutureMainThread = CompletableFuture.<CompletableFuture<ChunkResult<ChunkAccess>>>supplyAsync(
-                    () -> this.getChunkFutureMainThread(x, z, chunkStatus, requireChunk), this.mainThreadProcessor
+                    () -> this.getChunkFutureMainThread(x, z, chunkStatus, requireChunk), this.tickingRegions.executorFor(RegionPos.forChunk(x, z)) // ShreddedPaper - regions
                 )
                 .thenCompose(future -> (CompletionStage<ChunkResult<ChunkAccess>>)future);
         }
@@ -426,6 +_,7 @@
     }
 
     public boolean pollTask() {
+        if (ShreddedPaperTickThread.isShreddedPaperTickThread()) return false; // ShreddedPaper - don't run main thread tasks on worker threads
         return this.mainThreadProcessor.pollTask();
     }
 
@@ -474,7 +_,8 @@
     // CraftBukkit end
 
     @Override
-    public void tick(BooleanSupplier hasTimeLeft, boolean tickChunks) {
+    public CompletableFuture<Void> tick(BooleanSupplier hasTimeLeft, boolean tickChunks) { // ShreddedPaper - run async
+        CompletableFuture<Void> future = CompletableFuture.completedFuture(null); // ShreddedPaper - run async
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("purge");
         if (this.level.tickRateManager().runsNormally() || !tickChunks || this.level.spigotConfig.unloadFrozenChunks) { // Spigot
@@ -485,17 +_,22 @@
         profilerFiller.popPush("chunks");
         if (tickChunks) {
             ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getPlayerChunkLoader().tick(); // Paper - rewrite chunk system
-            this.tickChunks();
-            this.chunkMap.tick();
+            future = future.thenCompose(v -> this.tickChunks()); // ShreddedPaper - run async
+            future = future.thenRun(() -> this.chunkMap.tick()); // ShreddedPaper - run async
         }
 
+        future = future.thenRun(() -> { // ShreddedPaper - run async
         profilerFiller.popPush("unload");
         this.chunkMap.tick(hasTimeLeft);
         profilerFiller.pop();
         this.clearCache();
+        }); // ShreddedPaper - run async
+
+        return future; // ShreddedPaper - run async
     }
 
-    private void tickChunks() {
+    private CompletableFuture<Void> tickChunks() { // ShreddedPaper - run async
+        CompletableFuture<Void> future = CompletableFuture.completedFuture(null); // ShreddedPaper - run async
         long gameTime = this.level.getGameTime();
         long l = gameTime - this.lastInhabitedUpdate;
         this.lastInhabitedUpdate = gameTime;
@@ -504,16 +_,19 @@
             profilerFiller.push("pollingChunks");
             if (this.level.tickRateManager().runsNormally()) {
                 profilerFiller.push("tickingChunks");
-                this.tickChunks(profilerFiller, l);
+                future = future.thenCompose(v -> this.tickChunks(profilerFiller, l)); // ShreddedPaper - run async
                 profilerFiller.pop();
-            }
+            } else future = future.thenCompose(v -> this.shreddedPaperChunkTicker.tickChunks(0, null, null)); // ShreddedPaper - still tick chunks anyway
 
-            this.broadcastChangedChunks(profilerFiller);
+            // this.broadcastChangedChunks(profilerFiller); // ShreddedPaper - handled in the region
             profilerFiller.pop();
         }
+
+        return future; // ShreddedPaper - run async
     }
 
     private void broadcastChangedChunks(ProfilerFiller profiler) {
+        if (true) throw new UnsupportedOperationException("Disabled by ShreddedPaper"); // ShreddedPaper - handled in the region, ensure it stays that way
         profiler.push("broadcast");
 
         for (ChunkHolder chunkHolder : this.chunkHoldersToBroadcast) {
@@ -527,7 +_,8 @@
         profiler.pop();
     }
 
-    private void tickChunks(ProfilerFiller profiler, long timeInhabited) {
+    private CompletableFuture<Void> tickChunks(ProfilerFiller profiler, long timeInhabited) { // ShreddedPaper - run async
+        CompletableFuture<Void> future = CompletableFuture.completedFuture(null); // ShreddedPaper - run async
         profiler.push("naturalSpawnCount");
         int naturalSpawnChunkCount = this.distanceManager.getNaturalSpawnChunkCount();
         // Paper start - Optional per player mob spawns
@@ -571,36 +_,40 @@
             filteredSpawningCategories = List.of();
         }
 
-        List<LevelChunk> list = this.spawningChunks;
-
-        try {
-            profiler.popPush("filteringSpawningChunks");
-            this.chunkMap.collectSpawningChunks(list);
-            profiler.popPush("shuffleSpawningChunks");
-            // Paper start - chunk tick iteration optimisation
-            this.shuffleRandom.setSeed(this.level.random.nextLong());
-            if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled
-            // Paper end - chunk tick iteration optimisation
-            profiler.popPush("tickSpawningChunks");
-
-            for (LevelChunk levelChunk : list) {
-                this.tickSpawningChunk(levelChunk, timeInhabited, filteredSpawningCategories, spawnState);
-            }
-        } finally {
-            list.clear();
-        }
+        future = future.thenCompose(v -> this.shreddedPaperChunkTicker.tickChunks(timeInhabited, filteredSpawningCategories, lastSpawnState)); // ShreddedPaper - run async
+        // ShreddedPaper start - moved to ShreddedPaperChunkTicker
+//        List<LevelChunk> list = this.spawningChunks;
+//
+//        try {
+//            profiler.popPush("filteringSpawningChunks");
+//            this.chunkMap.collectSpawningChunks(list);
+//            profiler.popPush("shuffleSpawningChunks");
+//            // Paper start - chunk tick iteration optimisation
+//            this.shuffleRandom.setSeed(this.level.random.nextLong());
+//            if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled
+//            // Paper end - chunk tick iteration optimisation
+//            profiler.popPush("tickSpawningChunks");
+//
+//            for (LevelChunk levelChunk : list) {
+//                this.tickSpawningChunk(levelChunk, timeInhabited, filteredSpawningCategories, spawnState);
+//            }
+//        } finally {
+//            list.clear();
+//        }
+        // ShreddedPaper end - moved to ShreddedPaperChunkTicker
 
         profiler.popPush("tickTickingChunks");
-        this.iterateTickingChunksFaster(); // Paper - chunk tick iteration optimizations
+        // this.iterateTickingChunksFaster(); // Paper - chunk tick iteration optimizations // ShreddedPaper - moved to ShreddedPaperChunkTicker
         if (flag) {
             profiler.popPush("customSpawners");
-            this.level.tickCustomSpawners(this.spawnEnemies);
+            future = future.thenRun(() -> this.level.tickCustomSpawners(this.spawnEnemies)); // ShreddedPaper - run async
         }
 
         profiler.pop();
+        return future; // ShreddedPaper - run async
     }
 
-    private void tickSpawningChunk(LevelChunk chunk, long timeInhabited, List<MobCategory> spawnCategories, NaturalSpawner.SpawnState spawnState) {
+    public void tickSpawningChunk(LevelChunk chunk, long timeInhabited, List<MobCategory> spawnCategories, NaturalSpawner.SpawnState spawnState) { // ShreddedPaper - make public
         ChunkPos pos = chunk.getPos();
         chunk.incrementInhabitedTime(timeInhabited);
         if (true) { // Paper - rewrite chunk system
@@ -662,7 +_,7 @@
 
     @Override
     public void onLightUpdate(LightLayer lightLayer, SectionPos pos) {
-        this.mainThreadProcessor.execute(() -> {
+        this.level.moonrise$getChunkTaskScheduler().scheduleChunkTask(pos.x(), pos.z(), () -> { // ShreddedPaper - run on chunk thread
             ChunkHolder visibleChunkIfPresent = this.getVisibleChunkIfPresent(pos.chunk().toLong());
             if (visibleChunkIfPresent != null && visibleChunkIfPresent.sectionLightChanged(lightLayer, pos.y())) {
                 this.chunkHoldersToBroadcast.add(visibleChunkIfPresent);
@@ -823,12 +_,27 @@
 
         @Override
         public boolean pollTask() {
+            // ShreddedPaper start - run all region tasks cause the worker threads might be deadlocked and not get to them
+            if ((!MinecraftServer.getServer().executingMidTickTasks.get() && TickThread.isTickThread()) || TickThread.isShutdownThread()) {
+                level.getChunkSource().tickingRegions.forEach(region -> {
+                    if (TickThread.isShutdownThread()) {
+                        // We're trying to shut down the server, just execute all the tasks
+                        region.getInternalTaskQueue().executeTask();
+                    } else if (!region.getInternalTaskQueue().hasNoScheduledTasks()) {
+                        // We're the main thread, try executing chunk tasks for regions not being ticked
+                        level.chunkScheduler.getRegionLocker().tryReadOnlyLockNow(region.getRegionPos(), () -> {
+                            region.getInternalTaskQueue().executeTask();
+                        });
+                    }
+                });
+            }
+            // ShreddedPaper end
             // Paper start - rewrite chunk system
             final ServerChunkCache serverChunkCache = ServerChunkCache.this;
             if (serverChunkCache.runDistanceManagerUpdates()) {
                 return true;
             } else {
-                return super.pollTask() | ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)serverChunkCache.level).moonrise$getChunkTaskScheduler().executeMainThreadTask();
+                return (!ShreddedPaperTickThread.isShreddedPaperTickThread() && super.pollTask()) | ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)serverChunkCache.level).moonrise$getChunkTaskScheduler().executeMainThreadTask(); // ShreddedPaper - don't run main thread tasks on workers
             }
             // Paper end - rewrite chunk system
         }
