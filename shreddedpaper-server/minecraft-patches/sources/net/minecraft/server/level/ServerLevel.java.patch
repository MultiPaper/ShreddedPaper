--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -1,10 +_,16 @@
 package net.minecraft.server.level;
 
+import ca.spottedleaf.moonrise.common.util.TickThread;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.multipaper.shreddedpaper.ShreddedPaper;
+import io.multipaper.shreddedpaper.region.LevelChunkRegion;
+import io.multipaper.shreddedpaper.region.LevelTicksRegionProxy;
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperRegionScheduler;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -26,6 +_,8 @@
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -190,11 +_,11 @@
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    final List<ServerPlayer> players = new CopyOnWriteArrayList<>(); // ShreddedPaper - thread-safe (players should not be changing worlds often, thus copy-on-write is sufficient)
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
-    final EntityTickList entityTickList = new EntityTickList();
+    // final EntityTickList entityTickList = new EntityTickList(); // ShreddedPaper - moved into each region
     private final ServerWaypointManager waypointManager;
     private final EnvironmentAttributeSystem environmentAttributes;
     // Paper - rewrite chunk system
@@ -203,15 +_,15 @@
     private final SleepStatus sleepStatus;
     private int emptyTime;
     private final PortalForcer portalForcer;
-    private final LevelTicks<Block> blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
-    private final LevelTicks<Fluid> fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
+    public final LevelTicksRegionProxy<Block> blockTicks = new LevelTicksRegionProxy<>(this::isPositionTickingWithEntitiesLoaded); // ShreddedPaper
+    public final LevelTicksRegionProxy<Fluid> fluidTicks = new LevelTicksRegionProxy<>(this::isPositionTickingWithEntitiesLoaded); // ShreddedPaper
     private final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    final Set<Mob> navigatingMobs = new ObjectOpenHashSet<>();
-    volatile boolean isUpdatingNavigations;
+    // final Set<Mob> navigatingMobs = new ObjectOpenHashSet<>(); // ShreddedPaper - handled ourselves
+    final ThreadLocal<Boolean> isUpdatingNavigations = ThreadLocal.withInitial(() -> false); // ShreddedPaper - make thread local
     protected final Raids raids;
-    private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet<>();
-    private final List<BlockEventData> blockEventsToReschedule = new ArrayList<>(64);
-    private boolean handlingTick;
+    // private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet<>(); // ShreddedPaper - moved into each region
+    private final ThreadLocal<List<BlockEventData>> blockEventsToRescheduleThreadLocal = ThreadLocal.withInitial(() -> new ArrayList<>(64)); // ShreddedPaper
+    public ThreadLocal<Boolean> handlingTickThreadLocal = ThreadLocal.withInitial(() -> false); // ShreddedPaper
     private final List<CustomSpawner> customSpawners;
     private @Nullable EndDragonFight dragonFight;
     final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectOpenHashMap<>();
@@ -221,6 +_,7 @@
     private double preciseTime; // Purpur - Configurable daylight cycle
     private boolean forceTime; // Purpur - Configurable daylight cycle
     private final RandomSequences randomSequences;
+    public final ShreddedPaperRegionScheduler chunkScheduler = new ShreddedPaperRegionScheduler(); // ShreddedPaper
     final LevelDebugSynchronizers debugSynchronizers = new LevelDebugSynchronizers(this);
 
     // CraftBukkit start
@@ -316,9 +_,9 @@
     private long tickedBlocksOrFluids;
     private final ca.spottedleaf.moonrise.common.misc.NearbyPlayers nearbyPlayers = new ca.spottedleaf.moonrise.common.misc.NearbyPlayers((ServerLevel)(Object)this);
     private static final LevelChunk[] EMPTY_LEVEL_CHUNKS = new LevelChunk[0];
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> loadedChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> tickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> entityTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
+    // private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> loadedChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS); // ShreddedPaper - loadedChunks is unused, remove
+    // private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> tickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS); // ShreddedPaper - unused, ensure it remains that way
+    // private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> entityTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS); // ShreddedPaper - unused, ensure it remains that way
 
     @Override
     public final LevelChunk moonrise$getFullChunkIfLoaded(final int chunkX, final int chunkZ) {
@@ -492,19 +_,21 @@
         return this.nearbyPlayers;
     }
 
-    @Override
-    public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getLoadedChunks() {
-        return this.loadedChunks;
-    }
+    // ShreddedPaper start - loadedChunks is unused, remove
+//    @Override
+//    public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getLoadedChunks() {
+//        return this.loadedChunks;
+//    }
+    // ShreddedPaper start - loadedChunks is unused, remove
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getTickingChunks() {
-        return this.tickingChunks;
+        throw new UnsupportedOperationException("Removed by ShreddedPaper"); // return this.tickingChunks; // ShreddedPaper - unused, ensure it remains that way
     }
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getEntityTickingChunks() {
-        return this.entityTickingChunks;
+        throw new UnsupportedOperationException("Removed by ShreddedPaper"); // return this.entityTickingChunks; // ShreddedPaper - unused, ensure it remains that way
     }
 
     @Override
@@ -530,75 +_,77 @@
    }
     // Paper end - rewrite chunk system
     // Paper start - chunk tick iteration
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> playerTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap playerTickingRequests = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap();
-
-    @Override
-    public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getPlayerTickingChunks() {
-        return this.playerTickingChunks;
-    }
-
-    @Override
-    public final void moonrise$markChunkForPlayerTicking(final LevelChunk chunk) {
-        final ChunkPos pos = chunk.getPos();
-        if (!this.playerTickingRequests.containsKey(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos))) {
-            return;
-        }
-
-        this.playerTickingChunks.add(chunk);
-    }
-
-    @Override
-    public final void moonrise$removeChunkForPlayerTicking(final LevelChunk chunk) {
-        this.playerTickingChunks.remove(chunk);
-    }
-
-    @Override
-    public final void moonrise$addPlayerTickingRequest(final int chunkX, final int chunkZ) {
-        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot add ticking request async");
-
-        final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
-
-        if (this.playerTickingRequests.addTo(chunkKey, 1) != 0) {
-            // already added
-            return;
-        }
-
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)(ServerLevel)(Object)this).moonrise$getChunkTaskScheduler()
-            .chunkHolderManager.getChunkHolder(chunkKey);
-
-        if (chunkHolder == null || !chunkHolder.isTickingReady()) {
-            return;
-        }
-
-        this.playerTickingChunks.add((LevelChunk)chunkHolder.getCurrentChunk());
-    }
-
-    @Override
-    public final void moonrise$removePlayerTickingRequest(final int chunkX, final int chunkZ) {
-        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot remove ticking request async");
-
-        final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
-        final int val = this.playerTickingRequests.addTo(chunkKey, -1);
-
-        if (val <= 0) {
-            throw new IllegalStateException("Negative counter");
-        }
-
-        if (val != 1) {
-            // still has at least one request
-            return;
-        }
-
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)(ServerLevel)(Object)this).moonrise$getChunkTaskScheduler()
-            .chunkHolderManager.getChunkHolder(chunkKey);
-
-        if (chunkHolder == null || !chunkHolder.isTickingReady()) {
-            return;
-        }
-
-        this.playerTickingChunks.remove((LevelChunk)chunkHolder.getCurrentChunk());
-    }
+    // ShreddedPaper start - handled by the regions
+//    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> playerTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
+//    private final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap playerTickingRequests = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap();
+//
+//    @Override
+//    public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getPlayerTickingChunks() {
+//        return this.playerTickingChunks;
+//    }
+//
+//    @Override
+//    public final void moonrise$markChunkForPlayerTicking(final LevelChunk chunk) {
+//        final ChunkPos pos = chunk.getPos();
+//        if (!this.playerTickingRequests.containsKey(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos))) {
+//            return;
+//        }
+//
+//        this.playerTickingChunks.add(chunk);
+//    }
+//
+//    @Override
+//    public final void moonrise$removeChunkForPlayerTicking(final LevelChunk chunk) {
+//        this.playerTickingChunks.remove(chunk);
+//    }
+//
+//    @Override
+//    public final void moonrise$addPlayerTickingRequest(final int chunkX, final int chunkZ) {
+//        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot add ticking request async");
+//
+//        final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
+//
+//        if (this.playerTickingRequests.addTo(chunkKey, 1) != 0) {
+//            // already added
+//            return;
+//        }
+//
+//        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)(ServerLevel)(Object)this).moonrise$getChunkTaskScheduler()
+//            .chunkHolderManager.getChunkHolder(chunkKey);
+//
+//        if (chunkHolder == null || !chunkHolder.isTickingReady()) {
+//            return;
+//        }
+//
+//        this.playerTickingChunks.add((LevelChunk)chunkHolder.getCurrentChunk());
+//    }
+//
+//    @Override
+//    public final void moonrise$removePlayerTickingRequest(final int chunkX, final int chunkZ) {
+//        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot remove ticking request async");
+//
+//        final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
+//        final int val = this.playerTickingRequests.addTo(chunkKey, -1);
+//
+//        if (val <= 0) {
+//            throw new IllegalStateException("Negative counter");
+//        }
+//
+//        if (val != 1) {
+//            // still has at least one request
+//            return;
+//        }
+//
+//        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)(ServerLevel)(Object)this).moonrise$getChunkTaskScheduler()
+//            .chunkHolderManager.getChunkHolder(chunkKey);
+//
+//        if (chunkHolder == null || !chunkHolder.isTickingReady()) {
+//            return;
+//        }
+//
+//        this.playerTickingChunks.remove((LevelChunk)chunkHolder.getCurrentChunk());
+//    }
+    // ShreddedPaper end - handled by the regions
     // Paper end - chunk tick iteration
 
     public ServerLevel(
@@ -767,9 +_,9 @@
         return this.environmentAttributes;
     }
 
-    public void tick(BooleanSupplier hasTimeLeft) {
+    public CompletableFuture<Void> tickAsync(BooleanSupplier hasTimeLeft) { // ShreddedPaper - run async
         ProfilerFiller profilerFiller = Profiler.get();
-        this.handlingTick = true;
+        this.handlingTickThreadLocal.set(true); // ShreddedPaper
         TickRateManager tickRateManager = this.tickRateManager();
         boolean runsNormally = tickRateManager.runsNormally();
         if (runsNormally) {
@@ -827,13 +_,13 @@
         }
 
         profilerFiller.popPush("chunkSource");
-        this.getChunkSource().tick(hasTimeLeft, true);
+        return this.getChunkSource().tick(hasTimeLeft, true).thenRun(() -> { // ShreddedPaper - run async
         profilerFiller.popPush("blockEvents");
         if (runsNormally) {
-            this.runBlockEvents();
+            // this.runBlockEvents(); // ShreddedPaper - moved into each region
         }
 
-        this.handlingTick = false;
+        this.handlingTickThreadLocal.set(false); // ShreddedPaper
         profilerFiller.pop();
         boolean hasActiveTickets = !paperConfig().unsupportedSettings.disableWorldTickingWhenEmpty || this.chunkSource.hasActiveTickets(); // CraftBukkit - this prevents entity cleanup, other issues on servers with no players // Paper - restore this
         if (hasActiveTickets) {
@@ -853,34 +_,36 @@
             }
 
             io.papermc.paper.entity.activation.ActivationRange.activateEntities(this); // Paper - EAR
-            this.entityTickList
-                .forEach(
-                    entity -> {
-                        if (!entity.isRemoved()) {
-                            if (!tickRateManager.isEntityFrozen(entity)) {
-                                profilerFiller.push("checkDespawn");
-                                entity.checkDespawn();
-                                profilerFiller.pop();
-                                if (true) { // Paper - rewrite chunk system
-                                    Entity vehicle = entity.getVehicle();
-                                    if (vehicle != null) {
-                                        if (!vehicle.isRemoved() && vehicle.hasPassenger(entity)) {
-                                            return;
-                                        }
-
-                                        entity.stopRiding();
-                                    }
-
-                                    profilerFiller.push("tick");
-                                    this.guardEntityTick(this::tickNonPassenger, entity);
-                                    profilerFiller.pop();
-                                }
-                            }
-                        }
-                    }
-                );
+            // ShreddedPaper start - moved to ShreddedPaperEntityTicker
+//            this.entityTickList
+//                .forEach(
+//                    entity -> {
+//                        if (!entity.isRemoved()) {
+//                            if (!tickRateManager.isEntityFrozen(entity)) {
+//                                profilerFiller.push("checkDespawn");
+//                                entity.checkDespawn();
+//                                profilerFiller.pop();
+//                                if (true) { // Paper - rewrite chunk system
+//                                    Entity vehicle = entity.getVehicle();
+//                                    if (vehicle != null) {
+//                                        if (!vehicle.isRemoved() && vehicle.hasPassenger(entity)) {
+//                                            return;
+//                                        }
+//
+//                                        entity.stopRiding();
+//                                    }
+//
+//                                    profilerFiller.push("tick");
+//                                    this.guardEntityTick(this::tickNonPassenger, entity);
+//                                    profilerFiller.pop();
+//                                }
+//                            }
+//                        }
+//                    }
+//                );
+            // ShreddedPaper end - moved to ShreddedPaperEntityTicker
             profilerFiller.popPush("blockEntities");
-            this.tickBlockEntities();
+            // this.tickBlockEntities(); // ShreddedPaper - handled locally in the region
             profilerFiller.pop();
         }
 
@@ -889,15 +_,16 @@
         profilerFiller.pop();
         profilerFiller.push("debugSynchronizers");
         if (this.debugSynchronizers.hasAnySubscriberFor(DebugSubscriptions.NEIGHBOR_UPDATES)) {
-            this.neighborUpdater
-                .setDebugListener(blockPos -> this.debugSynchronizers.broadcastEventToTracking(blockPos, DebugSubscriptions.NEIGHBOR_UPDATES, blockPos));
+            // this.neighborUpdater // ShreddedPaper - unneeded
+            //     .setDebugListener(blockPos -> this.debugSynchronizers.broadcastEventToTracking(blockPos, DebugSubscriptions.NEIGHBOR_UPDATES, blockPos)); // ShreddedPaper - unneeded
         } else {
-            this.neighborUpdater.setDebugListener(null);
+            // this.neighborUpdater.setDebugListener(null); // ShreddedPaper - unneeded
         }
 
         this.debugSynchronizers.tick(this.server.debugSubscribers());
         profilerFiller.pop();
         this.environmentAttributes().invalidateTickCache();
+        }); // ShreddedPaper - run async
     }
 
     @Override
@@ -958,7 +_,7 @@
 
     private void wakeUpAllPlayers() {
         this.sleepStatus.removeAllSleepers();
-        this.players.stream().filter(LivingEntity::isSleeping).collect(Collectors.toList()).forEach(player -> player.stopSleepInBed(false, false));
+        this.players.stream().filter(LivingEntity::isSleeping).collect(Collectors.toList()).forEach(player -> ShreddedPaper.runSync(player, () -> player.stopSleepInBed(false, false))); // ShreddedPaper - run on player's thread
     }
 
     // Paper start - optimise random ticking
@@ -1182,7 +_,7 @@
     }
 
     public boolean isHandlingTick() {
-        return this.handlingTick;
+        return this.handlingTickThreadLocal.get();
     }
 
     public boolean canSleepThroughNights() {
@@ -1392,27 +_,29 @@
         this.emptyTime = 0;
     }
 
-    private void tickFluid(BlockPos pos, Fluid fluid) {
+    public void tickFluid(BlockPos pos, Fluid fluid) { // ShreddedPaper - make public
+        TickThread.ensureTickThread(this, pos, "Cannot tick fluid outside of tick thread"); // ShreddedPaper
         BlockState blockState = this.getBlockState(pos);
         FluidState fluidState = blockState.getFluidState();
         if (fluidState.is(fluid)) {
             fluidState.tick(this, pos, blockState);
         }
         // Paper start - rewrite chunk system
-        if ((++this.tickedBlocksOrFluids & 7L) != 0L) {
+        if (false && (++this.tickedBlocksOrFluids & 7L) != 0L) { // ShreddedPaper - no mid tick tasks
             ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
         }
         // Paper end - rewrite chunk system
 
     }
 
-    private void tickBlock(BlockPos pos, Block block) {
+    public void tickBlock(BlockPos pos, Block block) { // ShreddedPaper - make public
+        TickThread.ensureTickThread(this, pos, "Cannot tick block outside of tick thread"); // ShreddedPaper
         BlockState blockState = this.getBlockState(pos);
         if (blockState.is(block)) {
             blockState.tick(this, pos, this.random);
         }
         // Paper start - rewrite chunk system
-        if ((++this.tickedBlocksOrFluids & 7L) != 0L) {
+        if (false && (++this.tickedBlocksOrFluids & 7L) != 0L) { // ShreddedPaper - no mid tick tasks
             ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
         }
         // Paper end - rewrite chunk system
@@ -1467,7 +_,7 @@
     private void tickPassenger(Entity ridingEntity, Entity passengerEntity, final boolean isActive) { // Paper - EAR 2
         if (passengerEntity.isRemoved() || passengerEntity.getVehicle() != ridingEntity) {
             passengerEntity.stopRiding();
-        } else if (passengerEntity instanceof Player || this.entityTickList.contains(passengerEntity)) {
+        } else if (passengerEntity instanceof Player || passengerEntity.isTicking()) { // ShreddedPaper - use a different method to check if passenger is ticking
             passengerEntity.setOldPosAndRot();
             passengerEntity.tickCount++;
             passengerEntity.totalEntityAge++; // Paper - age-like counter for all entities
@@ -1710,8 +_,8 @@
         } else {
             if (entity instanceof net.minecraft.world.entity.item.ItemEntity itemEntity && itemEntity.getItem().isEmpty()) return false; // Paper - Prevent empty items from being added
             // Paper start - capture all item additions to the world
-            if (captureDrops != null && entity instanceof net.minecraft.world.entity.item.ItemEntity) {
-                captureDrops.add((net.minecraft.world.entity.item.ItemEntity) entity);
+            if (captureDropsThreadLocal.get() != null && entity instanceof net.minecraft.world.entity.item.ItemEntity) { // ShreddedPaper - use thread local
+                captureDropsThreadLocal.get().add((net.minecraft.world.entity.item.ItemEntity) entity); // ShreddedPaper - use thread local
                 return true;
             }
             // Paper end - capture all item additions to the world
@@ -1903,7 +_,7 @@
 
     @Override
     public void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
-        if (this.isUpdatingNavigations) {
+        if (this.isUpdatingNavigations.get()) { // ShreddedPaper - use thread local
             String string = "recursive call to sendBlockUpdated";
             Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
         }
@@ -1917,7 +_,7 @@
             List<PathNavigation> list = new ObjectArrayList<>();
 
             try { // Paper - catch CME see below why
-            for (Mob mob : this.navigatingMobs) {
+            for (Mob mob : this.chunkSource.tickingRegions.collectRelevantNavigatingMobs(RegionPos.forChunk(new ChunkPos(pos)))) { // ShreddedPaper
                 PathNavigation navigation = mob.getNavigation();
                 if (navigation.shouldRecomputePath(pos)) {
                     list.add(navigation);
@@ -1934,13 +_,13 @@
             // Paper end - catch CME see below why
 
             try {
-                this.isUpdatingNavigations = true;
+                this.isUpdatingNavigations.set(true); // ShreddedPaper - use thread local
 
                 for (PathNavigation pathNavigation : list) {
                     pathNavigation.recomputePath();
                 }
             } finally {
-                this.isUpdatingNavigations = false;
+                this.isUpdatingNavigations.set(false); // ShreddedPaper - use thread local
             }
         }
         } // Paper - option to disable pathfinding updates
@@ -1949,17 +_,17 @@
     @Override
     public void updateNeighborsAt(BlockPos pos, Block block) {
         // CraftBukkit start
-        if (this.populating) {
+        if (this.populatingThreadLocal.get()) { // ShreddedPaper - thread local for populating
             return;
         }
         // CraftBukkit end
-        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
+        if (captureBlockStatesThreadLocal.get()) { return; } // Paper - Cancel all physics during placement // ShreddedPaper - use thread local
         this.updateNeighborsAt(pos, block, ExperimentalRedstoneUtils.initialOrientation(this, null, null));
     }
 
     @Override
     public void updateNeighborsAt(BlockPos pos, Block block, @Nullable Orientation orientation) {
-        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
+        if (captureBlockStatesThreadLocal.get()) { return; } // Paper - Cancel all physics during placement // ShreddedPaper - use thread local
         this.neighborUpdater.updateNeighborsAtExceptFromFacing(pos, block, null, orientation);
     }
 
@@ -2084,14 +_,15 @@
 
     @Override
     public void blockEvent(BlockPos pos, Block block, int eventId, int eventParam) {
-        this.blockEvents.add(new BlockEventData(pos, block, eventId, eventParam));
+        this.chunkSource.tickingRegions.addBlockEvent(new BlockEventData(pos, block, eventId, eventParam)); // ShreddedPaper
     }
 
-    private void runBlockEvents() {
-        this.blockEventsToReschedule.clear();
+    public void runBlockEvents(LevelChunkRegion region) { // ShreddedPaper
+        List<BlockEventData> blockEventsToReschedule = blockEventsToRescheduleThreadLocal.get(); // ShreddedPaper
+        blockEventsToReschedule.clear(); // ShreddedPaper
 
-        while (!this.blockEvents.isEmpty()) {
-            BlockEventData blockEventData = this.blockEvents.removeFirst();
+        while (region.hasBlockEvents()) { // ShreddedPaper
+            BlockEventData blockEventData = (BlockEventData) region.removeFirstBlockEvent(); // ShreddedPaper
             if (this.shouldTickBlocksAt(blockEventData.pos())) {
                 if (this.doBlockEvent(blockEventData)) {
                     this.server
@@ -2107,11 +_,11 @@
                         );
                 }
             } else {
-                this.blockEventsToReschedule.add(blockEventData);
+                blockEventsToReschedule.add(blockEventData); // ShreddedPaper
             }
         }
 
-        this.blockEvents.addAll(this.blockEventsToReschedule);
+        region.addAllBlockEvents(blockEventsToReschedule); // ShreddedPaper
     }
 
     private boolean doBlockEvent(BlockEventData event) {
@@ -2337,7 +_,7 @@
             final MapItemSavedData mapData = storage.get(MapItemSavedData.type(mapId)); // get populates the cache
             if (mapData != null) { // map was read, init it and return
                 mapData.id = mapId;
-                new org.bukkit.event.server.MapInitializeEvent(mapData.mapView).callEvent();
+                if (mapData.hasCalledMapInitializeEvent.compareAndSet(false, true)) new org.bukkit.event.server.MapInitializeEvent(mapData.mapView).callEvent(); // ShreddedPaper - ensure only called once
                 return mapData;
             }
 
@@ -2356,8 +_,7 @@
     public void setMapData(MapId mapId, MapItemSavedData data) {
         // CraftBukkit start
         data.id = mapId;
-        org.bukkit.event.server.MapInitializeEvent event = new org.bukkit.event.server.MapInitializeEvent(data.mapView);
-        event.callEvent();
+        if (data.hasCalledMapInitializeEvent.compareAndSet(false, true)) new org.bukkit.event.server.MapInitializeEvent(data.mapView).callEvent(); // ShreddedPaper - ensure only called once
         // CraftBukkit end
         this.getServer().overworld().getDataStorage().set(MapItemSavedData.type(mapId), data);
     }
@@ -2412,11 +_,11 @@
         Optional<Holder<PoiType>> optional1 = PoiTypes.forState(newState);
         if (!Objects.equals(optional, optional1)) {
             BlockPos blockPos = pos.immutable();
-            optional.ifPresent(holder -> this.getServer().execute(() -> {
+            optional.ifPresent(holder -> chunkSource.tickingRegions.execute(RegionPos.forChunk(new ChunkPos(pos)), () -> { // ShreddedPaper
                 this.getPoiManager().remove(blockPos);
                 this.debugSynchronizers.dropPoi(blockPos);
             }));
-            optional1.ifPresent(holder -> this.getServer().execute(() -> {
+            optional1.ifPresent(holder -> chunkSource.tickingRegions.execute(RegionPos.forChunk(new ChunkPos(pos)), () -> { // ShreddedPaper
                 // Paper start - Remove stale POIs
                 if (optional.isEmpty() && this.getPoiManager().exists(blockPos, ignored -> true)) {
                     this.getPoiManager().remove(blockPos);
@@ -2479,7 +_,7 @@
             }
 
             bufferedWriter.write(String.format(Locale.ROOT, "entities: %s\n", this.moonrise$getEntityLookup().getDebugInfo()));  // Paper - rewrite chunk system
-            bufferedWriter.write(String.format(Locale.ROOT, "block_entity_tickers: %d\n", this.blockEntityTickers.size()));
+            // bufferedWriter.write(String.format(Locale.ROOT, "block_entity_tickers: %d\n", this.blockEntityTickers.size())); // ShreddedPaper - removed blockEntityTickers
             bufferedWriter.write(String.format(Locale.ROOT, "block_ticks: %d\n", this.getBlockTicks().count()));
             bufferedWriter.write(String.format(Locale.ROOT, "fluid_ticks: %d\n", this.getFluidTicks().count()));
             bufferedWriter.write("distance_manager: " + chunkMap.getDistanceManager().getDebugStatus() + "\n");
@@ -2547,17 +_,25 @@
     }
 
     private void dumpBlockEntityTickers(Writer output) throws IOException {
-        CsvOutput csvOutput = CsvOutput.builder().addColumn("x").addColumn("y").addColumn("z").addColumn("type").build(output);
-
-        for (TickingBlockEntity tickingBlockEntity : this.blockEntityTickers) {
-            BlockPos pos = tickingBlockEntity.getPos();
-            csvOutput.writeRow(pos.getX(), pos.getY(), pos.getZ(), tickingBlockEntity.getType());
-        }
+        // ShreddedPaper start - removed blockEntityTickers
+//        CsvOutput csvOutput = CsvOutput.builder().addColumn("x").addColumn("y").addColumn("z").addColumn("type").build(output);
+//
+//        for (TickingBlockEntity tickingBlockEntity : this.blockEntityTickers) {
+//            BlockPos pos = tickingBlockEntity.getPos();
+//            csvOutput.writeRow(pos.getX(), pos.getY(), pos.getZ(), tickingBlockEntity.getType());
+//        }
+        // ShreddedPaper end - removed blockEntityTickers
     }
 
     @VisibleForTesting
     public void clearBlockEvents(BoundingBox boundingBox) {
-        this.blockEvents.removeIf(blockEventData -> boundingBox.isInside(blockEventData.pos()));
+        // ShreddedPaper start - moved blockEvents into regions
+        this.getLevel().getChunkSource().tickingRegions.forEachRegionInBoundingBox(boundingBox, region -> {
+            region.removeBlockEventsIf((blockactiondata) -> {
+                return boundingBox.isInside(blockactiondata.pos());
+            });
+        });
+        // ShreddedPaper end - moved blockEvents into regions
     }
 
     @Override
@@ -2600,8 +_,8 @@
             this.players.size(),
             this.moonrise$getEntityLookup().getDebugInfo(), // Paper - rewrite chunk system
             getTypeCount(this.moonrise$getEntityLookup().getAll(), entity -> BuiltInRegistries.ENTITY_TYPE.getKey(entity.getType()).toString()), // Paper - rewrite chunk system
-            this.blockEntityTickers.size(),
-            getTypeCount(this.blockEntityTickers, TickingBlockEntity::getType),
+            0 /*this.blockEntityTickers.size()*/, // ShreddedPaper - removed blockEntityTickers
+            0 /*getTypeCount(this.blockEntityTickers, TickingBlockEntity::getType)*/, // ShreddedPaper - removed blockEntityTickers
             this.getBlockTicks().count(),
             this.getFluidTicks().count(),
             this.gatherChunkSourceStats()
@@ -2630,7 +_,7 @@
 
     @Override
     public LevelEntityGetter<Entity> getEntities() {
-        org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot
+        // org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot // ShreddedPaper - thread safe now
         return this.moonrise$getEntityLookup(); // Paper - rewrite chunk system
     }
 
@@ -2857,12 +_,12 @@
         @Override
         public void onTickingStart(Entity entity) {
             if (entity instanceof net.minecraft.world.entity.Marker && !paperConfig().entities.markers.tick) return; // Paper - Configurable marker ticking
-            ServerLevel.this.entityTickList.add(entity);
+            ServerLevel.this.getChunkSource().tickingRegions.addTickingEntity(entity); // ShreddedPaper - move entityTickList to the regions
         }
 
         @Override
         public void onTickingEnd(Entity entity) {
-            ServerLevel.this.entityTickList.remove(entity);
+            ServerLevel.this.getChunkSource().tickingRegions.removeTickingEntity(entity); // ShreddedPaper - move entityTickList to the regions
             // Paper start - Reset pearls when they stop being ticked
             if (ServerLevel.this.paperConfig().fixes.disableUnloadedChunkEnderpearlExploit && ServerLevel.this.paperConfig().misc.legacyEnderPearlBehavior && entity instanceof net.minecraft.world.entity.projectile.throwableitemprojectile.ThrownEnderpearl pearl) {
                 pearl.setOwner(null);
@@ -2872,10 +_,11 @@
 
         @Override
         public void onTrackingStart(Entity entity) {
-            org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
+            TickThread.ensureTickThread(entity, "entity register"); // org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot // ShreddedPaper
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer serverPlayer) {
                 ServerLevel.this.players.add(serverPlayer);
+                ServerLevel.this.getChunkSource().tickingRegions.addPlayer(serverPlayer); // ShreddedPaper - add player to region
                 if (serverPlayer.isReceivingWaypoints()) {
                     ServerLevel.this.getWaypointManager().addPlayer(serverPlayer);
                 }
@@ -2888,14 +_,14 @@
             }
 
             if (entity instanceof Mob mob) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // ShreddedPaper - use thread local
                     String string = "onTrackingStart called during navigation iteration";
                     Util.logAndPauseIfInIde(
                         "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
                     );
                 }
 
-                ServerLevel.this.navigatingMobs.add(mob);
+                // ServerLevel.this.navigatingMobs.add(mob); // ShreddedPaper - handled ourselves
             }
 
             if (entity instanceof EnderDragon enderDragon) {
@@ -2922,7 +_,7 @@
 
         @Override
         public void onTrackingEnd(Entity entity) {
-            org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
+            TickThread.ensureTickThread(entity, "entity unregister"); // org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot // ShreddedPaper
             // Spigot start // TODO I don't think this is needed anymore
             if (entity instanceof Player player) {
                 for (final ServerLevel level : ServerLevel.this.getServer().getAllLevels()) {
@@ -2931,10 +_,12 @@
                             continue;
                         }
 
+                        synchronized (map) { // ShreddedPaper - thread-safe
                         map.carriedByPlayers.remove(player);
                         if (map.carriedBy.removeIf(holdingPlayer -> holdingPlayer.player == player)) {
                             map.decorations.remove(player.getName().getString());
                         }
+                        } // ShreddedPaper - thread-safe
                     }
                 }
             }
@@ -2953,20 +_,21 @@
             // Spigot end
             ServerLevel.this.getChunkSource().removeEntity(entity);
             if (entity instanceof ServerPlayer serverPlayer) {
+                ServerLevel.this.getChunkSource().tickingRegions.removePlayer(serverPlayer); // ShreddedPaper - remove player from region
                 ServerLevel.this.players.remove(serverPlayer);
                 ServerLevel.this.getWaypointManager().removePlayer(serverPlayer);
                 ServerLevel.this.updateSleepingPlayerList();
             }
 
             if (entity instanceof Mob mob) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // ShreddedPaper - use thread local
                     String string = "onTrackingStart called during navigation iteration";
                     Util.logAndPauseIfInIde(
                         "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
                     );
                 }
 
-                ServerLevel.this.navigatingMobs.remove(mob);
+                // ServerLevel.this.navigatingMobs.remove(mob); // ShreddedPaper - handled ourselves
             }
 
             if (entity instanceof EnderDragon enderDragon) {
@@ -2991,6 +_,9 @@
         @Override
         public void onSectionChange(Entity entity) {
             entity.updateDynamicGameEventListener(DynamicGameEventListener::move);
+            ServerLevel.this.chunkSource.tickingRegions.moveTickingEntity(entity); // ShreddedPaper - move ticking entity into the new region
+            ServerLevel.this.chunkSource.tickingRegions.moveTrackedEntity(entity); // ShreddedPaper - move tracked entity into the new region
+            if (entity instanceof ServerPlayer serverPlayer) ServerLevel.this.chunkSource.tickingRegions.movePlayer(serverPlayer); // ShreddedPaper - move player into the new region
         }
     }
 
