--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -5,6 +_,8 @@
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperRegionScheduler;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -26,6 +_,8 @@
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -190,11 +_,11 @@
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    final List<ServerPlayer> players = new CopyOnWriteArrayList<>(); // ShreddedPaper - thread-safe (players should not be changing worlds often, thus copy-on-write is sufficient)
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
-    final EntityTickList entityTickList = new EntityTickList();
+    // final EntityTickList entityTickList = new EntityTickList(); // ShreddedPaper - moved into each region
     private final ServerWaypointManager waypointManager;
     private final EnvironmentAttributeSystem environmentAttributes;
     // Paper - rewrite chunk system
@@ -221,6 +_,7 @@
     private double preciseTime; // Purpur - Configurable daylight cycle
     private boolean forceTime; // Purpur - Configurable daylight cycle
     private final RandomSequences randomSequences;
+    public final ShreddedPaperRegionScheduler chunkScheduler = new ShreddedPaperRegionScheduler(); // ShreddedPaper
     final LevelDebugSynchronizers debugSynchronizers = new LevelDebugSynchronizers(this);
 
     // CraftBukkit start
@@ -317,8 +_,8 @@
     private final ca.spottedleaf.moonrise.common.misc.NearbyPlayers nearbyPlayers = new ca.spottedleaf.moonrise.common.misc.NearbyPlayers((ServerLevel)(Object)this);
     private static final LevelChunk[] EMPTY_LEVEL_CHUNKS = new LevelChunk[0];
     private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> loadedChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> tickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> entityTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
+    // private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> tickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS); // ShreddedPaper - unused, ensure it remains that way
+    // private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> entityTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS); // ShreddedPaper - unused, ensure it remains that way
 
     @Override
     public final LevelChunk moonrise$getFullChunkIfLoaded(final int chunkX, final int chunkZ) {
@@ -499,12 +_,12 @@
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getTickingChunks() {
-        return this.tickingChunks;
+        throw new UnsupportedOperationException("Removed by ShreddedPaper"); // return this.tickingChunks; // ShreddedPaper - unused, ensure it remains that way
     }
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getEntityTickingChunks() {
-        return this.entityTickingChunks;
+        throw new UnsupportedOperationException("Removed by ShreddedPaper"); // return this.entityTickingChunks; // ShreddedPaper - unused, ensure it remains that way
     }
 
     @Override
@@ -530,75 +_,77 @@
    }
     // Paper end - rewrite chunk system
     // Paper start - chunk tick iteration
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> playerTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap playerTickingRequests = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap();
-
-    @Override
-    public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getPlayerTickingChunks() {
-        return this.playerTickingChunks;
-    }
-
-    @Override
-    public final void moonrise$markChunkForPlayerTicking(final LevelChunk chunk) {
-        final ChunkPos pos = chunk.getPos();
-        if (!this.playerTickingRequests.containsKey(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos))) {
-            return;
-        }
-
-        this.playerTickingChunks.add(chunk);
-    }
-
-    @Override
-    public final void moonrise$removeChunkForPlayerTicking(final LevelChunk chunk) {
-        this.playerTickingChunks.remove(chunk);
-    }
-
-    @Override
-    public final void moonrise$addPlayerTickingRequest(final int chunkX, final int chunkZ) {
-        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot add ticking request async");
-
-        final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
-
-        if (this.playerTickingRequests.addTo(chunkKey, 1) != 0) {
-            // already added
-            return;
-        }
-
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)(ServerLevel)(Object)this).moonrise$getChunkTaskScheduler()
-            .chunkHolderManager.getChunkHolder(chunkKey);
-
-        if (chunkHolder == null || !chunkHolder.isTickingReady()) {
-            return;
-        }
-
-        this.playerTickingChunks.add((LevelChunk)chunkHolder.getCurrentChunk());
-    }
-
-    @Override
-    public final void moonrise$removePlayerTickingRequest(final int chunkX, final int chunkZ) {
-        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot remove ticking request async");
-
-        final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
-        final int val = this.playerTickingRequests.addTo(chunkKey, -1);
-
-        if (val <= 0) {
-            throw new IllegalStateException("Negative counter");
-        }
-
-        if (val != 1) {
-            // still has at least one request
-            return;
-        }
-
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)(ServerLevel)(Object)this).moonrise$getChunkTaskScheduler()
-            .chunkHolderManager.getChunkHolder(chunkKey);
-
-        if (chunkHolder == null || !chunkHolder.isTickingReady()) {
-            return;
-        }
-
-        this.playerTickingChunks.remove((LevelChunk)chunkHolder.getCurrentChunk());
-    }
+    // ShreddedPaper start - handled by the regions
+//    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> playerTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
+//    private final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap playerTickingRequests = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap();
+//
+//    @Override
+//    public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getPlayerTickingChunks() {
+//        return this.playerTickingChunks;
+//    }
+//
+//    @Override
+//    public final void moonrise$markChunkForPlayerTicking(final LevelChunk chunk) {
+//        final ChunkPos pos = chunk.getPos();
+//        if (!this.playerTickingRequests.containsKey(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos))) {
+//            return;
+//        }
+//
+//        this.playerTickingChunks.add(chunk);
+//    }
+//
+//    @Override
+//    public final void moonrise$removeChunkForPlayerTicking(final LevelChunk chunk) {
+//        this.playerTickingChunks.remove(chunk);
+//    }
+//
+//    @Override
+//    public final void moonrise$addPlayerTickingRequest(final int chunkX, final int chunkZ) {
+//        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot add ticking request async");
+//
+//        final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
+//
+//        if (this.playerTickingRequests.addTo(chunkKey, 1) != 0) {
+//            // already added
+//            return;
+//        }
+//
+//        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)(ServerLevel)(Object)this).moonrise$getChunkTaskScheduler()
+//            .chunkHolderManager.getChunkHolder(chunkKey);
+//
+//        if (chunkHolder == null || !chunkHolder.isTickingReady()) {
+//            return;
+//        }
+//
+//        this.playerTickingChunks.add((LevelChunk)chunkHolder.getCurrentChunk());
+//    }
+//
+//    @Override
+//    public final void moonrise$removePlayerTickingRequest(final int chunkX, final int chunkZ) {
+//        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot remove ticking request async");
+//
+//        final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
+//        final int val = this.playerTickingRequests.addTo(chunkKey, -1);
+//
+//        if (val <= 0) {
+//            throw new IllegalStateException("Negative counter");
+//        }
+//
+//        if (val != 1) {
+//            // still has at least one request
+//            return;
+//        }
+//
+//        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)(ServerLevel)(Object)this).moonrise$getChunkTaskScheduler()
+//            .chunkHolderManager.getChunkHolder(chunkKey);
+//
+//        if (chunkHolder == null || !chunkHolder.isTickingReady()) {
+//            return;
+//        }
+//
+//        this.playerTickingChunks.remove((LevelChunk)chunkHolder.getCurrentChunk());
+//    }
+    // ShreddedPaper end - handled by the regions
     // Paper end - chunk tick iteration
 
     public ServerLevel(
@@ -767,7 +_,7 @@
         return this.environmentAttributes;
     }
 
-    public void tick(BooleanSupplier hasTimeLeft) {
+    public CompletableFuture<Void> tick(BooleanSupplier hasTimeLeft) { // ShreddedPaper - run async
         ProfilerFiller profilerFiller = Profiler.get();
         this.handlingTick = true;
         TickRateManager tickRateManager = this.tickRateManager();
@@ -827,7 +_,7 @@
         }
 
         profilerFiller.popPush("chunkSource");
-        this.getChunkSource().tick(hasTimeLeft, true);
+        return this.getChunkSource().tick(hasTimeLeft, true).thenRun(() -> { // ShreddedPaper - run async
         profilerFiller.popPush("blockEvents");
         if (runsNormally) {
             this.runBlockEvents();
@@ -853,32 +_,34 @@
             }
 
             io.papermc.paper.entity.activation.ActivationRange.activateEntities(this); // Paper - EAR
-            this.entityTickList
-                .forEach(
-                    entity -> {
-                        if (!entity.isRemoved()) {
-                            if (!tickRateManager.isEntityFrozen(entity)) {
-                                profilerFiller.push("checkDespawn");
-                                entity.checkDespawn();
-                                profilerFiller.pop();
-                                if (true) { // Paper - rewrite chunk system
-                                    Entity vehicle = entity.getVehicle();
-                                    if (vehicle != null) {
-                                        if (!vehicle.isRemoved() && vehicle.hasPassenger(entity)) {
-                                            return;
-                                        }
-
-                                        entity.stopRiding();
-                                    }
-
-                                    profilerFiller.push("tick");
-                                    this.guardEntityTick(this::tickNonPassenger, entity);
-                                    profilerFiller.pop();
-                                }
-                            }
-                        }
-                    }
-                );
+            // ShreddedPaper start - moved to ShreddedPaperEntityTicker
+//            this.entityTickList
+//                .forEach(
+//                    entity -> {
+//                        if (!entity.isRemoved()) {
+//                            if (!tickRateManager.isEntityFrozen(entity)) {
+//                                profilerFiller.push("checkDespawn");
+//                                entity.checkDespawn();
+//                                profilerFiller.pop();
+//                                if (true) { // Paper - rewrite chunk system
+//                                    Entity vehicle = entity.getVehicle();
+//                                    if (vehicle != null) {
+//                                        if (!vehicle.isRemoved() && vehicle.hasPassenger(entity)) {
+//                                            return;
+//                                        }
+//
+//                                        entity.stopRiding();
+//                                    }
+//
+//                                    profilerFiller.push("tick");
+//                                    this.guardEntityTick(this::tickNonPassenger, entity);
+//                                    profilerFiller.pop();
+//                                }
+//                            }
+//                        }
+//                    }
+//                );
+            // ShreddedPaper end - moved to ShreddedPaperEntityTicker
             profilerFiller.popPush("blockEntities");
             this.tickBlockEntities();
             profilerFiller.pop();
@@ -889,15 +_,16 @@
         profilerFiller.pop();
         profilerFiller.push("debugSynchronizers");
         if (this.debugSynchronizers.hasAnySubscriberFor(DebugSubscriptions.NEIGHBOR_UPDATES)) {
-            this.neighborUpdater
-                .setDebugListener(blockPos -> this.debugSynchronizers.broadcastEventToTracking(blockPos, DebugSubscriptions.NEIGHBOR_UPDATES, blockPos));
+            // this.neighborUpdater // ShreddedPaper - unneeded
+            //     .setDebugListener(blockPos -> this.debugSynchronizers.broadcastEventToTracking(blockPos, DebugSubscriptions.NEIGHBOR_UPDATES, blockPos)); // ShreddedPaper - unneeded
         } else {
-            this.neighborUpdater.setDebugListener(null);
+            // this.neighborUpdater.setDebugListener(null); // ShreddedPaper - unneeded
         }
 
         this.debugSynchronizers.tick(this.server.debugSubscribers());
         profilerFiller.pop();
         this.environmentAttributes().invalidateTickCache();
+        }); // ShreddedPaper - run async
     }
 
     @Override
@@ -1467,7 +_,7 @@
     private void tickPassenger(Entity ridingEntity, Entity passengerEntity, final boolean isActive) { // Paper - EAR 2
         if (passengerEntity.isRemoved() || passengerEntity.getVehicle() != ridingEntity) {
             passengerEntity.stopRiding();
-        } else if (passengerEntity instanceof Player || this.entityTickList.contains(passengerEntity)) {
+        } else if (passengerEntity instanceof Player || passengerEntity.isTicking()) { // ShreddedPaper - use a different method to check if passenger is ticking
             passengerEntity.setOldPosAndRot();
             passengerEntity.tickCount++;
             passengerEntity.totalEntityAge++; // Paper - age-like counter for all entities
@@ -2412,11 +_,11 @@
         Optional<Holder<PoiType>> optional1 = PoiTypes.forState(newState);
         if (!Objects.equals(optional, optional1)) {
             BlockPos blockPos = pos.immutable();
-            optional.ifPresent(holder -> this.getServer().execute(() -> {
+            optional.ifPresent(holder -> chunkSource.tickingRegions.execute(RegionPos.forChunk(new ChunkPos(pos)), () -> { // ShreddedPaper
                 this.getPoiManager().remove(blockPos);
                 this.debugSynchronizers.dropPoi(blockPos);
             }));
-            optional1.ifPresent(holder -> this.getServer().execute(() -> {
+            optional1.ifPresent(holder -> chunkSource.tickingRegions.execute(RegionPos.forChunk(new ChunkPos(pos)), () -> { // ShreddedPaper
                 // Paper start - Remove stale POIs
                 if (optional.isEmpty() && this.getPoiManager().exists(blockPos, ignored -> true)) {
                     this.getPoiManager().remove(blockPos);
@@ -2630,7 +_,7 @@
 
     @Override
     public LevelEntityGetter<Entity> getEntities() {
-        org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot
+        // org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot // ShreddedPaper - thread safe now
         return this.moonrise$getEntityLookup(); // Paper - rewrite chunk system
     }
 
@@ -2857,12 +_,12 @@
         @Override
         public void onTickingStart(Entity entity) {
             if (entity instanceof net.minecraft.world.entity.Marker && !paperConfig().entities.markers.tick) return; // Paper - Configurable marker ticking
-            ServerLevel.this.entityTickList.add(entity);
+            ServerLevel.this.getChunkSource().tickingRegions.addTickingEntity(entity); // ShreddedPaper - move entityTickList to the regions
         }
 
         @Override
         public void onTickingEnd(Entity entity) {
-            ServerLevel.this.entityTickList.remove(entity);
+            ServerLevel.this.getChunkSource().tickingRegions.removeTickingEntity(entity); // ShreddedPaper - move entityTickList to the regions
             // Paper start - Reset pearls when they stop being ticked
             if (ServerLevel.this.paperConfig().fixes.disableUnloadedChunkEnderpearlExploit && ServerLevel.this.paperConfig().misc.legacyEnderPearlBehavior && entity instanceof net.minecraft.world.entity.projectile.throwableitemprojectile.ThrownEnderpearl pearl) {
                 pearl.setOwner(null);
@@ -2876,6 +_,7 @@
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer serverPlayer) {
                 ServerLevel.this.players.add(serverPlayer);
+                ServerLevel.this.getChunkSource().tickingRegions.addPlayer(serverPlayer); // ShreddedPaper - add player to region
                 if (serverPlayer.isReceivingWaypoints()) {
                     ServerLevel.this.getWaypointManager().addPlayer(serverPlayer);
                 }
@@ -2953,6 +_,7 @@
             // Spigot end
             ServerLevel.this.getChunkSource().removeEntity(entity);
             if (entity instanceof ServerPlayer serverPlayer) {
+                ServerLevel.this.getChunkSource().tickingRegions.removePlayer(serverPlayer); // ShreddedPaper - remove player from region
                 ServerLevel.this.players.remove(serverPlayer);
                 ServerLevel.this.getWaypointManager().removePlayer(serverPlayer);
                 ServerLevel.this.updateSleepingPlayerList();
@@ -2991,6 +_,8 @@
         @Override
         public void onSectionChange(Entity entity) {
             entity.updateDynamicGameEventListener(DynamicGameEventListener::move);
+            ServerLevel.this.chunkSource.tickingRegions.moveTickingEntity(entity); // ShreddedPaper - move ticking entity into the new region
+            if (entity instanceof ServerPlayer serverPlayer) ServerLevel.this.chunkSource.tickingRegions.movePlayer(serverPlayer); // ShreddedPaper - move player into the new region
         }
     }
 
