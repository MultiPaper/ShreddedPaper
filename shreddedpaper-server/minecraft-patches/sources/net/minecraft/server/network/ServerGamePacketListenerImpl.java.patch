--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1,5 +_,6 @@
 package net.minecraft.server.network;
 
+import ca.spottedleaf.moonrise.common.util.TickThread;
 import com.google.common.collect.Lists;
 import com.google.common.primitives.Floats;
 import com.mojang.authlib.GameProfile;
@@ -8,6 +_,7 @@
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.suggestion.Suggestions;
 import com.mojang.logging.LogUtils;
+import io.multipaper.shreddedpaper.ShreddedPaper;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
@@ -626,6 +_,12 @@
                     return;
                 }
                 // Paper end - Prevent moving into unloaded chunks
+                // ShreddedPaper start - Check we own the destination location
+                if (!TickThread.isTickThreadFor(this.player.level(), new Vec3(toX, toY, toZ))) {
+                    this.connection.send(ClientboundMoveVehiclePacket.fromEntity(rootVehicle));
+                    return;
+                }
+                // ShreddedPaper end - Check we own the destination location
                 if (d7 - d6 > Math.max(100.0, Mth.square(org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed)) && !this.isSingleplayerOwner()) {
                     // CraftBukkit end
                     LOGGER.warn("{} (vehicle of {}) moved too quickly! {},{},{}", rootVehicle.getPlainTextName(), this.player.getPlainTextName(), d3, d4, d5);
@@ -1379,7 +_,7 @@
             Consumer<List<FilteredText>> consumer = optional.isPresent()
                 ? texts -> this.signBook(texts.get(0), texts.subList(1, texts.size()), slot, hasSignPerm) // Purpur - Allow color codes in books
                 : list1 -> this.updateBookContents(list1, slot, hasEditPerm); // Purpur - Allow color codes in books
-            this.filterTextPacket(list).thenAcceptAsync(consumer, this.server);
+            this.filterTextPacket(list).thenAcceptAsync(consumer, r -> ShreddedPaper.ensureSync(this.player, r)); // ShreddedPaper - run on region thread
         }
     }
 
@@ -1573,6 +_,12 @@
                                         // Paper end - Add fail move event
                                     }
                                     // Paper end - Prevent moving into unloaded chunks
+                                    // ShreddedPaper start - Check we own the destination location
+                                    if (!TickThread.isTickThreadFor(this.player.level(), new Vec3(toX, toY, toZ))) {
+                                        this.internalTeleport(PositionMoveRotation.of(this.player), Collections.emptySet());
+                                        return;
+                                    }
+                                    // ShreddedPaper end - Check we own the destination location
 
                                     if (this.shouldCheckPlayerMovement(isFallFlying)) {
                                         float f2 = isFallFlying ? 300.0F : 100.0F;
@@ -2288,7 +_,9 @@
             for (ServerLevel serverLevel : this.server.getAllLevels()) {
                 Entity entity = packet.getEntity(serverLevel);
                 if (entity != null) {
+                    ShreddedPaper.ensureSync(this.player, entity, () -> { // ShreddedPaper - ensure on entity's thread
                     this.player.teleportTo(serverLevel, entity.getX(), entity.getY(), entity.getZ(), Set.of(), entity.getYRot(), entity.getXRot(), true, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.SPECTATE); // CraftBukkit
+                    }); // ShreddedPaper - ensure on entity's thread
                     return;
                 }
             }
@@ -2312,12 +_,14 @@
             this.processedDisconnect = true;
         }
         // CraftBukkit end
+        player.getBukkitEntity().taskScheduler.schedule(e -> { // ShreddedPaper - run on player's thread
         LOGGER.info("{} lost connection: {}", this.player.getPlainTextName(), details.reason().getString());
         // Paper start - Fix kick event leave message not being sent
         final net.kyori.adventure.text.Component quitMessage = details.quitMessage().map(io.papermc.paper.adventure.PaperAdventure::asAdventure).orElse(null);
         this.removePlayerFromWorld(quitMessage);
         // Paper end - Fix kick event leave message not being sent
         super.onDisconnect(details);
+        }, e -> LOGGER.error("Failed to run disconnect task for player {}", player.getName().getString(), new Exception("Disconnect task retired")), 1); // ShreddedPaper - run on player's thread
     }
 
     private void removePlayerFromWorld() {
@@ -2579,7 +_,7 @@
             this.player.resetLastActionTime();
             // CraftBukkit start
             if (sync) {
-                this.server.execute(handler);
+                ShreddedPaper.runSync(player, handler); // ShreddedPaper - run on player's thread
             } else {
                 handler.run();
             }
@@ -3030,23 +_,27 @@
         switch (action) {
             case PERFORM_RESPAWN:
                 if (this.player.wonGame) {
+                    this.server.getPlayerList().respawnAsync(this.player, true, Entity.RemovalReason.CHANGED_DIMENSION, RespawnReason.END_PORTAL).thenAccept(player -> { // CraftBukkit // ShreddedPaper - async respawn
+                    this.player = player; // ShreddedPaper - async respawn
                     this.player.wonGame = false;
-                    this.player = this.server.getPlayerList().respawn(this.player, true, Entity.RemovalReason.CHANGED_DIMENSION, RespawnReason.END_PORTAL); // CraftBukkit
                     this.resetPosition();
                     this.restartClientLoadTimerAfterRespawn();
                     CriteriaTriggers.CHANGED_DIMENSION.trigger(this.player, Level.END, Level.OVERWORLD);
+                    }); // ShreddedPaper - async respawn
                 } else {
                     if (this.player.getHealth() > 0.0F) {
                         return;
                     }
 
-                    this.player = this.server.getPlayerList().respawn(this.player, false, Entity.RemovalReason.KILLED, RespawnReason.DEATH); // CraftBukkit
+                    this.server.getPlayerList().respawnAsync(this.player, false, Entity.RemovalReason.KILLED, RespawnReason.DEATH).thenAccept(player -> { // CraftBukkit // ShreddedPaper - async respawn
+                    this.player = player; // ShreddedPaper - async respawn
                     this.resetPosition();
                     this.restartClientLoadTimerAfterRespawn();
                     if (this.server.isHardcore()) {
                         this.player.setGameMode(GameType.SPECTATOR, org.bukkit.event.player.PlayerGameModeChangeEvent.Cause.HARDCORE_DEATH, null); // Paper - Expand PlayerGameModeChangeEvent
                         this.player.level().getGameRules().set(GameRules.SPECTATORS_GENERATE_CHUNKS, false, this.player.level()); // CraftBukkit - per-world
                     }
+                    }); // ShreddedPaper - async respawn
                 }
                 break;
             case REQUEST_STATS:
@@ -3575,7 +_,7 @@
         }
         List<String> list = Stream.of(lines).map(ChatFormatting::stripFormatting).collect(Collectors.toList());
         // Paper end - Limit client sign length
-        this.filterTextPacket(list).thenAcceptAsync(texts -> this.updateSignText(packet, (List<FilteredText>)texts), this.server);
+        this.filterTextPacket(list).thenAcceptAsync(texts -> this.updateSignText(packet, (List<FilteredText>)texts), r -> ShreddedPaper.ensureSync(this.player, r)); // ShreddedPaper - run on region thread
     }
 
     private void updateSignText(ServerboundSignUpdatePacket packet, List<FilteredText> filteredText) {
@@ -3833,7 +_,7 @@
 
     @Override
     public void disconnectAsync(final net.minecraft.network.DisconnectionDetails disconnectionInfo) {
-        if (this.cserver.isPrimaryThread()) {
+        if (TickThread.isTickThreadFor(this.player)) { // ShreddedPaper
             this.disconnect(disconnectionInfo);
             return;
         }
