--- a/src/main/java/ca/spottedleaf/moonrise/common/misc/PositionCountingAreaMap.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/misc/PositionCountingAreaMap.java
@@ -1,9 +_,13 @@
 package ca.spottedleaf.moonrise.common.misc;
 
 import ca.spottedleaf.moonrise.common.util.CoordinateUtils;
+import io.multipaper.shreddedpaper.util.SimpleStampedLock;
 import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongArraySet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceArraySet;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ReferenceSet;
 
 public final class PositionCountingAreaMap<T> {
@@ -11,12 +_,15 @@
     private final Reference2ReferenceOpenHashMap<T, PositionCounter> counters = new Reference2ReferenceOpenHashMap<>();
     private final Long2IntOpenHashMap positions = new Long2IntOpenHashMap();
 
+    private final SimpleStampedLock countersLock = new SimpleStampedLock(); // ShreddedPaper - Multi-threaded access
+    private final SimpleStampedLock positionsLock = new SimpleStampedLock(); // ShreddedPaper - Multi-threaded access
+
     public ReferenceSet<T> getObjects() {
-        return this.counters.keySet();
+        return this.countersLock.optimisticRead(() -> new ReferenceArraySet<>(this.counters.keySet())); // ShreddedPaper - Multi-threaded access - ReferenceArraySet is most efficient to copy the set with
     }
 
     public LongSet getPositions() {
-        return this.positions.keySet();
+        return this.countersLock.optimisticRead(() -> new LongArraySet(this.positions.keySet())); // ShreddedPaper - Multi-threaded access - LongArraySet is most efficient to copy the set with
     }
 
     public int getTotalPositions() {
@@ -32,37 +_,37 @@
     }
 
     public int getObjectsNear(final int toX, final int toZ) {
-        return this.positions.get(CoordinateUtils.getChunkKey(toX, toZ));
+        return this.positionsLock.optimisticRead(() -> this.positions.get(CoordinateUtils.getChunkKey(toX, toZ))); // ShreddedPaper - Multi-threaded access
     }
 
     public boolean add(final T parameter, final int toX, final int toZ, final int distance) {
-        final PositionCounter existing = this.counters.get(parameter);
+        final PositionCounter existing = this.countersLock.optimisticRead(() -> this.counters.get(parameter)); // ShreddedPaper - Multi-threaded access
         if (existing != null) {
             return false;
         }
 
         final PositionCounter counter = new PositionCounter(parameter);
 
-        this.counters.put(parameter, counter);
+        this.countersLock.write(() -> this.counters.put(parameter, counter)); // ShreddedPaper - Multi-threaded access - no need for atomic compute, only one thread writes the same parameter at once
 
         return counter.add(toX, toZ, distance);
     }
 
     public boolean addOrUpdate(final T parameter, final int toX, final int toZ, final int distance) {
-        final PositionCounter existing = this.counters.get(parameter);
+        final PositionCounter existing = this.countersLock.optimisticRead(() -> this.counters.get(parameter)); // ShreddedPaper - Multi-threaded access
         if (existing != null) {
             return existing.update(toX, toZ, distance);
         }
 
         final PositionCounter counter = new PositionCounter(parameter);
 
-        this.counters.put(parameter, counter);
+        this.countersLock.write(() -> this.counters.put(parameter, counter)); // ShreddedPaper - Multi-threaded access - no need for atomic compute, only one thread writes the same parameter at once
 
         return counter.add(toX, toZ, distance);
     }
 
     public boolean remove(final T parameter) {
-        final PositionCounter counter = this.counters.remove(parameter);
+        final PositionCounter counter = this.countersLock.write(() -> this.counters.remove(parameter)); // ShreddedPaper - Multi-threaded access
         if (counter == null) {
             return false;
         }
@@ -73,7 +_,7 @@
     }
 
     public boolean update(final T parameter, final int toX, final int toZ, final int distance) {
-        final PositionCounter counter = this.counters.get(parameter);
+        final PositionCounter counter = this.countersLock.optimisticRead(() -> this.counters.get(parameter)); // ShreddedPaper - Multi-threaded access
         if (counter == null) {
             return false;
         }
@@ -89,15 +_,17 @@
 
         @Override
         protected void addCallback(final T parameter, final int toX, final int toZ) {
-            PositionCountingAreaMap.this.positions.addTo(CoordinateUtils.getChunkKey(toX, toZ), 1);
+            PositionCountingAreaMap.this.positionsLock.write(() -> PositionCountingAreaMap.this.positions.addTo(CoordinateUtils.getChunkKey(toX, toZ), 1)); // ShreddedPaper - Multi-threaded access
         }
 
         @Override
         protected void removeCallback(final T parameter, final int toX, final int toZ) {
             final long key = CoordinateUtils.getChunkKey(toX, toZ);
+            PositionCountingAreaMap.this.positionsLock.write(() -> { // ShreddedPaper - Multi-threaded access
             if (PositionCountingAreaMap.this.positions.addTo(key, -1) == 1) {
                 PositionCountingAreaMap.this.positions.remove(key);
             }
+            }); // ShreddedPaper - Multi-threaded access
         }
     }
 }
