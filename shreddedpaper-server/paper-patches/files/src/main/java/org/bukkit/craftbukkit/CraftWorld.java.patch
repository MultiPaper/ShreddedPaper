--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -2,10 +_,14 @@
 
 import ca.spottedleaf.moonrise.common.list.ReferenceList;
 import ca.spottedleaf.moonrise.common.util.CoordinateUtils;
+import ca.spottedleaf.moonrise.common.util.TickThread;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Pair;
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperTickThread;
+import io.multipaper.shreddedpaper.threading.SynchronousPluginExecution;
 import io.papermc.paper.FeatureHooks;
 import io.papermc.paper.raytracing.BlockCollisionMode;
 import io.papermc.paper.raytracing.PositionedRayTraceConfigurationBuilder;
@@ -27,6 +_,7 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
@@ -182,6 +_,7 @@
     private final BlockMetadataStore blockMetadata = new BlockMetadataStore(this);
     private final Object2IntOpenHashMap<SpawnCategory> spawnCategoryLimit = new Object2IntOpenHashMap<>();
     private final CraftPersistentDataContainer persistentDataContainer = new CraftPersistentDataContainer(CraftWorld.DATA_TYPE_REGISTRY);
+    private static final ThreadLocal<Boolean> isInsideIsChunkGenerated = ThreadLocal.withInitial(() -> Boolean.FALSE); // ShreddedPaper - track recursive isChunkGenerated calls
     // Paper start - void damage configuration
     private boolean voidDamageEnabled;
     private float voidDamageAmount;
@@ -240,7 +_,7 @@
 
     @Override
     public int getTickableTileEntityCount() {
-        return world.blockEntityTickers.size();
+        return 0; // world.blockEntityTickers.size(); // ShreddedPaper - removed blockEntityTickers
     }
 
     @Override
@@ -383,6 +_,7 @@
 
     @Override
     public Chunk getChunkAt(int x, int z) {
+        if (ShreddedPaperTickThread.isShreddedPaperTickThread() && !TickThread.isTickThreadFor(this.world, x, z)) throw new IllegalStateException("Cannot get chunk from a region that is not ours! world=" + this.world.serverLevelData.getLevelName() + ", chunkpos=[" + x + "," + z + "]"); // ShreddedPaper - regions
         warnUnsafeChunk("getting a faraway chunk", x, z); // Paper
         net.minecraft.world.level.chunk.LevelChunk chunk = (net.minecraft.world.level.chunk.LevelChunk) this.world.getChunk(x, z, ChunkStatus.FULL, true);
         return new CraftChunk(chunk);
@@ -413,26 +_,37 @@
     @Override
     public boolean isChunkGenerated(int x, int z) {
         // Paper start - Fix this method
-        if (!Bukkit.isPrimaryThread()) {
-            return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
+        if (!TickThread.isTickThreadFor(this.world, x, z)) { // ShreddedPaper - regions
+            CompletableFuture<Boolean> future = java.util.concurrent.CompletableFuture.supplyAsync(() -> { // ShreddedPaper - regions
                 return CraftWorld.this.isChunkGenerated(x, z);
-            }, world.getChunkSource().mainThreadProcessor).join();
+            }, world.getChunkSource().tickingRegions.executorFor(RegionPos.forChunk(x, z))); // ShreddedPaper - regions
+            return future.join(); // ShreddedPaper - don't use managedBlock to avoid deadlocks in multi-threaded context
         }
         ChunkAccess chunk = world.getChunkSource().getChunkAtImmediately(x, z);
         if (chunk != null) {
             return chunk instanceof ImposterProtoChunk || chunk instanceof net.minecraft.world.level.chunk.LevelChunk;
         }
-        final java.util.concurrent.CompletableFuture<ChunkAccess> future = new java.util.concurrent.CompletableFuture<>();
-        ca.spottedleaf.moonrise.common.PlatformHooks.get().scheduleChunkLoad(
-            this.world, x, z, false, ChunkStatus.EMPTY, true, ca.spottedleaf.concurrentutil.util.Priority.NORMAL, future::complete
-        );
-        world.getChunkSource().mainThreadProcessor.managedBlock(future::isDone);
-        return future.thenApply(c -> {
-            if (c != null) {
-                return c.getPersistedStatus() == ChunkStatus.FULL;
-            }
-            return false;
-        }).join();
+        // ShreddedPaper start - avoid recursive deadlock by returning false for recursive calls when chunk not in memory
+        if (isInsideIsChunkGenerated.get()) {
+            return false; // Conservative answer: assume not generated if we can't check without blocking
+        }
+        isInsideIsChunkGenerated.set(Boolean.TRUE);
+        try {
+            // ShreddedPaper end
+            final java.util.concurrent.CompletableFuture<ChunkAccess> future = new java.util.concurrent.CompletableFuture<>();
+            ca.spottedleaf.moonrise.common.PlatformHooks.get().scheduleChunkLoad(
+                this.world, x, z, false, ChunkStatus.EMPTY, true, ca.spottedleaf.concurrentutil.util.Priority.NORMAL, future::complete
+            );
+            world.getChunkSource().mainThreadProcessor.managedBlock(future::isDone);
+            return future.thenApply(c -> {
+                if (c != null) {
+                    return c.getPersistedStatus() == ChunkStatus.FULL;
+                }
+                return false;
+            }).join();
+        } finally {
+            isInsideIsChunkGenerated.set(Boolean.FALSE);
+        }
         // Paper end - Fix this method
     }
 
@@ -751,13 +_,15 @@
 
     @Override
     public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
-        this.world.captureTreeGeneration = true;
-        this.world.captureBlockStates = true;
+        this.world.captureTreeGenerationThreadLocal.set(true); // ShreddedPaper - use thread local
+        this.world.captureBlockStatesThreadLocal.set(true); // ShreddedPaper - use thread local
+        this.world.capturedTileEntitiesThreadLocal.get().clear(); // ShreddedPaper - use thread local - clear beforehand
+        this.world.capturedBlockStatesThreadLocal.get().clear(); // ShreddedPaper - use thread local - clear beforehand
         boolean grownTree = this.generateTree(loc, type);
-        this.world.captureBlockStates = false;
-        this.world.captureTreeGeneration = false;
+        this.world.captureBlockStatesThreadLocal.set(false); // ShreddedPaper - use thread local
+        this.world.captureTreeGenerationThreadLocal.set(false); // ShreddedPaper - use thread local
         if (grownTree) { // Copy block data to delegate
-            for (BlockState blockstate : this.world.capturedBlockStates.values()) {
+            for (BlockState blockstate : this.world.capturedBlockStatesThreadLocal.get().values()) { // ShreddedPaper - use thread local
                 BlockPos position = ((CraftBlockState) blockstate).getPosition();
                 net.minecraft.world.level.block.state.BlockState oldBlock = this.world.getBlockState(position);
                 int flags = ((CraftBlockState) blockstate).getFlags();
@@ -765,10 +_,10 @@
                 net.minecraft.world.level.block.state.BlockState newBlock = this.world.getBlockState(position);
                 this.world.notifyAndUpdatePhysics(position, null, oldBlock, newBlock, newBlock, flags, net.minecraft.world.level.block.Block.UPDATE_LIMIT);
             }
-            this.world.capturedBlockStates.clear();
+            this.world.capturedBlockStatesThreadLocal.get().clear(); // ShreddedPaper - use thread local
             return true;
         } else {
-            this.world.capturedBlockStates.clear();
+            this.world.capturedBlockStatesThreadLocal.get().clear(); // ShreddedPaper - use thread local
             return false;
         }
     }
@@ -1600,7 +_,7 @@
         if (!(entity instanceof CraftEntity craftEntity) || entity.getWorld() != this || sound == null || category == null) return;
 
         ClientboundSoundEntityPacket packet = new ClientboundSoundEntityPacket(CraftSound.bukkitToMinecraftHolder(sound), net.minecraft.sounds.SoundSource.valueOf(category.name()), craftEntity.getHandle(), volume, pitch, seed);
-        ChunkMap.TrackedEntity entityTracker = this.getHandle().getChunkSource().chunkMap.entityMap.get(entity.getEntityId());
+        ChunkMap.TrackedEntity entityTracker = ((CraftEntity) entity).getHandle().moonrise$getTrackedEntity(); // this.getHandle().getChunkSource().chunkMap.entityMap.get(entity.getEntityId()); // ShreddedPaper - don't use map
         if (entityTracker != null) {
             entityTracker.sendToTrackingPlayersAndSelf(packet);
         }
@@ -1621,7 +_,7 @@
         if (!(entity instanceof CraftEntity craftEntity) || entity.getWorld() != this || sound == null || category == null) return;
 
         ClientboundSoundEntityPacket packet = new ClientboundSoundEntityPacket(Holder.direct(SoundEvent.createVariableRangeEvent(Identifier.parse(sound))), net.minecraft.sounds.SoundSource.valueOf(category.name()), craftEntity.getHandle(), volume, pitch, seed);
-        ChunkMap.TrackedEntity entityTracker = this.getHandle().getChunkSource().chunkMap.entityMap.get(entity.getEntityId());
+        ChunkMap.TrackedEntity entityTracker = ((CraftEntity) entity).getHandle().moonrise$getTrackedEntity(); // this.getHandle().getChunkSource().chunkMap.entityMap.get(entity.getEntityId()); // ShreddedPaper - don't use map
         if (entityTracker != null) {
             entityTracker.sendToTrackingPlayersAndSelf(packet);
         }
@@ -2048,11 +_,12 @@
     @Override
     public void getChunkAtAsync(int x, int z, boolean gen, boolean urgent, @NotNull Consumer<? super Chunk> cb) {
         warnUnsafeChunk("getting a faraway chunk async", x, z); // Paper
+        Plugin plugin = SynchronousPluginExecution.getCurrentPlugin(); // ShreddedPaper - synchronous plugin execution
         ca.spottedleaf.moonrise.common.PlatformHooks.get().scheduleChunkLoad(
             this.getHandle(), x, z, gen, ChunkStatus.FULL, true,
             urgent ? ca.spottedleaf.concurrentutil.util.Priority.HIGHER : ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
             (ChunkAccess chunk) -> {
-                cb.accept(chunk == null ? null : new CraftChunk((net.minecraft.world.level.chunk.LevelChunk)chunk));
+                SynchronousPluginExecution.executeNoException(plugin, () -> cb.accept(chunk == null ? null : new CraftChunk((net.minecraft.world.level.chunk.LevelChunk)chunk))); // ShreddedPaper - synchronous plugin execution
             }
         );
 
@@ -2062,11 +_,12 @@
     public void getChunksAtAsync(int minX, int minZ, int maxX, int maxZ, boolean urgent, Runnable cb) {
         warnUnsafeChunk("getting a faraway chunk async", minX, minZ); // Paper
         warnUnsafeChunk("getting a faraway chunk async", maxX, maxZ); // Paper
+        Plugin plugin = SynchronousPluginExecution.getCurrentPlugin(); // ShreddedPaper - synchronous plugin execution
         this.getHandle().loadChunks(
             minX, minZ, maxX, maxZ,
             urgent ? ca.spottedleaf.concurrentutil.util.Priority.HIGHER : ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
             (List<ChunkAccess> chunks) -> {
-                cb.run();
+                SynchronousPluginExecution.executeNoException(plugin, () -> cb.run()); // ShreddedPaper - synchronous plugin execution
             }
         );
     }
