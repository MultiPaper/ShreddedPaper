From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sat, 4 May 2024 14:40:58 +0900
Subject: [PATCH] Add multithreading region scheduler


diff --git a/src/main/java/io/multipaper/shreddedpaper/region/RegionPos.java b/src/main/java/io/multipaper/shreddedpaper/region/RegionPos.java
new file mode 100644
index 0000000000000000000000000000000000000000..c8caf9240e1aa5e434a47cbdf4b7bf68e4025586
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/region/RegionPos.java
@@ -0,0 +1,138 @@
+package io.multipaper.shreddedpaper.region;
+
+import com.mojang.logging.LogUtils;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.world.level.ChunkPos;
+import org.bukkit.Location;
+import org.slf4j.Logger;
+import io.multipaper.shreddedpaper.config.ShreddedPaperConfiguration;
+
+// Copy of ChunkPos basically, but separate to avoid accidental usage as a ChunkPos
+public class RegionPos {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    public static final int REGION_SIZE; // eg 8 (for an 8x8 region)
+    public static final int REGION_SHIFT; // eg 3 (1 << 3 == 8)
+    public static final int REGION_SIZE_MASK; // eg 7 (9 % 8 == 9 & 7 == 1)
+
+    static {
+        // desiredRegionSize = 7 -> shift = 3, size = 8, mask = 7
+        // desiredRegionSize = 8 -> shift = 3, size = 8, mask = 7
+        // desiredRegionSize = 9 -> shift = 4, size = 16, mask = 15
+        int desiredRegionSize = ShreddedPaperConfiguration.get().multithreading.regionSize - 1;
+        int shift = 0;
+        while (desiredRegionSize > 0) {
+            shift++;
+            desiredRegionSize >>= 1;
+        }
+
+        REGION_SIZE = 1 << shift;
+        REGION_SHIFT = shift;
+        REGION_SIZE_MASK = (1 << shift) - 1;
+
+        if (REGION_SIZE <= 1) {
+            throw new IllegalStateException("!!! Region size is " + REGION_SIZE + " chunk, this is too small. It must be at least 2 chunks !!!");
+        }
+
+        if (REGION_SIZE < 8) {
+            LOGGER.warn("!!! !!!");
+            LOGGER.warn("!!! Region size is less than 8 chunks, this will cause issues unless you know what you're doing!!!");
+            LOGGER.warn("!!! !!!");
+        }
+
+        LOGGER.info("Using region size: {}, shift={}, mask={}", REGION_SIZE, REGION_SHIFT, REGION_SIZE_MASK);
+    }
+
+    public final int x;
+    public final int z;
+    public final long longKey; // Paper
+
+    public RegionPos(int rx, int rz) {
+        this.x = rx;
+        this.z = rz;
+        this.longKey = RegionPos.asLong(this.x, this.z);
+    }
+
+    public RegionPos(long regionKey) {
+        this.x = (int) regionKey;
+        this.z = (int) (regionKey >> 32);
+        this.longKey = regionKey;
+    }
+
+    public static RegionPos forChunk(ChunkPos chunkPos) {
+        return chunkPos.getRegionPos(); // Cache the RegionPos on the ChunkPos to minimize object creation
+    }
+
+    public static RegionPos forChunk(int chunkX, int chunkZ) {
+        return new RegionPos(asLongForChunk(chunkX, chunkZ));
+    }
+
+    public static RegionPos forBlockPos(BlockPos blockPos) {
+        return forBlockPos(blockPos.getX(), blockPos.getY(), blockPos.getZ());
+    }
+
+    public static RegionPos forBlockPos(int x, int y, int z) {
+        return new RegionPos(asLongForBlockPos(x, y, z));
+    }
+
+    public static RegionPos forLocation(Location location) {
+        return forBlockPos(location.getBlockX(), location.getBlockY(), location.getBlockZ());
+    }
+
+    public static long asLongForChunk(ChunkPos chunkPos) {
+        return asLongForChunk(chunkPos.x, chunkPos.z);
+    }
+
+    public static long asLongForChunk(int chunkX, int chunkZ) {
+        return asLong(chunkX >> REGION_SHIFT, chunkZ >> REGION_SHIFT);
+    }
+
+    public static long asLongForBlockPos(BlockPos blockPos) {
+        return asLongForBlockPos(blockPos.getX(), blockPos.getY(), blockPos.getZ());
+    }
+
+    public static long asLongForBlockPos(int x, int y, int z) {
+        return asLongForChunk(SectionPos.blockToSectionCoord(x), SectionPos.blockToSectionCoord(z));
+    }
+
+    public static long asLong(RegionPos regionPos) {
+        return asLong(regionPos.x, regionPos.z);
+    }
+
+    public static long asLong(int regionX, int regionZ) {
+        return (long)regionX & 4294967295L | ((long)regionZ & 4294967295L) << 32;
+    }
+
+    public int getLowerChunkX() {
+        return this.x << REGION_SHIFT;
+    }
+
+    public int getLowerChunkZ() {
+        return this.z << REGION_SHIFT;
+    }
+
+    public int getUpperChunkX() {
+        return getLowerChunkX() + REGION_SIZE - 1;
+    }
+
+    public int getUpperChunkZ() {
+        return getLowerChunkZ() + REGION_SIZE - 1;
+    }
+
+    @Override
+    public int hashCode() {
+        return ChunkPos.hash(this.x, this.z);
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        return this == object || object instanceof RegionPos regionPos && this.x == regionPos.x && this.z == regionPos.z;
+    }
+
+    @Override
+    public String toString() {
+        return "RegionPos[" + this.x + ", " + this.z + "]";
+    }
+}
diff --git a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionLocker.java b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionLocker.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa1abd5a95e144684ac0574cf51e9b6ee9d6a51d
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionLocker.java
@@ -0,0 +1,271 @@
+package io.multipaper.shreddedpaper.threading;
+
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
+import io.multipaper.shreddedpaper.region.RegionPos;
+
+import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.LockSupport;
+import java.util.function.Supplier;
+
+/**
+ * Read lock:
+ *  - Only one thread can hold a read lock at a time.
+ *  - Many servers can hold a read lock at the same time.
+ *  - Good for tasks such as sending data to clients and loading chunks.
+ * Write lock:
+ *  - An extension of the read lock.
+ *  - Only one server can hold a write lock at a time.
+ *  - Important for tasks that modify the region, such as modifying blocks or entities.
+ */
+public class ShreddedPaperRegionLocker {
+
+    private static final int REGION_LOCK_RADIUS = 1;
+
+    private final ConcurrentHashMap<RegionPos, Thread> lockedRegions = new ConcurrentHashMap<>();
+
+    private final ThreadLocal<Set<RegionPos>> localLocks = ThreadLocal.withInitial(ObjectOpenHashSet::new);
+    private final ThreadLocal<Set<RegionPos>> readOnlyLocks = ThreadLocal.withInitial(ObjectOpenHashSet::new);
+    private final ThreadLocal<Set<RegionPos>> writeLocks = ThreadLocal.withInitial(ObjectOpenHashSet::new);
+    private final ThreadLocal<Set<RegionPos>> unmodifiableLocalLocks = ThreadLocal.withInitial(() -> Collections.unmodifiableSet(localLocks.get()));
+
+    /**
+     * Checks if the current thread holds a read lock for the given region
+     */
+    public boolean hasLock(RegionPos regionPos) {
+        return localLocks.get().contains(regionPos);
+    }
+
+    /**
+     * Checks if the current thread holds a write lock for the given region.
+     * This check is usually unnecessary, but ensures that there will be no
+     * syncing conflicts with other servers.
+     */
+    public boolean hasWriteLock(RegionPos regionPos) {
+        return writeLocks.get().contains(regionPos);
+    }
+
+    /**
+     * Returns an unmodifiable view of the locked regions for the current thread.
+     */
+    public Set<RegionPos> getLockedRegions() {
+        // Use an unmodifiable view to ensure the underlying set doesn't get accidentally modified
+        return unmodifiableLocalLocks.get();
+    }
+
+    /**
+     * Returns an unmodifiable view of all locked regions across all threads.
+     */
+    public Set<Map.Entry<RegionPos, Thread>> getAllLockedRegions() {
+        return Collections.unmodifiableSet(lockedRegions.entrySet());
+    }
+
+    public RegionLock lockRegion(RegionPos regionPos) {
+        int tries = 0;
+        RegionLock lock;
+        while ((lock = this.tryTakeLockNow(regionPos)) == null) {
+            LockSupport.parkNanos(Math.min(100_000, 1_000 * (++tries)));
+        }
+        return lock;
+    }
+
+    /**
+     * Lock the region and run the runnable. If the region is already locked, wait until it is unlocked.
+     * Can be called recursively and will respect existing locks created by the same thread.
+     */
+    public <T> T lockRegion(RegionPos regionPos, Supplier<T> runnableWithReturnValue) {
+        RegionLock lock = this.lockRegion(regionPos);
+        try {
+            return runnableWithReturnValue.get();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Lock the region and run the runnable. If the region is already locked, wait until it is unlocked.
+     * Can be called recursively and will respect existing locks created by the same thread.
+     */
+    public void lockRegion(RegionPos regionPos, Runnable runnable) {
+        RegionLock lock = this.lockRegion(regionPos);
+        try {
+            runnable.run();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Try to acquire the region lock immediately, if successful run the runnable.
+     * If unsuccessful, return false and the runnable will not be run.
+     * If the region is already locked, it will return unsuccessfully immediately instead of waiting to try to acquire the lock.
+     * Can be called recursively and will respect existing locks created by the same thread.
+     * This method will sync the lock with other servers.
+     * @return true if the lock was acquired and the runnable was run, false if the runnable was not run
+     */
+    public boolean tryLockNow(RegionPos centerPos, Runnable ifSuccess) {
+        RegionLock lock = this.tryTakeLockNow(centerPos);
+        if (lock == null) {
+            return false;
+        }
+
+        try {
+            ifSuccess.run();
+            return true;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Try to acquire the region lock immediately, if successful run the runnable.
+     * If unsuccessful, return false and the runnable will not be run.
+     * If the region is already locked, it will return unsuccessfully immediately instead of waiting to try to acquire the lock.
+     * Can be called recursively and will respect existing locks created by the same thread.
+     * The specified region must not be modified within this lock. This method will not sync the lock with other servers.
+     * return true if the lock was acquired and the runnable was run, false if the runnable was not run
+     */
+    public boolean tryReadOnlyLockNow(RegionPos centerPos, Runnable ifSuccess) {
+        final RegionLock lock = this.tryTakeReadOnlyLockNow(centerPos);
+        if (lock == null) {
+            return false;
+        }
+
+        try {
+            ifSuccess.run();
+            return true;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Nullable
+    public RegionLock tryTakeLockNow(RegionPos centerPos) {
+        return internalTryTakeLockNow(centerPos, REGION_LOCK_RADIUS);
+    }
+
+    @Nullable
+    public WriteRegionLock internalTryTakeLockNow(RegionPos centerPos, int lockRadius) {
+        final ReadOnlyRegionLock lock = internalTryTakeReadOnlyLockNow(centerPos, lockRadius);
+        return lock == null ? null : new WriteRegionLock(lock);
+    }
+
+    @Nullable
+    public RegionLock tryTakeReadOnlyLockNow(RegionPos centerPos) {
+        return internalTryTakeReadOnlyLockNow(centerPos, REGION_LOCK_RADIUS);
+    }
+
+    @Nullable
+    public ReadOnlyRegionLock internalTryTakeReadOnlyLockNow(RegionPos centerPos, int lockRadius) {
+        final ReadOnlyRegionLock lock = new ReadOnlyRegionLock(lockRadius);
+
+        for (int x = -lockRadius; x <= lockRadius; x++) {
+            for (int z = -lockRadius; z <= lockRadius; z++) {
+                RegionPos regionPos = x == 0 && z == 0 ? centerPos : new RegionPos(centerPos.x + x, centerPos.z + z);
+                if (!lock.tryLockRegion(regionPos)) {
+                    // Failed to take lock, abort
+                    lock.unlock();
+                    return null;
+                }
+            }
+        }
+
+        return lock;
+    }
+
+    public interface RegionLock {
+        Collection<RegionPos> lockedRegions();
+        Thread owner();
+        void unlock();
+    }
+
+    public class ReadOnlyRegionLock implements RegionLock {
+        private final List<RegionPos> readLocks;
+        private final Thread thread;
+
+        private ReadOnlyRegionLock(int lockRadius) {
+            this.thread = Thread.currentThread();
+            this.readLocks = new ArrayList<>((lockRadius * 2 + 1) * (lockRadius * 2 + 1));
+        }
+
+        protected boolean tryLockRegion(RegionPos regionPos) {
+            if (this.thread != Thread.currentThread()) {
+                throw new IllegalStateException("Cannot lock a region from a different thread [expected=%s,got=%s]".formatted(thread, Thread.currentThread()));
+            }
+
+            Thread regionOwner = ShreddedPaperRegionLocker.this.lockedRegions.compute(regionPos, (k, prevValue) -> {
+                if (prevValue == null) {
+                    // This region is unlocked, let's lock it
+                    ShreddedPaperRegionLocker.this.localLocks.get().add(regionPos);
+                    ShreddedPaperRegionLocker.this.readOnlyLocks.get().add(regionPos);
+                    this.readLocks.add(regionPos);
+                    return this.owner();
+                } else {
+                    // This region is already locked, it could be already locked by us or someone else
+                    return prevValue;
+                }
+            });
+
+            return regionOwner == this.owner();
+        }
+
+        public Collection<RegionPos> lockedRegions() {
+            return Collections.unmodifiableCollection(this.readLocks);
+        }
+
+        public Thread owner() {
+            return this.thread;
+        }
+
+        public void unlock() {
+            if (this.thread != Thread.currentThread()) {
+                throw new IllegalStateException("Cannot unlock a lock from a different thread [expected=%s,got=%s]".formatted(thread, Thread.currentThread()));
+            }
+
+            for (RegionPos regionPos : this.readLocks) {
+                ShreddedPaperRegionLocker.this.lockedRegions.remove(regionPos, this.thread);
+                ShreddedPaperRegionLocker.this.localLocks.get().remove(regionPos);
+                ShreddedPaperRegionLocker.this.readOnlyLocks.get().remove(regionPos);
+            }
+        }
+
+    }
+
+    public class WriteRegionLock implements RegionLock {
+        private final List<RegionPos> writeLocks;
+        private final ReadOnlyRegionLock superLock;
+
+        private WriteRegionLock(ReadOnlyRegionLock superLock) {
+            this.superLock = superLock;
+
+            Collection<RegionPos> lockedRegions = superLock.lockedRegions();
+            this.writeLocks = new ArrayList<>(lockedRegions);
+            ShreddedPaperRegionLocker.this.writeLocks.get().addAll(lockedRegions);
+            ShreddedPaperRegionLocker.this.readOnlyLocks.get().removeAll(lockedRegions);
+        }
+
+        @Override
+        public Collection<RegionPos> lockedRegions() {
+            return Collections.unmodifiableCollection(this.writeLocks);
+        }
+
+        @Override
+        public Thread owner() {
+            return this.superLock.owner();
+        }
+
+        @Override
+        public void unlock() {
+            ShreddedPaperRegionLocker.this.writeLocks.get().removeAll(this.writeLocks);
+            ShreddedPaperRegionLocker.this.readOnlyLocks.get().addAll(this.writeLocks);
+            this.superLock.unlock();
+        }
+    }
+
+}
diff --git a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionScheduler.java b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionScheduler.java
new file mode 100644
index 0000000000000000000000000000000000000000..1a0f4e1d5c1de71221d10528c39cd777e471e155
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionScheduler.java
@@ -0,0 +1,194 @@
+package io.multipaper.shreddedpaper.threading;
+
+import net.minecraft.server.level.ServerLevel;
+import io.multipaper.shreddedpaper.region.RegionPos;
+
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class ShreddedPaperRegionScheduler {
+
+    private final ShreddedPaperRegionLocker locker = new ShreddedPaperRegionLocker();
+    private final Map<RegionPos, CompletableFuture<Void>> chunkQueue = new ConcurrentHashMap<>(); // Maintain order when scheduling for one chunk
+
+    public static CompletableFuture<Void> schedule(ServerLevel level, RegionPos regionPos, Runnable runnable) {
+        return level.chunkScheduler.schedule(regionPos, runnable);
+    }
+
+    /**
+     * Schedule a task to run on the given region's thread.
+     */
+    public CompletableFuture<Void> schedule(RegionPos regionPos, Runnable runnable) {
+        CompletableFuture<Void> future = chunkQueue.compute(regionPos, (key, value) -> {
+            if (value == null) {
+                return createTask(regionPos, runnable);
+            } else {
+                // Ensure each chunk task is run in scheduled order
+                return value.thenCompose(v -> createTask(regionPos, runnable));
+            }
+        });
+        future.thenRun(() -> chunkQueue.remove(regionPos, future));
+        return future;
+    }
+
+    /**
+     * Avoid using this often. Locking massive parts of the world can take time and will freeze these regions during the process.
+     */
+    public CompletableFuture<Void> scheduleOnMany(Runnable runnable, RegionPos... posArray) {
+        CompletableFuture<Void> future = new CompletableFuture<>();
+
+        ShreddedPaperTickThread.getExecutor().execute(() -> {
+            runOnMany(sortPredictably(posArray), runnable, future);
+        });
+
+        return future;
+    }
+
+    public static CompletableFuture<Void> scheduleAcrossLevels(ServerLevel level1, RegionPos regionPos1, ServerLevel level2, RegionPos regionPos2, Runnable runnable) {
+        if (level1 == level2) {
+            // We don't sort the regionPos in this method because we assume they're a different level, use the method that does sort them instead
+            return level1.chunkScheduler.scheduleOnMany(runnable, regionPos1, regionPos2);
+        }
+
+        ServerLevel finalLevel1;
+        RegionPos finalRegionPos1;
+        ServerLevel finalLevel2;
+        RegionPos finalRegionPos2;
+
+        // Sort predictably to avoid deadlocks
+        if (compare(level1, level2) > 0) {
+            finalLevel1 = level2;
+            finalRegionPos1 = regionPos2;
+            finalLevel2 = level1;
+            finalRegionPos2 = regionPos1;
+        } else {
+            finalLevel1 = level1;
+            finalRegionPos1 = regionPos1;
+            finalLevel2 = level2;
+            finalRegionPos2 = regionPos2;
+        }
+
+        CompletableFuture<Void> future = new CompletableFuture<>();
+
+        ShreddedPaperTickThread.getExecutor().execute(() -> {
+            runAcrossLevels(finalLevel1, finalRegionPos1, finalLevel2, finalRegionPos2, runnable, future);
+        });
+
+        return future;
+    }
+
+    /**
+     * Sort the region positions in a predictable order to avoid deadlocks.
+     */
+    private RegionPos[] sortPredictably(RegionPos[] posArray) {
+        // This should only be used on very small arrays, usually just 2 elements, so this simple O(n^2) sort is fine
+        for (int i = 0; i < posArray.length; i++) {
+            for (int j = i + 1; j < posArray.length; j++) {
+                if (compare(posArray[i], posArray[j]) > 0) {
+                    RegionPos temp = posArray[i];
+                    posArray[i] = posArray[j];
+                    posArray[j] = temp;
+                }
+            }
+        }
+        return posArray;
+    }
+
+    private static int compare(RegionPos a, RegionPos b) {
+        int x = Integer.compare(a.x, b.x);
+        if (x != 0) {
+            return x;
+        }
+        return Integer.compare(a.z, b.z);
+    }
+
+    private static int compare(ServerLevel a, ServerLevel b) {
+        return a.uuid.compareTo(b.uuid);
+    }
+
+    private CompletableFuture<Void> createTask(RegionPos regionPos, Runnable runnable) {
+        CompletableFuture<Void> future = new CompletableFuture<>();
+
+        ShreddedPaperTickThread.getExecutor().execute(() -> {
+            run(regionPos, runnable, future);
+        });
+
+        return future;
+    }
+
+    private void run(RegionPos regionPos, Runnable runnable, CompletableFuture<Void> future) {
+        try {
+            if (!locker.tryLockNow(regionPos, () -> {
+                runnable.run();
+                future.complete(null);
+            })) {
+                // Retry later
+                ShreddedPaperTickThread.getExecutor().schedule(() -> run(regionPos, runnable, future), 1, java.util.concurrent.TimeUnit.MILLISECONDS);
+            }
+        } catch (Exception e) {
+            future.completeExceptionally(e);
+        }
+    }
+
+    private void runOnMany(RegionPos[] regionPosArray, Runnable runnable, CompletableFuture<Void> future) {
+        try {
+            // Recursive runnables to lock each region in order
+            Runnable[] runnables = new Runnable[regionPosArray.length + 1];
+            for (int i = 0; i < regionPosArray.length; i++) {
+                int finalI = i;
+                runnables[i] = () -> {
+                    try {
+                        locker.tryLockNow(regionPosArray[finalI], runnables[finalI + 1]);
+                    } catch (Exception e) {
+                        future.completeExceptionally(e);
+                    }
+                };
+            }
+            runnables[runnables.length - 1] = () -> {
+                try {
+                    runnable.run();
+                    future.complete(null);
+                } catch (Exception e) {
+                    future.completeExceptionally(e);
+                }
+            };
+
+            runnables[0].run();
+
+            if (!future.isDone()) {
+                // Retry later
+                ShreddedPaperTickThread.getExecutor().schedule(() -> runOnMany(regionPosArray, runnable, future), 1, java.util.concurrent.TimeUnit.MILLISECONDS);
+            }
+        } catch (Exception e) {
+            future.completeExceptionally(e);
+        }
+    }
+
+    private static void runAcrossLevels(ServerLevel level1, RegionPos regionPos1, ServerLevel level2, RegionPos regionPos2, Runnable runnable, CompletableFuture<Void> future) {
+        try {
+            level1.chunkScheduler.locker.tryLockNow(regionPos1, () -> {
+                level2.chunkScheduler.locker.tryLockNow(regionPos2, () -> {
+                    try {
+                        runnable.run();
+                        future.complete(null);
+                    } catch (Exception e) {
+                        future.completeExceptionally(e);
+                    }
+                });
+            });
+
+            if (!future.isDone()) {
+                // Retry later
+                ShreddedPaperTickThread.getExecutor().schedule(() -> runAcrossLevels(level1, regionPos1, level2, regionPos2, runnable, future), 1, java.util.concurrent.TimeUnit.MILLISECONDS);
+            }
+        } catch (Exception e) {
+            future.completeExceptionally(e);
+        }
+    }
+
+    public ShreddedPaperRegionLocker getRegionLocker() {
+        return locker;
+    }
+
+}
diff --git a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperTickThread.java b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperTickThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..6794d2979074b8468e0859e06de4d2dcc087e57b
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperTickThread.java
@@ -0,0 +1,61 @@
+package io.multipaper.shreddedpaper.threading;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.TickThread;
+import org.slf4j.Logger;
+import io.multipaper.shreddedpaper.config.ShreddedPaperConfiguration;
+
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class ShreddedPaperTickThread extends TickThread {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    public static final int THREAD_COUNT;
+
+    private static final AtomicInteger ID_GENERATOR = new AtomicInteger();
+
+    private static final ScheduledThreadPoolExecutor executor;
+
+    static {
+        int threadCount = ShreddedPaperConfiguration.get().multithreading.threadCount;
+
+        if (threadCount <= 0) {
+            threadCount = Math.max(Runtime.getRuntime().availableProcessors() - 1, 1);
+        }
+
+        THREAD_COUNT = threadCount;
+
+        executor = new ScheduledThreadPoolExecutor(THREAD_COUNT, r -> new ShreddedPaperTickThread(r, "ShreddedPaperTickThread-%d"));
+
+        LOGGER.info("Using {} threads", THREAD_COUNT);
+    }
+
+    public ShreddedPaperTickThread(Runnable run, String name) {
+        super(run, String.format(name, ID_GENERATOR.incrementAndGet()));
+    }
+
+    public static boolean isShreddedPaperTickThread() {
+        // Use this method to check if it's a shreddedpaper tick thread, to ensure future potential support for VirtualThreads
+        return Thread.currentThread() instanceof ShreddedPaperTickThread;
+    }
+
+    static ScheduledThreadPoolExecutor getExecutor() {
+        return executor;
+    }
+
+    public static void stopServer() {
+        executor.shutdown();
+        try {
+            executor.awaitTermination(5, TimeUnit.SECONDS);
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+        if (!executor.isTerminated()) {
+            LOGGER.warn("Failed to stop tick threads after 5 seconds. Terminating...");
+            executor.shutdownNow();
+        }
+    }
+}
diff --git a/src/main/java/io/multipaper/shreddedpaper/util/ObjectHolder.java b/src/main/java/io/multipaper/shreddedpaper/util/ObjectHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..f98327c487394dd1e1a97987518102786114fcad
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/util/ObjectHolder.java
@@ -0,0 +1,22 @@
+package io.multipaper.shreddedpaper.util;
+
+public class ObjectHolder <T> {
+
+    T value;
+
+    public ObjectHolder() {
+        this(null);
+    }
+
+    public ObjectHolder(T object) {
+        this.value = object;
+    }
+
+    public T value() {
+        return value;
+    }
+
+    public void value(T value) {
+        this.value = value;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index 7ce9ebba8ce304d1f3f21d4f15ee5f3560d7700b..2c82a48867ab347f21822576baa0368273242f82 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -4,6 +4,8 @@ import co.aikar.timings.TimedEventExecutor;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerEventException;
 import com.google.common.collect.Sets;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperTickThread;
+import io.papermc.paper.util.TickThread;
 import org.bukkit.Server;
 import org.bukkit.Warning;
 import org.bukkit.event.Event;
@@ -36,7 +38,7 @@ class PaperEventManager {
 
     // SimplePluginManager
     public void callEvent(@NotNull Event event) {
-        if (event.isAsynchronous() && this.server.isPrimaryThread()) {
+        if (event.isAsynchronous() && (Thread.currentThread() instanceof TickThread || ShreddedPaperTickThread.isShreddedPaperTickThread())) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
         } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping()) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index bdaf062f9b66ceab303a0807eca301342886a8ea..313f30948c9ebd09094c1623bfe2c3594f30077c 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -1,5 +1,6 @@
 package io.papermc.paper.util;
 
+import io.multipaper.shreddedpaper.threading.ShreddedPaperTickThread;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
@@ -12,6 +13,11 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import org.bukkit.Bukkit;
+import io.multipaper.shreddedpaper.region.RegionPos;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 
 public class TickThread extends Thread {
@@ -35,56 +41,77 @@ public class TickThread extends Thread {
         ensureTickThread(reason);
     }
 
+    // ShreddedPaper start
+    public static void failedTickThreadCheck(final String reason, final String extraData) {
+        if (!isTickThread()) {
+            MinecraftServer.LOGGER.error(Thread.currentThread().getName() + " tried to run a task async: " + reason);
+        } else {
+            MinecraftServer.LOGGER.error(Thread.currentThread().getName() + " tried to run a task from the wrong thread: " + reason);
+        }
+        MinecraftServer.LOGGER.error("Extra data: " + extraData);
+        MinecraftServer.LOGGER.error("Server Version: " + Bukkit.getVersion());
+        MinecraftServer.LOGGER.error("Region locks currently held (regionSize=" + RegionPos.REGION_SIZE + " chunks): " + getCurrentLocksHeld());
+        MinecraftServer.LOGGER.error("Stack trace:", new Throwable());
+        throw new IllegalStateException(reason);
+    }
+
+    private static List<String> getCurrentLocksHeld() {
+        List<String> strings = new ArrayList<>();
+
+        for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
+            Set<RegionPos> regions = level.chunkScheduler.getRegionLocker().getLockedRegions();
+            if (!regions.isEmpty()) {
+                strings.add(level.convertable.getLevelId() + "=" + regions.stream().map(region -> "[" + region.x + "," + region.z + "]").toList());
+            }
+        }
+
+        return strings;
+    }
+    // ShreddedPaper end
+
     /**
      * @deprecated
      */
     @Deprecated
     public static void ensureTickThread(final String reason) {
         if (!isTickThread()) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            failedTickThreadCheck(reason, null);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final BlockPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            failedTickThreadCheck(reason, "world=" + world.convertable.getLevelId() + ", pos=" + pos);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final ChunkPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            failedTickThreadCheck(reason, "world=" + world.convertable.getLevelId() + ", chunkpos=" + pos);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final int chunkX, final int chunkZ, final String reason) {
         if (!isTickThreadFor(world, chunkX, chunkZ)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            failedTickThreadCheck(reason, "world=" + world.convertable.getLevelId() + ", chunkpos=[" + chunkX + "," + chunkZ + "]");
         }
     }
 
     public static void ensureTickThread(final Entity entity, final String reason) {
         if (!isTickThreadFor(entity)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            failedTickThreadCheck(reason, "entity=" + entity);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final AABB aabb, final String reason) {
         if (!isTickThreadFor(world, aabb)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            failedTickThreadCheck(reason, "world=" + world.convertable.getLevelId() + ", aabb=" + aabb);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final double blockX, final double blockZ, final String reason) {
         if (!isTickThreadFor(world, blockX, blockZ)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            failedTickThreadCheck(reason, "world=" + world.convertable.getLevelId() + ", x=" + (int) blockX + " y=? z=" + (int) blockZ);
         }
     }
 
@@ -110,50 +137,84 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThread() {
-        return Thread.currentThread() instanceof TickThread;
+        return MinecraftServer.getServer().forceTicks || isShutdownThread() || Thread.currentThread() instanceof TickThread || ShreddedPaperTickThread.isShreddedPaperTickThread(); // ShreddedPaper
     }
 
     public static boolean isShutdownThread() {
-        return false;
+        return Thread.currentThread() == MinecraftServer.getServer().shutdownThread; // ShreddedPaper
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final BlockPos pos) {
-        return isTickThread();
+        return isTickThreadFor(world, new ChunkPos(pos)); // ShreddedPaper
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final ChunkPos pos) {
-        return isTickThread();
+        return world.getServer().forceTicks || isShutdownThread() || world.chunkScheduler.getRegionLocker().hasLock(RegionPos.forChunk(pos)); // ShreddedPaper
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final Vec3 pos) {
-        return isTickThread();
+        return isTickThreadFor(world, pos.x, pos.z); // ShreddedPaper
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final int chunkX, final int chunkZ) {
-        return isTickThread();
+        return isTickThreadFor(world, new ChunkPos(chunkX, chunkZ)); // ShreddedPaper
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final AABB aabb) {
-        return isTickThread();
+        return isTickThreadFor(world, CoordinateUtils.getChunkCoordinate(aabb.minX), CoordinateUtils.getChunkCoordinate(aabb.minZ), CoordinateUtils.getChunkCoordinate(aabb.maxX), CoordinateUtils.getChunkCoordinate(aabb.maxZ)); // ShreddedPaper
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final double blockX, final double blockZ) {
-        return isTickThread();
+        return isTickThreadFor(world, CoordinateUtils.getChunkCoordinate(blockX), CoordinateUtils.getChunkCoordinate(blockZ)); // ShreddedPaper
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final Vec3 position, final Vec3 deltaMovement, final int buffer) {
-        return isTickThread();
+        // ShreddedPaper start
+        int fromChunkX = CoordinateUtils.getChunkCoordinate(position.x);
+        int fromChunkZ = CoordinateUtils.getChunkCoordinate(position.z);
+        int toChunkX = CoordinateUtils.getChunkCoordinate(position.x + deltaMovement.x);
+        int toChunkZ = CoordinateUtils.getChunkCoordinate(position.z + deltaMovement.z);
+
+        int minChunkX = Math.min(fromChunkX, toChunkX) - buffer;
+        int minChunkZ = Math.min(fromChunkZ, toChunkZ) - buffer;
+        int maxChunkX = Math.max(fromChunkX, toChunkX) + buffer;
+        int maxChunkZ = Math.max(fromChunkZ, toChunkZ) + buffer;
+
+        return isTickThreadFor(world, minChunkX, minChunkZ, maxChunkX, maxChunkZ);
+        // ShreddedPaper end
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final int fromChunkX, final int fromChunkZ, final int toChunkX, final int toChunkZ) {
-        return isTickThread();
+        // ShreddedPaper start
+        if (world.getServer().forceTicks || isShutdownThread()) return true;
+
+        int fromRegionX = fromChunkX >> RegionPos.REGION_SHIFT;
+        int fromRegionZ = fromChunkZ >> RegionPos.REGION_SHIFT;
+        int toRegionX = toChunkX >> RegionPos.REGION_SHIFT;
+        int toRegionZ = toChunkZ >> RegionPos.REGION_SHIFT;
+
+        int minRegionX = Math.min(fromRegionX, toRegionX);
+        int maxRegionX = Math.max(fromRegionX, toRegionX);
+        int minRegionZ = Math.min(fromRegionZ, toRegionZ);
+        int maxRegionZ = Math.max(fromRegionZ, toRegionZ);
+
+        for (int x = minRegionX; x <= maxRegionX; x++) {
+            for (int z = minRegionZ; z <= maxRegionZ; z++) {
+                if (!world.chunkScheduler.getRegionLocker().hasLock(new RegionPos(x, z))) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+        // ShreddedPaper end
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final int chunkX, final int chunkZ, final int radius) {
-        return isTickThread();
+        return isTickThreadFor(world, chunkX - radius, chunkZ - radius, chunkX + radius, chunkZ + radius); // ShreddedPaper
     }
 
     public static boolean isTickThreadFor(final Entity entity) {
-        return isTickThread();
+        return isTickThreadFor((ServerLevel) entity.level(), entity.chunkPosition()); // ShreddedPaper
     }
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 76edb0f99033d4819b82118a8ea21063674dcdd8..c617f12b7e44859a4edafc0deff844cd2148268d 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -191,6 +191,7 @@ import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
 import co.aikar.timings.MinecraftTimings; // Paper
+import io.multipaper.shreddedpaper.threading.ShreddedPaperTickThread;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, CommandSource, AutoCloseable {
 
@@ -977,6 +978,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         MinecraftServer.LOGGER.info("Stopping server");
         Commands.COMMAND_SENDING_POOL.shutdownNow(); // Paper - Perf: Async command map building; Shutdown and don't bother finishing
         MinecraftTimings.stopServer(); // Paper
+        ShreddedPaperTickThread.stopServer(); // ShreddedPaper
         // Purpur start
         if (upnp) {
             if (dev.omega24.upnp4j.UPnP4J.close(this.getPort(), dev.omega24.upnp4j.util.Protocol.TCP)) {
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 4c5017026e8a07508a43b1baa9617e8c8b6e659f..e9eb7f3a28474bc6d3c9f787e8d09b4a80e7fffe 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -50,7 +50,6 @@ import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
@@ -78,8 +77,6 @@ import net.minecraft.util.Mth;
 import net.minecraft.util.ProgressListener;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.Unit;
-import net.minecraft.util.datafix.DataFixTypes;
-import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.valueproviders.IntProvider;
 import net.minecraft.util.valueproviders.UniformInt;
 import net.minecraft.world.DifficultyInstance;
@@ -134,16 +131,13 @@ import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.storage.EntityStorage;
 import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
-import net.minecraft.world.level.chunk.storage.SimpleRegionStorage;
 import net.minecraft.world.level.dimension.BuiltinDimensionTypes;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.dimension.end.EndDragonFight;
-import net.minecraft.world.level.entity.EntityPersistentStorage;
 import net.minecraft.world.level.entity.EntityTickList;
 import net.minecraft.world.level.entity.EntityTypeTest;
 import net.minecraft.world.level.entity.LevelCallback;
 import net.minecraft.world.level.entity.LevelEntityGetter;
-import net.minecraft.world.level.entity.PersistentEntitySectionManager;
 import net.minecraft.world.level.gameevent.DynamicGameEventListener;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.gameevent.GameEventDispatcher;
@@ -180,6 +174,7 @@ import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperRegionScheduler;
 // CraftBukkit end
 
 public class ServerLevel extends Level implements WorldGenLevel {
@@ -223,6 +218,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     private double preciseTime; // Purpur
     private boolean forceTime; // Purpur
     private final RandomSequences randomSequences;
+    public final ShreddedPaperRegionScheduler chunkScheduler = new ShreddedPaperRegionScheduler(); // ShreddedPaper
     public long lastMidTickExecuteFailure; // Paper - execute chunk tasks mid tick
 
     // CraftBukkit start
diff --git a/src/main/java/net/minecraft/world/level/ChunkPos.java b/src/main/java/net/minecraft/world/level/ChunkPos.java
index 54cd046587c2f9dd26204bfa4eb65b8ad52b2d5e..cf28077748878476d7059828a04ea78921a94c71 100644
--- a/src/main/java/net/minecraft/world/level/ChunkPos.java
+++ b/src/main/java/net/minecraft/world/level/ChunkPos.java
@@ -7,6 +7,7 @@ import java.util.stream.StreamSupport;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
+import io.multipaper.shreddedpaper.region.RegionPos;
 
 public class ChunkPos {
     private static final int SAFETY_MARGIN = 1056;
@@ -24,6 +25,7 @@ public class ChunkPos {
     private static final int HASH_A = 1664525;
     private static final int HASH_C = 1013904223;
     private static final int HASH_Z_XOR = -559038737;
+    @Nullable private RegionPos regionPos; // ShreddedPaper
 
     public ChunkPos(int x, int z) {
         this.x = x;
@@ -43,6 +45,16 @@ public class ChunkPos {
         this.longKey = asLong(this.x, this.z); // Paper
     }
 
+    // ShreddedPaper start
+    public RegionPos getRegionPos() {
+        if (this.regionPos == null) {
+            // Cache the RegionPos to minimize object creation
+            this.regionPos = RegionPos.forChunk(this.x, this.z);
+        }
+        return this.regionPos;
+    }
+    // ShreddedPaper end
+
     public static ChunkPos minFromRegion(int x, int z) {
         return new ChunkPos(x << 5, z << 5);
     }
