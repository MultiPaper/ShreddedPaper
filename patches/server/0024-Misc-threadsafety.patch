From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sat, 25 May 2024 13:58:42 +0900
Subject: [PATCH] Misc threadsafety


diff --git a/src/main/java/com/destroystokyo/paper/util/RedstoneWireTurbo.java b/src/main/java/com/destroystokyo/paper/util/RedstoneWireTurbo.java
index 9f17170179cc99d84ad25a1e838aff3d8cc66f93..e0f567a94fb73d0d20a513f9a1a72974965063c9 100644
--- a/src/main/java/com/destroystokyo/paper/util/RedstoneWireTurbo.java
+++ b/src/main/java/com/destroystokyo/paper/util/RedstoneWireTurbo.java
@@ -833,14 +833,14 @@ public class RedstoneWireTurbo {
         j = getMaxCurrentStrength(upd, j);
         int l = 0;
 
-        wire.shouldSignal = false;
+        wire.shouldSignalThreadLocal.set(false); // ShreddedPaper - use thread local for shouldSignal
         // Unfortunately, World.isBlockIndirectlyGettingPowered is complicated,
         // and I'm not ready to try to replicate even more functionality from
         // elsewhere in Minecraft into this accelerator.  So sadly, we must
         // suffer the performance hit of this very expensive call.  If there
         // is consistency to what this call returns, we may be able to cache it.
         final int k = worldIn.getBestNeighborSignal(upd.self);
-        wire.shouldSignal = true;
+        wire.shouldSignalThreadLocal.set(true); // ShreddedPaper - use thread local for shouldSignal
 
         // The variable 'k' holds the maximum redstone power value of any adjacent blocks.
         // If 'k' has the highest level of all neighbors, then the power level of this
diff --git a/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java b/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
index a5f706d6f716b2a463ae58adcde69d9e665c7733..2f269fee6e9119db5b67934627d66e96672da892 100644
--- a/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
+++ b/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
@@ -154,11 +154,11 @@ public final class SingleThreadChunkRegionManager {
         return section;
     }
 
-    public void addChunk(final int chunkX, final int chunkZ) {
+    public synchronized void addChunk(final int chunkX, final int chunkZ) { // ShreddedPaper - synchronized
         this.getOrCreateAndMergeSection(chunkX >> this.regionChunkShift, chunkZ >> this.regionChunkShift, null).addChunk(chunkX, chunkZ);
     }
 
-    public void removeChunk(final int chunkX, final int chunkZ) {
+    public synchronized void removeChunk(final int chunkX, final int chunkZ) { // ShreddedPaper - synchronized
         final RegionSection section = this.regionsBySection.get(
                 MCUtil.getCoordinateKey(chunkX >> this.regionChunkShift, chunkZ >> this.regionChunkShift)
         );
@@ -169,7 +169,7 @@ public final class SingleThreadChunkRegionManager {
         }
     }
 
-    public void recalculateRegions() {
+    public synchronized void recalculateRegions() { // ShreddedPaper - synchronized
         for (int i = 0, len = this.needsRecalculation.size(); i < len; ++i) {
             final Region region = this.needsRecalculation.removeFirst();
 
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index 758c155c23d95c3cc952cb14f864c703f9b45127..6b83f09f9862e298cad009b3e3a384478f616030 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -6,6 +6,7 @@ import com.google.common.collect.ImmutableList;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
 import com.mojang.logging.LogUtils;
+import io.multipaper.shreddedpaper.region.RegionPos;
 import io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader;
 import io.papermc.paper.chunk.system.io.RegionFileIOThread;
 import io.papermc.paper.chunk.system.poi.PoiChunk;
@@ -50,6 +51,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -57,6 +59,7 @@ import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.LockSupport;
 import java.util.function.Predicate;
+import java.util.function.Supplier;
 
 public final class ChunkHolderManager {
 
@@ -279,7 +282,23 @@ public final class ChunkHolderManager {
         for (int i = 0, len = holders.size(); i < len; ++i) {
             final NewChunkHolder holder = holders.get(i);
             try {
-                final NewChunkHolder.SaveStat saveStat = holder.save(shutdown, false);
+                // ShreddedPaper start - save on chunk's thread
+                CompletableFuture<NewChunkHolder.SaveStat> future;
+                Supplier<NewChunkHolder.SaveStat> supplier = () -> holder.save(shutdown, false);
+                do {
+                    if (TickThread.isShutdownThread()) {
+                        // We're shutting down, no need to worry about chunk threads
+                        future = CompletableFuture.completedFuture(supplier.get());
+                    } else {
+                        future = CompletableFuture.supplyAsync(supplier, r -> world.chunkScheduler.getRegionLocker().tryReadOnlyLockNow(RegionPos.forChunk(holder.vanillaChunkHolder.pos), r));
+                        if (!future.isDone()) {
+                            // Poll task while we wait for region to become unlocked
+                            world.chunkSource.mainThreadProcessor.pollTask();
+                        }
+                    }
+                } while (!future.isDone());
+                final NewChunkHolder.SaveStat saveStat = future.join();
+                // ShreddedPaper end - save on chunk's thread
                 if (saveStat != null) {
                     ++saved;
                     needsFlush = flush;
diff --git a/src/main/java/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java b/src/main/java/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java
index 6df0db8b4cdab23494ea34236949ece4989110a3..28a62457a0a02c81055af711105b306f446b3fb5 100644
--- a/src/main/java/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java
@@ -63,7 +63,7 @@ public class BoatDispenseItemBehavior extends DefaultDispenseItemBehavior {
         CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
         BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(d1, d2 + d4, d3));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
             worldserver.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/src/main/java/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java b/src/main/java/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java
index f28705547a62da790f5df071400986aacba39367..18b64fe578ea7c865d8f84b57ad6743b013264fb 100644
--- a/src/main/java/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java
@@ -85,7 +85,7 @@ public class DefaultDispenseItemBehavior implements DispenseItemBehavior {
         CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack);
 
         BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), CraftVector.toBukkit(entityitem.getDeltaMovement()));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
             world.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java b/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
index 68236139e3571791b891dbbef6e3ee20031e16d9..f076380621dc6a40663e4f703de458a1d9b87fd9 100644
--- a/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
@@ -114,7 +114,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                 BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -173,7 +173,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                 BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -228,7 +228,7 @@ public interface DispenseItemBehavior {
                     CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                     BlockDispenseArmorEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) list.get(0).getBukkitEntity());
-                    if (!DispenserBlock.eventFired) {
+                    if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                         world.getCraftServer().getPluginManager().callEvent(event);
                     }
 
@@ -284,7 +284,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                 BlockDispenseArmorEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) entityhorseabstract.getBukkitEntity());
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                     world.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -358,7 +358,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                 BlockDispenseArmorEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) entityhorsechestedabstract.getBukkitEntity());
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                     world.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -430,7 +430,7 @@ public interface DispenseItemBehavior {
                     CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
                     BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(x, y, z));
-                    if (!DispenserBlock.eventFired) {
+                    if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                         worldserver.getCraftServer().getPluginManager().callEvent(event);
                     }
 
@@ -506,7 +506,7 @@ public interface DispenseItemBehavior {
                         CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
                         BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
-                        if (!DispenserBlock.eventFired) {
+                        if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                             worldserver.getCraftServer().getPluginManager().callEvent(event);
                         }
 
@@ -553,7 +553,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack); // Paper - ignore stack size on damageable items
 
                 BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -616,7 +616,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
                 BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -645,8 +645,8 @@ public interface DispenseItemBehavior {
                 // CraftBukkit start
                 worldserver.captureTreeGeneration = false;
                 if (worldserver.capturedBlockStates.size() > 0) {
-                    TreeType treeType = SaplingBlock.treeType;
-                    SaplingBlock.treeType = null;
+                    TreeType treeType = SaplingBlock.treeTypeThreadLocal.get(); // ShreddedPaper - thread local for treeType
+                    SaplingBlock.treeTypeThreadLocal.remove(); // ShreddedPaper - thread local for treeType
                     Location location = CraftLocation.toBukkit(blockposition, worldserver.getWorld());
                     List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(worldserver.capturedBlockStates.values());
                     worldserver.capturedBlockStates.clear();
@@ -685,7 +685,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                 BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector((double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                    worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -742,7 +742,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
                 BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -791,7 +791,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
                 BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -864,7 +864,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - only single item in event
 
                 BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -946,7 +946,7 @@ public interface DispenseItemBehavior {
                     CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                     BlockDispenseEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) list.get(0).getBukkitEntity());
-                    if (!DispenserBlock.eventFired) {
+                    if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                         world.getCraftServer().getPluginManager().callEvent(event);
                     }
 
diff --git a/src/main/java/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java b/src/main/java/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java
index e37d2d29f3ba67cfe28abe4847a3dca07121f0be..2b0c59dac5cbe34d2e88c2634d4e58bfeaf9fd0c 100644
--- a/src/main/java/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java
@@ -45,7 +45,7 @@ public class ProjectileDispenseBehavior extends DefaultDispenseItemBehavior {
         CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
         BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector((double) enumdirection.getStepX(), (double) enumdirection.getStepY(), (double) enumdirection.getStepZ()));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
             worldserver.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java b/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
index e4fab82b369f2c2ea0d8c8acd814d06140d551fc..eea19c71541204c0cccbba2bc86e0538d33027a2 100644
--- a/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
@@ -41,7 +41,7 @@ public class ShearsDispenseItemBehavior extends OptionalDispenseItemBehavior {
         CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack); // Paper - ignore stack size on damageable items
 
         BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
             worldserver.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/src/main/java/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java b/src/main/java/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java
index cb308808906a8cdb127df8284e106e00553473ca..e0bce00aa34e283bacbeb32a5a7e4e5b73d72338 100644
--- a/src/main/java/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java
@@ -37,7 +37,7 @@ public class ShulkerBoxDispenseBehavior extends OptionalDispenseItemBehavior {
             CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
             BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
-            if (!DispenserBlock.eventFired) {
+            if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                 pointer.level().getCraftServer().getPluginManager().callEvent(event);
             }
 
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 61327dfa158b385bfba4768493fd7724c4da73c5..d2494f38d1208e2e21daf7c45ccbfe07f3e02f7c 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -61,6 +61,7 @@ import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
 import net.minecraft.network.protocol.login.LoginProtocols;
 import net.minecraft.network.protocol.status.ClientStatusPacketListener;
 import net.minecraft.network.protocol.status.StatusProtocols;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.RunningOnDifferentThreadException;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.util.Mth;
@@ -340,6 +341,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
     private static void syncAfterConfigurationChange(ChannelFuture future) {
         try {
+            if (TickThread.isTickThread()) MinecraftServer.getServer().managedBlock(future::isDone); // ShreddedPaper - don't block main thread
             future.syncUninterruptibly();
         } catch (Exception exception) {
             if (exception instanceof ClosedChannelException) {
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 472b9494f8a34a8ba90d6a2936b0db7530a229ad..0e0c3a010d5cfaa0c15bcb38c4e3b1a8d7ad39a1 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -1,6 +1,8 @@
 package net.minecraft.server.level;
 
 import com.mojang.datafixers.util.Pair;
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 import java.util.ArrayList;
@@ -212,6 +214,9 @@ public class ChunkHolder {
     // Paper - rewrite chunk system
 
     public void blockChanged(BlockPos pos) {
+        if (!chunkMap.level.getServer().forceTicks && !TickThread.isShutdownThread() && !this.chunkMap.level.chunkScheduler.getRegionLocker().hasWriteLock(RegionPos.forBlockPos(pos))) { // ShreddedPaper
+            TickThread.failedTickThreadCheck("Block change is not write locked", "world=" + this.chunkMap.level.convertable.getLevelId() + ", pos=" + pos + ", newstate=" + this.getFullChunkNow().getBlockState(pos)); // ShreddedPaper
+        } // ShreddedPaper
         // Paper start - replace player chunk loader
         if (this.playersSentChunkTo.size() == 0) {
             return;
diff --git a/src/main/java/net/minecraft/server/level/PlayerMap.java b/src/main/java/net/minecraft/server/level/PlayerMap.java
index 12f1345ff70388fb217100bfc717ef861785381d..9c0f561a65ed5f5b45ce4c30754f71b310e614b0 100644
--- a/src/main/java/net/minecraft/server/level/PlayerMap.java
+++ b/src/main/java/net/minecraft/server/level/PlayerMap.java
@@ -2,36 +2,47 @@ package net.minecraft.server.level;
 
 import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
 import it.unimi.dsi.fastutil.objects.Object2BooleanOpenHashMap;
+import io.multipaper.shreddedpaper.util.SimpleStampedLock;
+
+import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 public final class PlayerMap {
     private final Object2BooleanMap<ServerPlayer> players = new Object2BooleanOpenHashMap<>();
-
-    public Set<ServerPlayer> getAllPlayers() {
-        return this.players.keySet();
+    private final SimpleStampedLock playersLock = new SimpleStampedLock(); // ShreddedPaper
+    private final CopyOnWriteArrayList<ServerPlayer> playersList = new CopyOnWriteArrayList<>(); // ShreddedPaper
+
+    public List<ServerPlayer> getAllPlayers() { // ShreddedPaper
+        // ShreddedPaper - change to a CopyOnWriteArrayList cache of the player key set to allow for thread-safe iteration
+        //  - Players aren't added/removed often, so a CopyOnWriteArrayList is sufficient
+        // return this.players.keySet(); // ShreddedPaper
+        return this.playersList; // ShreddedPaper
     }
 
     public void addPlayer(ServerPlayer player, boolean inactive) {
-        this.players.put(player, inactive);
+        this.playersLock.write(() -> this.players.put(player, inactive)); // ShreddedPaper
+        this.playersList.add(player); // ShreddedPaper
     }
 
     public void removePlayer(ServerPlayer player) {
-        this.players.removeBoolean(player);
+        this.playersLock.write(() -> this.players.removeBoolean(player)); // ShreddedPaper
+        this.playersList.remove(player); // ShreddedPaper
     }
 
     public void ignorePlayer(ServerPlayer player) {
-        this.players.replace(player, true);
+        this.playersLock.write(() -> this.players.replace(player, true)); // ShreddedPaper
     }
 
     public void unIgnorePlayer(ServerPlayer player) {
-        this.players.replace(player, false);
+        this.playersLock.write(() -> this.players.replace(player, false)); // ShreddedPaper
     }
 
     public boolean ignoredOrUnknown(ServerPlayer player) {
-        return this.players.getOrDefault(player, true);
+        return this.playersLock.optimisticRead(() -> this.players.getOrDefault(player, true)); // ShreddedPaper
     }
 
     public boolean ignored(ServerPlayer player) {
-        return this.players.getBoolean(player);
+        return this.playersLock.optimisticRead(() -> this.players.getBoolean(player)); // ShreddedPaper
     }
 }
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index 073743301c2e70fcd148c33e97be2a3069d6109e..b7f5bae372b75805c759b3ce9a91557b6fe1b27c 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -13,6 +13,8 @@ import java.util.Set;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import io.multipaper.shreddedpaper.ShreddedPaper;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientGamePacketListener;
@@ -130,6 +132,7 @@ public class ServerEntity {
                     MapItemSavedData worldmap = MapItem.getSavedData(mapid, this.level);
 
                     if (worldmap != null) {
+                        synchronized (worldmap) { // ShreddedPaper - thread-safe
                         Iterator<ServerPlayerConnection> iterator = this.trackedPlayers.iterator(); // CraftBukkit
 
                         while (iterator.hasNext()) {
@@ -141,6 +144,7 @@ public class ServerEntity {
                             if (packet != null) {
                                 entityplayer.connection.send(packet);
                             }
+                        } // ShreddedPaper - thread-safe
                         }
                     }
                 }
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 099251e47f8a8bd303fec64a157f78eeda416f21..dbdb0db0836315a7f7d4234a20608df1b0b3071c 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -1020,7 +1020,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     private void wakeUpAllPlayers() {
         this.sleepStatus.removeAllSleepers();
         (this.players.stream().filter(LivingEntity::isSleeping).collect(Collectors.toList())).forEach((entityplayer) -> { // CraftBukkit - decompile error
-            entityplayer.stopSleepInBed(false, false);
+            entityplayer.getBukkitEntity().taskScheduler.schedule(e -> entityplayer.stopSleepInBed(false, false), e -> {}, 1); // ShreddedPaper - run sync
         });
     }
     // Paper start - optimise random block ticking
@@ -2206,13 +2206,14 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         final net.minecraft.world.level.saveddata.SavedData existing = storage.cache.get(id.key());
         if (existing == null && !storage.cache.containsKey(id.key())) {
-            final MapItemSavedData worldmap = (MapItemSavedData) this.getServer().overworld().getDataStorage().get(MapItemSavedData.factory(), id.key());
-            storage.cache.put(id.key(), worldmap);
+            final MapItemSavedData worldmap = (MapItemSavedData) this.getServer().overworld().getDataStorage().get(MapItemSavedData.factory(), id.key()); // ShreddedPaper - this is already a thread-safe cache fill
+            // storage.cache.put(id.key(), worldmap); // ShreddedPaper - unnecessary and thread-unsafe - The .get() above already puts it in the cache thread-safely
             if (worldmap != null) {
                 worldmap.id = id;
-                new MapInitializeEvent(worldmap.mapView).callEvent();
+                if (worldmap.hasCalledMapInitializeEvent.compareAndSet(false, true)) new MapInitializeEvent(worldmap.mapView).callEvent(); // ShreddedPaper - ensure only called once
                 return worldmap;
             }
+            return worldmap;
         } else if (existing instanceof MapItemSavedData mapItemSavedData) {
             mapItemSavedData.id = id;
         }
@@ -2226,7 +2227,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         // CraftBukkit start
         state.id = id;
         MapInitializeEvent event = new MapInitializeEvent(state.mapView);
-        Bukkit.getServer().getPluginManager().callEvent(event);
+        if (state.hasCalledMapInitializeEvent.compareAndSet(false, true)) Bukkit.getServer().getPluginManager().callEvent(event); // ShreddedPaper - ensure only called once
         // CraftBukkit end
         this.getServer().overworld().getDataStorage().set(id.key(), state);
     }
@@ -2548,7 +2549,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public void blockUpdated(BlockPos pos, Block block) {
         if (!this.isDebug()) {
             // CraftBukkit start
-            if (this.populating) {
+            if (this.populatingThreadLocal.get()) { // ShreddedPaper - thread local for populating
                 return;
             }
             // CraftBukkit end
@@ -2841,6 +2842,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     {
                         if ( o instanceof MapItemSavedData )
                         {
+                            synchronized (o) { // ShreddedPaper - thread-safe
                             MapItemSavedData map = (MapItemSavedData) o;
                             map.carriedByPlayers.remove( (Player) entity );
                             for ( Iterator<MapItemSavedData.HoldingPlayer> iter = (Iterator<MapItemSavedData.HoldingPlayer>) map.carriedBy.iterator(); iter.hasNext(); )
@@ -2851,6 +2853,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                                     iter.remove();
                                 }
                             }
+                            } // ShreddedPaper - thread-safe
                         }
                     }
                 } );
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 509601a62a2bcbaefb7aed6856a4076e874311c7..9fa73f3848f89364ac46b7bdffc5591b53a64e16 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -2862,6 +2862,8 @@ public class ServerPlayer extends Player {
 
                 this.connection.send(new ClientboundRemoveMobEffectPacket(entity.getId(), mobeffect.getEffect()));
             }
+
+            if (entity.tracker != null) entity.tracker.serverEntity.sendChanges(); // ShreddedPaper - send changes now
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 6189ba831a32dd61e32d52f61301ae01bf3d33e1..96b58f95866c12e03d96f10e4f5b31311e663a23 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -3539,7 +3539,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
         this.filterTextPacket(list).thenAcceptAsync((list1) -> {
             this.updateSignText(packet, list1);
-        }, this.server);
+        }, r -> ShreddedPaper.runSync(this.player, r)); // ShreddedPaper - run on region thread
     }
 
     private void updateSignText(ServerboundSignUpdatePacket packet, List<FilteredText> signText) {
diff --git a/src/main/java/net/minecraft/util/thread/ReentrantBlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/ReentrantBlockableEventLoop.java
index 137fe86e33d63c629d69072ee7cbc15cdef1a4d8..081d5c96534746bf647f49c28f69b1666d8fef54 100644
--- a/src/main/java/net/minecraft/util/thread/ReentrantBlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/ReentrantBlockableEventLoop.java
@@ -1,7 +1,9 @@
 package net.minecraft.util.thread;
 
+import java.util.concurrent.atomic.AtomicInteger;
+
 public abstract class ReentrantBlockableEventLoop<R extends Runnable> extends BlockableEventLoop<R> {
-    private int reentrantCount;
+    private final AtomicInteger reentrantCount = new AtomicInteger(); // ShreddedPaper - use AtomicInteger
 
     public ReentrantBlockableEventLoop(String name) {
         super(name);
@@ -13,17 +15,17 @@ public abstract class ReentrantBlockableEventLoop<R extends Runnable> extends Bl
     }
 
     protected boolean runningTask() {
-        return this.reentrantCount != 0;
+        return this.reentrantCount.get() != 0; // ShreddedPaper - use AtomicInteger
     }
 
     @Override
     public void doRunTask(R task) {
-        this.reentrantCount++;
+        this.reentrantCount.getAndIncrement(); // ShreddedPaper - use AtomicInteger
 
         try {
             super.doRunTask(task);
         } finally {
-            this.reentrantCount--;
+            this.reentrantCount.getAndDecrement(); // ShreddedPaper - use AtomicInteger
         }
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index a755ea41486e5850014b133a1cdd455574742fdc..6c1e9965b10b5709129110bf408eaada8991542c 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1467,7 +1467,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     protected BlockPos getOnPos(float offset) {
-        if (this.mainSupportingBlockPos.isPresent() && this.level().getChunkIfLoadedImmediately(this.mainSupportingBlockPos.get()) != null) { // Paper - ensure no loads
+        if (this.mainSupportingBlockPos.isPresent() && this.level().getChunkIfLoadedImmediately(this.mainSupportingBlockPos.get()) != null && TickThread.isTickThreadFor((ServerLevel) this.level(), this.mainSupportingBlockPos.get())) { // Paper - ensure no loads // ShreddedPaper - ensure same region
             BlockPos blockposition = (BlockPos) this.mainSupportingBlockPos.get();
 
             if (offset <= 1.0E-5F) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index c6f193339fdcbcc938d4eafdcad0b112cf1698d5..256fbdc2a287a8232c8ecb9d0e06290a141a49ee 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -49,7 +49,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         return POI_DATA_SOURCE - level;
     }
 
-    protected void updateDistanceTracking(long section) {
+    protected synchronized void updateDistanceTracking(long section) {
         if (this.isVillageCenter(section)) {
             this.villageDistanceTracker.setSource(section, POI_DATA_SOURCE);
         } else {
@@ -228,7 +228,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         return this.getOrLoad(SectionPos.asLong(pos)).map(poiSet -> poiSet.getFreeTickets(pos)).orElse(0);
     }
 
-    public int sectionsToVillage(SectionPos pos) {
+    public synchronized int sectionsToVillage(SectionPos pos) {
         this.villageDistanceTracker.propagateUpdates(); // Paper - replace distance tracking util
         return convertBetweenLevels(this.villageDistanceTracker.getLevel(io.papermc.paper.util.CoordinateUtils.getChunkSectionKey(pos))); // Paper - replace distance tracking util
     }
@@ -243,7 +243,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
     }
 
     @Override
-    public void tick(BooleanSupplier shouldKeepTicking) {
+    public synchronized void tick(BooleanSupplier shouldKeepTicking) {
         this.villageDistanceTracker.propagateUpdates(); // Paper - rewrite chunk system
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 30c6f3ee109207c4eaa4244b6838f56514113d38..3fce197ad51db1fa5d498d5126920752014b7dd5 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -832,7 +832,9 @@ public abstract class Player extends LivingEntity {
             if (itemstack.getItem() == Items.FILLED_MAP) {
                 net.minecraft.world.level.saveddata.maps.MapItemSavedData worldmap = net.minecraft.world.item.MapItem.getSavedData(itemstack, this.level());
                 if (worldmap != null) {
+                    synchronized (worldmap) { // ShreddedPaper - thread-safe
                     worldmap.tickCarriedBy(this, itemstack);
+                    } // ShreddedPaper - thread-safe
                 }
             }
             // Paper end
diff --git a/src/main/java/net/minecraft/world/item/ArmorItem.java b/src/main/java/net/minecraft/world/item/ArmorItem.java
index b108ca4c7900ccf6a14ebea01c21c103459054f8..4576722aac8cb7f5310fc4c981a78488b17918bb 100644
--- a/src/main/java/net/minecraft/world/item/ArmorItem.java
+++ b/src/main/java/net/minecraft/world/item/ArmorItem.java
@@ -77,7 +77,7 @@ public class ArmorItem extends Item implements Equipable {
             CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
             BlockDispenseArmorEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) entityliving.getBukkitEntity());
-            if (!DispenserBlock.eventFired) {
+            if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                 world.getCraftServer().getPluginManager().callEvent(event);
             }
 
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index dc6c07b3cce53da0247fa8e2a7dc70d02a55ade4..20c2ed5b8a4a76554f251aa9c28fa5df10553bd9 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -23,7 +23,6 @@ import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
 import net.minecraft.core.HolderLookup;
 import net.minecraft.core.HolderSet;
@@ -47,7 +46,6 @@ import net.minecraft.network.chat.HoverEvent;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.codec.ByteBufCodecs;
 import net.minecraft.network.codec.StreamCodec;
-import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.resources.RegistryOps;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
@@ -93,7 +91,7 @@ import org.slf4j.Logger;
 
 // CraftBukkit start
 import java.util.Map;
-import java.util.Objects;
+
 import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.BaseEntityBlock;
@@ -421,8 +419,8 @@ public final class ItemStack implements DataComponentHolder {
             if (enuminteractionresult.consumesAction() && world.captureTreeGeneration && world.capturedBlockStates.size() > 0) {
                 world.captureTreeGeneration = false;
                 Location location = CraftLocation.toBukkit(blockposition, world.getWorld());
-                TreeType treeType = SaplingBlock.treeType;
-                SaplingBlock.treeType = null;
+                TreeType treeType = SaplingBlock.treeTypeThreadLocal.get(); // ShreddedPaper - thread local for treeType
+                SaplingBlock.treeTypeThreadLocal.remove(); // ShreddedPaper - thread local for treeType
                 List<CraftBlockState> blocks = new java.util.ArrayList<>(world.capturedBlockStates.values());
                 world.capturedBlockStates.clear();
                 StructureGrowEvent structureEvent = null;
@@ -450,7 +448,7 @@ public final class ItemStack implements DataComponentHolder {
                     entityhuman.awardStat(Stats.ITEM_USED.get(item)); // SPIGOT-7236 - award stat
                 }
 
-                SignItem.openSign = null; // SPIGOT-6758 - Reset on early return
+                SignItem.openSignThreadLocal.remove(); // SPIGOT-6758 - Reset on early return // ShreddedPaper - thread local for openSign
                 return enuminteractionresult;
             }
             world.captureTreeGeneration = false;
@@ -488,7 +486,7 @@ public final class ItemStack implements DataComponentHolder {
                     //     ((ServerPlayer) entityhuman).connection.send(new ClientboundBlockUpdatePacket(world, placedPos.relative(dir)));
                     // }
                     // Paper end - Don't resync blocks
-                    SignItem.openSign = null; // SPIGOT-6758 - Reset on early return
+                    SignItem.openSignThreadLocal.remove(); // SPIGOT-6758 - Reset on early return // ShreddedPaper - thread local for openSign
                 } else {
                     // Change the stack to its new contents if it hasn't been tampered with.
                     if (this.getCount() == oldCount && Objects.equals(this.components.asPatch(), oldData)) {
@@ -548,15 +546,15 @@ public final class ItemStack implements DataComponentHolder {
                     }
 
                     // SPIGOT-4678
-                    if (this.item instanceof SignItem && SignItem.openSign != null) {
+                    if (this.item instanceof SignItem && SignItem.openSignThreadLocal.get() != null) { // ShreddedPaper - thread local for openSign
                         try {
-                            if (world.getBlockEntity(SignItem.openSign) instanceof SignBlockEntity tileentitysign) {
-                                if (world.getBlockState(SignItem.openSign).getBlock() instanceof SignBlock blocksign) {
+                            if (world.getBlockEntity(SignItem.openSignThreadLocal.get()) instanceof SignBlockEntity tileentitysign) { // ShreddedPaper - thread local for openSign
+                                if (world.getBlockState(SignItem.openSignThreadLocal.get()).getBlock() instanceof SignBlock blocksign) { // ShreddedPaper - thread local for openSign
                                     blocksign.openTextEdit(entityhuman, tileentitysign, true, io.papermc.paper.event.player.PlayerOpenSignEvent.Cause.PLACE); // Paper - Add PlayerOpenSignEvent
                                 }
                             }
                         } finally {
-                            SignItem.openSign = null;
+                            SignItem.openSignThreadLocal.remove(); // ShreddedPaper - thread local for openSign
                         }
                     }
 
diff --git a/src/main/java/net/minecraft/world/item/MapItem.java b/src/main/java/net/minecraft/world/item/MapItem.java
index 608390ed36710a419de1542b80340dd3fcc7299c..13b7973ad6d53cefea5aa037cd1a9ff2ad839df4 100644
--- a/src/main/java/net/minecraft/world/item/MapItem.java
+++ b/src/main/java/net/minecraft/world/item/MapItem.java
@@ -69,6 +69,7 @@ public class MapItem extends ComplexItem {
     }
 
     public void update(Level world, Entity entity, MapItemSavedData state) {
+        synchronized (state) { // ShreddedPaper - thread-safe
         if (world.dimension() == state.dimension && entity instanceof Player) {
             int i = 1 << state.scale;
             int j = state.centerX;
@@ -181,6 +182,7 @@ public class MapItem extends ComplexItem {
                 }
             }
         }
+        } // ShreddedPaper - thread-safe
     }
 
     private BlockState getCorrectStateForFluidBlock(Level world, BlockState state, BlockPos pos) {
@@ -195,6 +197,7 @@ public class MapItem extends ComplexItem {
     public static void renderBiomePreviewMap(ServerLevel world, ItemStack map) {
         MapItemSavedData mapItemSavedData = getSavedData(map, world);
         if (mapItemSavedData != null) {
+            synchronized (mapItemSavedData) { // ShreddedPaper - thread-safe
             mapItemSavedData.isExplorerMap = true; // Purpur
             if (world.dimension() == mapItemSavedData.dimension) {
                 int i = 1 << mapItemSavedData.scale;
@@ -265,6 +268,7 @@ public class MapItem extends ComplexItem {
                     }
                 }
             }
+            } // ShreddedPaper - thread-safe
         }
     }
 
@@ -273,6 +277,7 @@ public class MapItem extends ComplexItem {
         if (!world.isClientSide) {
             MapItemSavedData mapItemSavedData = getSavedData(stack, world);
             if (mapItemSavedData != null) {
+                synchronized (mapItemSavedData) { // ShreddedPaper - thread-safe
                 if (entity instanceof Player player) {
                     mapItemSavedData.tickCarriedBy(player, stack);
                 }
@@ -280,6 +285,7 @@ public class MapItem extends ComplexItem {
                 if (!mapItemSavedData.locked && (selected || entity instanceof Player && ((Player)entity).getOffhandItem() == stack)) {
                     this.update(world, entity, mapItemSavedData);
                 }
+                } // ShreddedPaper - thread-safe
             }
         }
     }
diff --git a/src/main/java/net/minecraft/world/item/MinecartItem.java b/src/main/java/net/minecraft/world/item/MinecartItem.java
index 4b8cebb321eddc852b4ec7def7f51d781f67927b..5a99f87ce3b58d3bc076fca9fbbff339696e89b9 100644
--- a/src/main/java/net/minecraft/world/item/MinecartItem.java
+++ b/src/main/java/net/minecraft/world/item/MinecartItem.java
@@ -71,7 +71,7 @@ public class MinecartItem extends Item {
             CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
             BlockDispenseEvent event = new BlockDispenseEvent(block2, craftItem.clone(), new org.bukkit.util.Vector(d0, d1 + d3, d2));
-            if (!DispenserBlock.eventFired) {
+            if (!DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
                 worldserver.getCraftServer().getPluginManager().callEvent(event);
             }
 
diff --git a/src/main/java/net/minecraft/world/item/SignItem.java b/src/main/java/net/minecraft/world/item/SignItem.java
index 21c25026da4117b2cb2c85576d2def945a97dbe2..9b588a6f29f67520cc67aa9ec95d70bf499289cd 100644
--- a/src/main/java/net/minecraft/world/item/SignItem.java
+++ b/src/main/java/net/minecraft/world/item/SignItem.java
@@ -13,7 +13,7 @@ import net.minecraft.world.level.block.state.BlockState;
 
 public class SignItem extends StandingAndWallBlockItem {
 
-    public static BlockPos openSign; // CraftBukkit
+    public static final ThreadLocal<BlockPos> openSignThreadLocal = new ThreadLocal<>(); // CraftBukkit // ShreddedPaper - thread local for openSign
 
     public SignItem(Item.Properties settings, Block standingBlock, Block wallBlock) {
         super(standingBlock, wallBlock, settings, Direction.DOWN);
@@ -39,7 +39,7 @@ public class SignItem extends StandingAndWallBlockItem {
 
                     // CraftBukkit start - SPIGOT-4678
                     // blocksign.openTextEdit(entityhuman, tileentitysign, true);
-                    SignItem.openSign = pos;
+                    SignItem.openSignThreadLocal.set(pos); // ShreddedPaper - thread local for openSign
                     // CraftBukkit end
                 }
             }
diff --git a/src/main/java/net/minecraft/world/item/component/LodestoneTracker.java b/src/main/java/net/minecraft/world/item/component/LodestoneTracker.java
index cdd1f6939ce33e62f6609f7eb3a5dff59bf12675..70cbe44b89f7cac1b9b598505c17f8fa77dcee46 100644
--- a/src/main/java/net/minecraft/world/item/component/LodestoneTracker.java
+++ b/src/main/java/net/minecraft/world/item/component/LodestoneTracker.java
@@ -4,6 +4,8 @@ import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
 import io.netty.buffer.ByteBuf;
 import java.util.Optional;
+
+import io.papermc.paper.util.TickThread;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.GlobalPos;
 import net.minecraft.network.codec.ByteBufCodecs;
@@ -29,7 +31,7 @@ public record LodestoneTracker(Optional<GlobalPos> target, boolean tracked) {
                 return this;
             } else {
                 BlockPos blockPos = this.target.get().pos();
-                return world.isInWorldBounds(blockPos) && (!world.hasChunkAt(blockPos) || world.getPoiManager().existsAtPosition(PoiTypes.LODESTONE, blockPos)) // Paper - Prevent compass from loading chunks
+                return world.isInWorldBounds(blockPos) && (!TickThread.isTickThreadFor(world, blockPos) || !world.hasChunkAt(blockPos) || world.getPoiManager().existsAtPosition(PoiTypes.LODESTONE, blockPos)) // Paper - Prevent compass from loading chunks // ShreddedPaper - Prevent compass from accessing outside our thread
                     ? this
                     : new LodestoneTracker(Optional.empty(), true);
             }
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 195e715a76b9b89134cf929ad2810689e6573324..84557f71d4a98842faeb4badd723ff4e3183b3b3 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -166,7 +166,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public int wakeupInactiveRemainingMonsters;
     public int wakeupInactiveRemainingVillagers;
     // Paper end
-    public boolean populating;
+    public final ThreadLocal<Boolean> populatingThreadLocal = ThreadLocal.withInitial(() -> false); // ShreddedPaper - thread local for populating
     public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
     // Paper start - add paper world config
     private final io.papermc.paper.configuration.WorldConfiguration paperConfig;
diff --git a/src/main/java/net/minecraft/world/level/block/DispenserBlock.java b/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
index f6edfea463b3725d3a79aca38825e86dbf82175c..59e8748805feaf9bc36fcc5de11c9c56e3104eeb 100644
--- a/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
@@ -51,7 +51,7 @@ public class DispenserBlock extends BaseEntityBlock {
         object2objectopenhashmap.defaultReturnValue(DispenserBlock.DEFAULT_BEHAVIOR);
     });
     private static final int TRIGGER_DURATION = 4;
-    public static boolean eventFired = false; // CraftBukkit
+    public static final ThreadLocal<Boolean> eventFiredThreadLocal = ThreadLocal.withInitial(() -> false); // CraftBukkit // ShreddedPaper - use thread local for eventFired
 
     @Override
     public MapCodec<? extends DispenserBlock> codec() {
@@ -111,7 +111,7 @@ public class DispenserBlock extends BaseEntityBlock {
 
                 if (idispensebehavior != DispenseItemBehavior.NOOP) {
                     if (!org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockPreDispenseEvent(world, pos, itemstack, i)) return; // Paper - Add BlockPreDispenseEvent
-                    DispenserBlock.eventFired = false; // CraftBukkit - reset event status
+                    DispenserBlock.eventFiredThreadLocal.set(false); // CraftBukkit - reset event status // ShreddedPaper - use thread local for eventFired
                     tileentitydispenser.setItem(i, idispensebehavior.dispense(sourceblock, itemstack));
                 }
 
diff --git a/src/main/java/net/minecraft/world/level/block/FungusBlock.java b/src/main/java/net/minecraft/world/level/block/FungusBlock.java
index 454f95ba814b375e97189430b498c0e7486fbd94..0adc7974ccbc5aee8a6c077ae8ab9641accdf013 100644
--- a/src/main/java/net/minecraft/world/level/block/FungusBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/FungusBlock.java
@@ -76,9 +76,9 @@ public class FungusBlock extends BushBlock implements BonemealableBlock {
         this.getFeature(world).ifPresent((holder) -> {
             // CraftBukkit start
             if (this == Blocks.WARPED_FUNGUS) {
-                SaplingBlock.treeType = org.bukkit.TreeType.WARPED_FUNGUS;
+                SaplingBlock.treeTypeThreadLocal.set(org.bukkit.TreeType.WARPED_FUNGUS); // ShreddedPaper - thread local for treeType
             } else if (this == Blocks.CRIMSON_FUNGUS) {
-                SaplingBlock.treeType = org.bukkit.TreeType.CRIMSON_FUNGUS;
+                SaplingBlock.treeTypeThreadLocal.set(org.bukkit.TreeType.CRIMSON_FUNGUS); // ShreddedPaper - thread local for treeType
             }
             // CraftBukkit end
             ((ConfiguredFeature) holder.value()).place(world, world.getChunkSource().getGenerator(), random, pos);
diff --git a/src/main/java/net/minecraft/world/level/block/MushroomBlock.java b/src/main/java/net/minecraft/world/level/block/MushroomBlock.java
index 1172d85c5c26ab2142343d91149766e5993cb36a..103d24bf049e2cf4ba8f4f3fab38b0a3590473a2 100644
--- a/src/main/java/net/minecraft/world/level/block/MushroomBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/MushroomBlock.java
@@ -105,7 +105,7 @@ public class MushroomBlock extends BushBlock implements BonemealableBlock {
             return false;
         } else {
             world.removeBlock(pos, false);
-            SaplingBlock.treeType = (this == Blocks.BROWN_MUSHROOM) ? TreeType.BROWN_MUSHROOM : TreeType.RED_MUSHROOM; // CraftBukkit
+            SaplingBlock.treeTypeThreadLocal.set((this == Blocks.BROWN_MUSHROOM) ? TreeType.BROWN_MUSHROOM : TreeType.RED_MUSHROOM); // CraftBukkit // ShreddedPaper - thread local for treeType
             if (((ConfiguredFeature) ((Holder) optional.get()).value()).place(world, world.getChunkSource().getGenerator(), random, pos)) {
                 return true;
             } else {
diff --git a/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java b/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
index c131734cad123a35456d18f8a161f77a4ac9ac99..77c2cf5190d5732e15bf28c9ab98f5e3b1918cb6 100644
--- a/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -68,7 +68,7 @@ public class RedStoneWireBlock extends Block {
     });
     private static final float PARTICLE_DENSITY = 0.2F;
     private final BlockState crossState;
-    public boolean shouldSignal = true;
+    public final ThreadLocal<Boolean> shouldSignalThreadLocal = ThreadLocal.withInitial(() -> true); // ShreddedPaper - use thread local for shouldSignal
 
     @Override
     public MapCodec<RedStoneWireBlock> codec() {
@@ -260,7 +260,7 @@ public class RedStoneWireBlock extends Block {
 
     // Paper start - Optimize redstone (Eigencraft)
     // The bulk of the new functionality is found in RedstoneWireTurbo.java
-    com.destroystokyo.paper.util.RedstoneWireTurbo turbo = new com.destroystokyo.paper.util.RedstoneWireTurbo(this);
+    final ThreadLocal<com.destroystokyo.paper.util.RedstoneWireTurbo> turboThreadLocal = ThreadLocal.withInitial(() -> new com.destroystokyo.paper.util.RedstoneWireTurbo(this)); // ShreddedPaper - thread local for turbo
 
     /*
      * Modified version of pre-existing updateSurroundingRedstone, which is called from
@@ -269,7 +269,7 @@ public class RedStoneWireBlock extends Block {
      */
     private void updateSurroundingRedstone(Level worldIn, BlockPos pos, BlockState state, BlockPos source) {
         if (worldIn.paperConfig().misc.redstoneImplementation == io.papermc.paper.configuration.WorldConfiguration.Misc.RedstoneImplementation.EIGENCRAFT) {
-            turbo.updateSurroundingRedstone(worldIn, pos, state, source);
+            turboThreadLocal.get().updateSurroundingRedstone(worldIn, pos, state, source); // ShreddedPaper - thread local for turbo
             return;
         }
         updatePowerStrength(worldIn, pos, state);
@@ -288,9 +288,9 @@ public class RedStoneWireBlock extends Block {
         int i = state.getValue(POWER);
         int j = 0;
         j = this.getPower(j, worldIn.getBlockState(pos2));
-        this.shouldSignal = false;
+        this.shouldSignalThreadLocal.set(false); // ShreddedPaper - use thread local for shouldSignal
         int k = worldIn.getBestNeighborSignal(pos1);
-        this.shouldSignal = true;
+        this.shouldSignalThreadLocal.set(true); // ShreddedPaper - use thread local for shouldSignal
 
         if (worldIn.paperConfig().misc.redstoneImplementation == io.papermc.paper.configuration.WorldConfiguration.Misc.RedstoneImplementation.VANILLA) {
             // This code is totally redundant to if statements just below the loop.
@@ -360,7 +360,7 @@ public class RedStoneWireBlock extends Block {
                 // [Space Walker] suppress shape updates and emit those manually to
                 // bypass the new neighbor update stack.
                 if (worldIn.setBlock(pos1, state, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_CLIENTS))
-                    turbo.updateNeighborShapes(worldIn, pos1, state);
+                    turboThreadLocal.get().updateNeighborShapes(worldIn, pos1, state); // ShreddedPaper - thread local for turbo
             }
         }
 
@@ -409,10 +409,10 @@ public class RedStoneWireBlock extends Block {
     }
 
     private int calculateTargetStrength(Level world, BlockPos pos) {
-        this.shouldSignal = false;
+        this.shouldSignalThreadLocal.set(false); // ShreddedPaper - use thread local for shouldSignal
         int i = world.getBestNeighborSignal(pos);
 
-        this.shouldSignal = true;
+        this.shouldSignalThreadLocal.set(true); // ShreddedPaper - use thread local for shouldSignal
         int j = 0;
 
         if (i < 15) {
@@ -551,12 +551,12 @@ public class RedStoneWireBlock extends Block {
 
     @Override
     protected int getDirectSignal(BlockState state, BlockGetter world, BlockPos pos, Direction direction) {
-        return !this.shouldSignal ? 0 : state.getSignal(world, pos, direction);
+        return !this.shouldSignalThreadLocal.get() ? 0 : state.getSignal(world, pos, direction); // ShreddedPaper - use thread local for shouldSignal
     }
 
     @Override
     protected int getSignal(BlockState state, BlockGetter world, BlockPos pos, Direction direction) {
-        if (this.shouldSignal && direction != Direction.DOWN) {
+        if (this.shouldSignalThreadLocal.get() && direction != Direction.DOWN) { // ShreddedPaper - use thread local for shouldSignal
             int i = (Integer) state.getValue(RedStoneWireBlock.POWER);
 
             return i == 0 ? 0 : (direction != Direction.UP && !((RedstoneSide) this.getConnectionState(world, state, pos).getValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(direction.getOpposite()))).isConnected() ? 0 : i);
@@ -583,7 +583,7 @@ public class RedStoneWireBlock extends Block {
 
     @Override
     protected boolean isSignalSource(BlockState state) {
-        return this.shouldSignal;
+        return this.shouldSignalThreadLocal.get(); // ShreddedPaper - use thread local for shouldSignal
     }
 
     public static int getColorForPower(int powerLevel) {
diff --git a/src/main/java/net/minecraft/world/level/block/SaplingBlock.java b/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
index d262a5a6da57ef9ba9a6fe0dfbc88f577105e74f..99e69f34d4f2dd9a67076e38e094246d5969cd11 100644
--- a/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
@@ -35,7 +35,7 @@ public class SaplingBlock extends BushBlock implements BonemealableBlock {
     protected static final float AABB_OFFSET = 6.0F;
     protected static final VoxelShape SHAPE = Block.box(2.0D, 0.0D, 2.0D, 14.0D, 12.0D, 14.0D);
     protected final TreeGrower treeGrower;
-    public static TreeType treeType; // CraftBukkit
+    public static final ThreadLocal<TreeType> treeTypeThreadLocal = new ThreadLocal<>(); // CraftBukkit // ShreddedPaper - thread local for treeType
 
     @Override
     public MapCodec<? extends SaplingBlock> codec() {
@@ -73,8 +73,8 @@ public class SaplingBlock extends BushBlock implements BonemealableBlock {
                 this.treeGrower.growTree(world, world.getChunkSource().getGenerator(), pos, state, random);
                 world.captureTreeGeneration = false;
                 if (world.capturedBlockStates.size() > 0) {
-                    TreeType treeType = SaplingBlock.treeType;
-                    SaplingBlock.treeType = null;
+                    TreeType treeType = SaplingBlock.treeTypeThreadLocal.get(); // ShreddedPaper - thread local for treeType
+                    SaplingBlock.treeTypeThreadLocal.remove(); // ShreddedPaper - thread local for treeType
                     Location location = CraftLocation.toBukkit(pos, world.getWorld());
                     java.util.List<BlockState> blocks = new java.util.ArrayList<>(world.capturedBlockStates.values());
                     world.capturedBlockStates.clear();
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index cd0e43f4c53a746dd6183a8406269f9b11ad3571..7ecc61382e2025d09fff0c9bc515d7da2b460d5e 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -6,6 +6,8 @@ import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.util.TickThread;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.HolderLookup;
@@ -21,6 +23,7 @@ import net.minecraft.network.chat.Component;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientGamePacketListener;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
@@ -38,7 +41,7 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import co.aikar.timings.Timing; // Paper
 
 public abstract class BlockEntity {
-    static boolean ignoreTileUpdates; // Paper - Perf: Optimize Hoppers
+    static final ThreadLocal<Boolean> ignoreTileUpdatesThreadLocal = ThreadLocal.withInitial(() -> false); // Paper - Perf: Optimize Hoppers // ShreddedPaper - use thread local for ignoreTileUpdates
 
     public Timing tickTimer = MinecraftTimings.getTileEntityTimings(this); // Paper
     // CraftBukkit start - data containers
@@ -232,7 +235,8 @@ public abstract class BlockEntity {
 
     public void setChanged() {
         if (this.level != null) {
-            if (ignoreTileUpdates) return; // Paper - Perf: Optimize Hoppers
+            if (ignoreTileUpdatesThreadLocal.get()) return; // Paper - Perf: Optimize Hoppers // ShreddedPaper - use thread local for ignoreTileUpdates
+            TickThread.ensureTickThread((ServerLevel) this.level, this.worldPosition, "Block entity modification"); // ShreddedPaper
             BlockEntity.setChanged(this.level, this.worldPosition, this.blockState);
         }
 
diff --git a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
index 8310d132006043e93c612890514c4c7f3eb1c74d..460e6111aca479334210f2524c13ab0c9fc3482c 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -237,12 +237,12 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
     }
 
     // Paper start - Perf: Optimize Hoppers
-    private static boolean skipPullModeEventFire;
-    private static boolean skipPushModeEventFire;
+    private static final ThreadLocal<Boolean> skipPullModeEventFireThreadLocal = ThreadLocal.withInitial(() -> false); // ShreddedPaper - use thread local for skipPullModeEventFire
+    private static final ThreadLocal<Boolean> skipPushModeEventFireThreadLocal = ThreadLocal.withInitial(() -> false); // ShreddedPaper - use thread local for skipPushModeEventFire
     public static boolean skipHopperEvents;
 
     private static boolean hopperPush(final Level level, final Container destination, final Direction direction, final HopperBlockEntity hopper) {
-        skipPushModeEventFire = skipHopperEvents;
+        skipPushModeEventFireThreadLocal.set(skipHopperEvents); // ShreddedPaper - use thread local for skipPushModeEventFire
         boolean foundItem = false;
         for (int i = 0; i < hopper.getContainerSize(); ++i) {
             final ItemStack item = hopper.getItem(i);
@@ -257,7 +257,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
 
                 // We only need to fire the event once to give protection plugins a chance to cancel this event
                 // Because nothing uses getItem, every event call should end up the same result.
-                if (!skipPushModeEventFire) {
+                if (!skipPushModeEventFireThreadLocal.get()) { // ShreddedPaper - use thread local for skipPushModeEventFire
                     movedItem = callPushMoveEvent(destination, movedItem, hopper);
                     if (movedItem == null) { // cancelled
                         origItemStack.setCount(originalItemCount);
@@ -293,7 +293,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
         container.setChanged(); // original logic always marks source inv as changed even if no move happens.
         movedItem.setCount(movedItemCount);
 
-        if (!skipPullModeEventFire) {
+        if (!skipPullModeEventFireThreadLocal.get()) { // ShreddedPaper - use thread local for skipPullModeEventFire
             movedItem = callPullMoveEvent(hopper, container, movedItem);
             if (movedItem == null) { // cancelled
                 origItemStack.setCount(originalItemCount);
@@ -313,9 +313,9 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
                 origItemStack.setCount(originalItemCount - movedItemCount + remainingItemCount);
             }
 
-            ignoreTileUpdates = true;
+            ignoreTileUpdatesThreadLocal.set(true); // ShreddedPaper - use thread local for ignoreTileUpdates
             container.setItem(i, origItemStack);
-            ignoreTileUpdates = false;
+            ignoreTileUpdatesThreadLocal.set(false); // ShreddedPaper - use thread local for ignoreTileUpdates
             container.setChanged();
             return true;
         }
@@ -335,7 +335,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
             CraftItemStack.asCraftMirror(itemstack), destinationInventory, true);
         final boolean result = event.callEvent();
         if (!event.calledGetItem && !event.calledSetItem) {
-            skipPushModeEventFire = true;
+            skipPushModeEventFireThreadLocal.set(true); // ShreddedPaper - use thread local for skipPushModeEventFire
         }
         if (!result) {
             cooldownHopper(hopper);
@@ -358,7 +358,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
         final io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent event = new io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent(sourceInventory, CraftItemStack.asCraftMirror(itemstack), destination, false);
         final boolean result = event.callEvent();
         if (!event.calledGetItem && !event.calledSetItem) {
-            skipPullModeEventFire = true;
+            skipPullModeEventFireThreadLocal.set(true); // ShreddedPaper - use thread local for skipPullModeEventFire
         }
         if (!result) {
             cooldownHopper(hopper);
@@ -547,7 +547,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
 
         if (iinventory != null) {
             Direction enumdirection = Direction.DOWN;
-            skipPullModeEventFire = skipHopperEvents; // Paper - Perf: Optimize Hoppers
+            skipPullModeEventFireThreadLocal.set(skipHopperEvents); // Paper - Perf: Optimize Hoppers // ShreddedPaper - use thread local for skipPullModeEventFire
             int[] aint = HopperBlockEntity.getSlots(iinventory, enumdirection);
             int i = aint.length;
 
@@ -733,9 +733,9 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
                     stack = stack.split(to.getMaxStackSize());
                 }
                 // Spigot end
-                ignoreTileUpdates = true; // Paper - Perf: Optimize Hoppers
+                ignoreTileUpdatesThreadLocal.set(true); // Paper - Perf: Optimize Hoppers // ShreddedPaper - use thread local for ignoreTileUpdates
                 to.setItem(slot, stack);
-                ignoreTileUpdates = false; // Paper - Perf: Optimize Hoppers
+                ignoreTileUpdatesThreadLocal.set(false); // Paper - Perf: Optimize Hoppers // ShreddedPaper - use thread local for ignoreTileUpdates
                 stack = leftover; // Paper - Make hoppers respect inventory max stack size
                 flag = true;
             } else if (HopperBlockEntity.canMergeItems(itemstack1, stack)) {
diff --git a/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
index 81dd0aa6a90fd9dda9e7752f85b9cf4568e3b575..a9c1d3848794b7cd67d48588637083b2f938c45c 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
@@ -45,9 +45,9 @@ public class SculkCatalystBlockEntity extends BlockEntity implements GameEventLi
     // Paper end - Fix NPE in SculkBloomEvent world access
 
     public static void serverTick(Level world, BlockPos pos, BlockState state, SculkCatalystBlockEntity blockEntity) {
-        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverride = blockEntity.getBlockPos(); // CraftBukkit - SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep.
+        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverrideThreadLocal.set(blockEntity.getBlockPos()); // CraftBukkit - SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep. // ShreddedPaper - use thread local
         blockEntity.catalystListener.getSculkSpreader().updateCursors(world, pos, world.getRandom(), true);
-        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverride = null; // CraftBukkit
+        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverrideThreadLocal.remove(); // CraftBukkit // ShreddedPaper - use thread local
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/grower/TreeGrower.java b/src/main/java/net/minecraft/world/level/block/grower/TreeGrower.java
index 597599138f69c9ee05dc7657c51c25336337875e..e7a8dd959d43b029f99178dc463b4900f67ddf60 100644
--- a/src/main/java/net/minecraft/world/level/block/grower/TreeGrower.java
+++ b/src/main/java/net/minecraft/world/level/block/grower/TreeGrower.java
@@ -25,7 +25,6 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
 // CraftBukkit start
-import net.minecraft.data.worldgen.features.TreeFeatures;
 import org.bukkit.TreeType;
 // CraftBukkit end
 
@@ -175,47 +174,47 @@ public final class TreeGrower {
     private void setTreeType(Holder<ConfiguredFeature<?, ?>> holder) {
         ResourceKey<ConfiguredFeature<?, ?>> worldgentreeabstract = holder.unwrapKey().get();
         if (worldgentreeabstract == TreeFeatures.OAK || worldgentreeabstract == TreeFeatures.OAK_BEES_005) {
-            SaplingBlock.treeType = TreeType.TREE;
+           SaplingBlock.treeTypeThreadLocal.set(TreeType.TREE); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.HUGE_RED_MUSHROOM) {
-            SaplingBlock.treeType = TreeType.RED_MUSHROOM;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.RED_MUSHROOM); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.HUGE_BROWN_MUSHROOM) {
-            SaplingBlock.treeType = TreeType.BROWN_MUSHROOM;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.BROWN_MUSHROOM); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.JUNGLE_TREE) {
-            SaplingBlock.treeType = TreeType.COCOA_TREE;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.COCOA_TREE); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.JUNGLE_TREE_NO_VINE) {
-            SaplingBlock.treeType = TreeType.SMALL_JUNGLE;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.SMALL_JUNGLE); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.PINE) {
-            SaplingBlock.treeType = TreeType.TALL_REDWOOD;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.TALL_REDWOOD); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.SPRUCE) {
-            SaplingBlock.treeType = TreeType.REDWOOD;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.REDWOOD); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.ACACIA) {
-            SaplingBlock.treeType = TreeType.ACACIA;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.ACACIA); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.BIRCH || worldgentreeabstract == TreeFeatures.BIRCH_BEES_005) {
-            SaplingBlock.treeType = TreeType.BIRCH;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.BIRCH); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.SUPER_BIRCH_BEES_0002) {
-            SaplingBlock.treeType = TreeType.TALL_BIRCH;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.TALL_BIRCH); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.SWAMP_OAK) {
-            SaplingBlock.treeType = TreeType.SWAMP;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.SWAMP); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.FANCY_OAK || worldgentreeabstract == TreeFeatures.FANCY_OAK_BEES_005) {
-            SaplingBlock.treeType = TreeType.BIG_TREE;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.BIG_TREE); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.JUNGLE_BUSH) {
-            SaplingBlock.treeType = TreeType.JUNGLE_BUSH;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.JUNGLE_BUSH); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.DARK_OAK) {
-            SaplingBlock.treeType = TreeType.DARK_OAK;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.DARK_OAK); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.MEGA_SPRUCE) {
-            SaplingBlock.treeType = TreeType.MEGA_REDWOOD;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.MEGA_REDWOOD); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.MEGA_PINE) {
-            SaplingBlock.treeType = TreeType.MEGA_PINE;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.MEGA_PINE); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.MEGA_JUNGLE_TREE) {
-            SaplingBlock.treeType = TreeType.JUNGLE;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.JUNGLE); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.AZALEA_TREE) {
-            SaplingBlock.treeType = TreeType.AZALEA;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.AZALEA); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.MANGROVE) {
-            SaplingBlock.treeType = TreeType.MANGROVE;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.MANGROVE); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.TALL_MANGROVE) {
-            SaplingBlock.treeType = TreeType.TALL_MANGROVE;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.TALL_MANGROVE); // ShreddedPaper - thread local for treeType
         } else if (worldgentreeabstract == TreeFeatures.CHERRY || worldgentreeabstract == TreeFeatures.CHERRY_BEES_005) {
-            SaplingBlock.treeType = TreeType.CHERRY;
+            SaplingBlock.treeTypeThreadLocal.set(TreeType.CHERRY); // ShreddedPaper - thread local for treeType
         } else {
             throw new IllegalArgumentException("Unknown tree generator " + worldgentreeabstract);
         }
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index 031fc626d2075cbe0941fecc188406712ab9953f..b9b084b7e9d5c9b4613d45eed9612ad5f7a4af77 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -3,6 +3,7 @@ package net.minecraft.world.level.block.state;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
+import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap;
 import java.util.Arrays;
 import java.util.Collections;
@@ -162,11 +163,11 @@ public abstract class BlockBehaviour implements FeatureElement {
     // Paper end - UseOnContext param
 
     protected void onPlace(BlockState state, Level world, BlockPos pos, BlockState oldState, boolean notify) {
-        org.spigotmc.AsyncCatcher.catchOp("block onPlace"); // Spigot
+        TickThread.ensureTickThread((ServerLevel) world, pos, "block onPlace"); // Spigot // ShreddedPaper
     }
 
     protected void onRemove(BlockState state, Level world, BlockPos pos, BlockState newState, boolean moved) {
-        org.spigotmc.AsyncCatcher.catchOp("block remove"); // Spigot
+        TickThread.ensureTickThread((ServerLevel) world, pos, "block remove"); // Spigot // ShreddedPaper
         if (state.hasBlockEntity() && !state.is(newState.getBlock())) {
             world.removeBlockEntity(pos);
         }
diff --git a/src/main/java/net/minecraft/world/level/border/WorldBorder.java b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
index 6c6eb7deed281678c05ef27f933e1693b11dae7c..ee9c8fd4924e60a8f593c886c17f0014a3dda76c 100644
--- a/src/main/java/net/minecraft/world/level/border/WorldBorder.java
+++ b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
@@ -38,14 +38,14 @@ public class WorldBorder {
     }
 
     // Paper start - Bound treasure maps to world border
-    private final BlockPos.MutableBlockPos mutPos = new BlockPos.MutableBlockPos();
+    private final ThreadLocal<BlockPos.MutableBlockPos> mutPosThreadLocal = ThreadLocal.withInitial(() -> new BlockPos.MutableBlockPos()); // ShreddedPaper - thread local for mutPos
     public boolean isBlockInBounds(int chunkX, int chunkZ) {
-        this.mutPos.set(chunkX, 64, chunkZ);
-        return this.isWithinBounds(this.mutPos);
+        this.mutPosThreadLocal.get().set(chunkX, 64, chunkZ); // ShreddedPaper - thread local for mutPos
+        return this.isWithinBounds(this.mutPosThreadLocal.get()); // ShreddedPaper - thread local for mutPos
     }
     public boolean isChunkInBounds(int chunkX, int chunkZ) {
-        this.mutPos.set(((chunkX << 4) + 15), 64, (chunkZ << 4) + 15);
-        return this.isWithinBounds(this.mutPos);
+        this.mutPosThreadLocal.get().set(((chunkX << 4) + 15), 64, (chunkZ << 4) + 15); // ShreddedPaper - thread local for mutPos
+        return this.isWithinBounds(this.mutPosThreadLocal.get()); // ShreddedPaper - thread local for mutPos
     }
     // Paper end - Bound treasure maps to world border
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 71521c19c60ed16579be100263e0c72cf8f88bec..e01aba693382654f0b078ae06538248736fe896b 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -809,13 +809,13 @@ public class LevelChunk extends ChunkAccess {
 
                 org.bukkit.World world = this.level.getWorld();
                 if (world != null) {
-                    this.level.populating = true;
+                    this.level.populatingThreadLocal.set(true); // ShreddedPaper - thread local for populating
                     try {
                         for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
                             populator.populate(world, random, bukkitChunk);
                         }
                     } finally {
-                        this.level.populating = false;
+                        this.level.populatingThreadLocal.set(false); // ShreddedPaper - thread local for populating
                     }
                 }
                 server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
diff --git a/src/main/java/net/minecraft/world/level/saveddata/maps/MapIndex.java b/src/main/java/net/minecraft/world/level/saveddata/maps/MapIndex.java
index 763b315b1d761bc3bd82d9b847ed3f64fd5ce991..841aa55043f354d5058992d43645bf9e56a723db 100644
--- a/src/main/java/net/minecraft/world/level/saveddata/maps/MapIndex.java
+++ b/src/main/java/net/minecraft/world/level/saveddata/maps/MapIndex.java
@@ -33,7 +33,7 @@ public class MapIndex extends SavedData {
     }
 
     @Override
-    public CompoundTag save(CompoundTag nbt, HolderLookup.Provider registryLookup) {
+    public synchronized CompoundTag save(CompoundTag nbt, HolderLookup.Provider registryLookup) { // ShreddedPaper - thread-safe
         for (Entry<String> entry : this.usedAuxIds.object2IntEntrySet()) {
             nbt.putInt(entry.getKey(), entry.getIntValue());
         }
@@ -41,7 +41,7 @@ public class MapIndex extends SavedData {
         return nbt;
     }
 
-    public MapId getFreeAuxValueForMap() {
+    public synchronized MapId getFreeAuxValueForMap() { // ShreddedPaper - thread-safe
         int i = this.usedAuxIds.getInt("map") + 1;
         this.usedAuxIds.put("map", i);
         this.setDirty();
diff --git a/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java b/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
index e26f6215ca42885cb0635a3183a8df93a924ba7f..5d01e9c124047ab89be5727ec4ecd044f76c202e 100644
--- a/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
+++ b/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
@@ -12,6 +12,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
@@ -72,6 +73,7 @@ public class MapItemSavedData extends SavedData {
     public byte scale;
     public byte[] colors = new byte[16384];
     public boolean locked;
+    public AtomicBoolean hasCalledMapInitializeEvent = new AtomicBoolean(false); // ShreddedPaper
     public final List<MapItemSavedData.HoldingPlayer> carriedBy = Lists.newArrayList();
     public final Map<Player, MapItemSavedData.HoldingPlayer> carriedByPlayers = Maps.newHashMap();
     private final Map<String, MapBanner> bannerMarkers = Maps.newHashMap();
diff --git a/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java b/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
index 6e23e69abd56eeda3b52a22019e1b74ae10682e7..f3d1dfb2cca74ecfc123f1c06a20462a1295d60f 100644
--- a/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
@@ -25,7 +25,7 @@ import org.slf4j.Logger;
 
 public class DimensionDataStorage implements java.io.Closeable { // Paper - Write SavedData IO async
     private static final Logger LOGGER = LogUtils.getLogger();
-    public final Map<String, SavedData> cache = Maps.newHashMap();
+    public final Map<String, SavedData> cache = Maps.newConcurrentMap(); // ShreddedPaper - thread-safe
     private final DataFixer fixerUpper;
     private final HolderLookup.Provider registries;
     private final File dataFolder;
@@ -43,25 +43,29 @@ public class DimensionDataStorage implements java.io.Closeable { // Paper - Writ
     }
 
     public <T extends SavedData> T computeIfAbsent(SavedData.Factory<T> type, String id) {
-        T savedData = this.get(type, id);
-        if (savedData != null) {
-            return savedData;
-        } else {
-            T savedData2 = (T)type.constructor().get();
-            this.set(id, savedData2);
-            return savedData2;
-        }
+        // ShreddedPaper start - thread-safe
+        return (T) this.cache.compute(id, (key, savedData) -> {
+            if (savedData != null) {
+                return savedData;
+            }
+
+            savedData = this.readSavedData(type.deserializer(), type.type(), key);
+            if (savedData != null) {
+                return  savedData;
+            }
+
+            return type.constructor().get();
+        });
+        // ShreddedPaper end - thread-safe
     }
 
     @Nullable
     public <T extends SavedData> T get(SavedData.Factory<T> type, String id) {
-        SavedData savedData = this.cache.get(id);
-        if (savedData == null && !this.cache.containsKey(id)) {
-            savedData = this.readSavedData(type.deserializer(), type.type(), id);
-            this.cache.put(id, savedData);
-        }
-
-        return (T)savedData;
+        // ShreddedPaper start - thread-safe
+        return (T) this.cache.computeIfAbsent(id, (key) -> {
+            return this.readSavedData(type.deserializer(), type.type(), key);
+        });
+        // ShreddedPaper end - thread-safe
     }
 
     @Nullable
@@ -88,8 +92,8 @@ public class DimensionDataStorage implements java.io.Closeable { // Paper - Writ
 
         CompoundTag var9;
         try (
-            InputStream inputStream = new FileInputStream(file);
-            PushbackInputStream pushbackInputStream = new PushbackInputStream(new FastBufferedInputStream(inputStream), 2);
+                InputStream inputStream = new FileInputStream(file);
+                PushbackInputStream pushbackInputStream = new PushbackInputStream(new FastBufferedInputStream(inputStream), 2);
         ) {
             CompoundTag compoundTag;
             if (this.isGzip(pushbackInputStream)) {
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index ac11f18690434922179b61ffcc3036dea025b0cb..efdac83c60651818f7d1829be8970cd1c546f3de 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -554,8 +554,8 @@ public class CraftBlock implements Block {
         world.captureTreeGeneration = false;
 
         if (world.capturedBlockStates.size() > 0) {
-            TreeType treeType = SaplingBlock.treeType;
-            SaplingBlock.treeType = null;
+            TreeType treeType = SaplingBlock.treeTypeThreadLocal.get(); // ShreddedPaper - thread local for treeType
+            SaplingBlock.treeTypeThreadLocal.remove(); // ShreddedPaper - thread local for treeType
             List<BlockState> blocks = new ArrayList<>(world.capturedBlockStates.values());
             world.capturedBlockStates.clear();
             StructureGrowEvent structureEvent = null;
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
index fa63a6cfcfcc4eee4503a82d85333c139c8c8b2b..3e7e1e1f7e4cff93f11b35050af6368a6445da66 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
@@ -4,6 +4,8 @@ import com.google.common.base.Preconditions;
 import java.lang.ref.WeakReference;
 import java.util.List;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.util.TickThread;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.level.LevelAccessor;
 import org.bukkit.Chunk;
@@ -214,6 +216,7 @@ public class CraftBlockState implements BlockState {
         }
         LevelAccessor access = this.getWorldHandle();
         CraftBlock block = this.getBlock();
+        TickThread.ensureTickThread(this.world.getHandle(), this.position, "BlockState update");
 
         if (block.getType() != this.getType()) {
             if (!force) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
index 3ed19f30f1cab9df3b1bfdf0b0caf7882a77c5f7..bebe02d73ed34453ff521ec1d803935c0287604b 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
@@ -9,6 +9,8 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
+
+import io.papermc.paper.util.TickThread;
 import net.minecraft.network.protocol.game.ClientboundHurtAnimationPacket;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
@@ -523,7 +525,7 @@ public class CraftLivingEntity extends CraftEntity implements LivingEntity {
 
     @Override
     public boolean addPotionEffect(PotionEffect effect, boolean force) {
-        org.spigotmc.AsyncCatcher.catchOp("effect add"); // Paper
+        TickThread.ensureTickThread(this.getHandle(), "effect add"); // Paper // ShreddedPaper
         this.getHandle().addEffect(org.bukkit.craftbukkit.potion.CraftPotionUtil.fromBukkit(effect), EntityPotionEffectEvent.Cause.PLUGIN); // Paper - Don't ignore icon
         return true;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 27ff2b3037a90ee94bea767c285f2454e545aad2..494920321af0098e390d6b2669403acc97dab984 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -3501,7 +3501,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     // Paper start - Add chunk view API
     @Override
     public Set<java.lang.Long> getSentChunkKeys() {
-        org.spigotmc.AsyncCatcher.catchOp("accessing sent chunks");
+        TickThread.ensureTickThread(this.getHandle(), "accessing sent chunks"); // ShreddedPaper
         return it.unimi.dsi.fastutil.longs.LongSets.unmodifiable(
             this.getHandle().chunkLoader.getSentChunksRaw().clone()
         );
@@ -3509,7 +3509,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public Set<org.bukkit.Chunk> getSentChunks() {
-        org.spigotmc.AsyncCatcher.catchOp("accessing sent chunks");
+        TickThread.ensureTickThread(this.getHandle(), "accessing sent chunks"); // ShreddedPaper
         final it.unimi.dsi.fastutil.longs.LongOpenHashSet rawChunkKeys = this.getHandle().chunkLoader.getSentChunksRaw();
         final it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<org.bukkit.Chunk> chunks = new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>(rawChunkKeys.size());
         final org.bukkit.World world = this.getWorld();
@@ -3522,7 +3522,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public boolean isChunkSent(final long chunkKey) {
-        org.spigotmc.AsyncCatcher.catchOp("accessing sent chunks");
+        TickThread.ensureTickThread(this.getHandle(), "accessing sent chunks"); // ShreddedPaper
         return this.getHandle().chunkLoader.getSentChunksRaw().contains(chunkKey);
     }
     // Paper end
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 5308dc55bcc334ad6bef927de6c2d9b9364d99ff..309786921442a94a275a7dcd923cfc216845f010 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -951,7 +951,7 @@ public class CraftEventFactory {
         return CraftEventFactory.handleBlockSpreadEvent(world, source, target, block, 2);
     }
 
-    public static BlockPos sourceBlockOverride = null; // SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep.
+    public static ThreadLocal<BlockPos> sourceBlockOverrideThreadLocal = ThreadLocal.withInitial(() -> null); // SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep. // ShreddedPaper - use thread local
 
     public static boolean handleBlockSpreadEvent(LevelAccessor world, BlockPos source, BlockPos target, net.minecraft.world.level.block.state.BlockState block, int flag) {
         // Suppress during worldgen
@@ -963,7 +963,7 @@ public class CraftEventFactory {
         CraftBlockState state = CraftBlockStates.getBlockState(world, target, flag);
         state.setData(block);
 
-        BlockSpreadEvent event = new BlockSpreadEvent(state.getBlock(), CraftBlock.at(world, CraftEventFactory.sourceBlockOverride != null ? CraftEventFactory.sourceBlockOverride : source), state);
+        BlockSpreadEvent event = new BlockSpreadEvent(state.getBlock(), CraftBlock.at(world, CraftEventFactory.sourceBlockOverrideThreadLocal.get() != null ? CraftEventFactory.sourceBlockOverrideThreadLocal.get() : source), state); // ShreddedPaper - use thread local
         Bukkit.getPluginManager().callEvent(event);
 
         if (!event.isCancelled()) {
@@ -2164,7 +2164,7 @@ public class CraftEventFactory {
         CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemStack.copyWithCount(1));
 
         org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(bukkitBlock, craftItem.clone(), CraftVector.toBukkit(to));
-        if (!net.minecraft.world.level.block.DispenserBlock.eventFired) {
+        if (!net.minecraft.world.level.block.DispenserBlock.eventFiredThreadLocal.get()) { // ShreddedPaper - use thread local for eventFired
             if (!event.callEvent()) {
                 return itemStack;
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryPlayer.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryPlayer.java
index eafa54c870c3e2aef30c3f9f96f516607a7cae24..1ba11d3653790464bc9af174daecf351fac07d4e 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryPlayer.java
@@ -1,6 +1,7 @@
 package org.bukkit.craftbukkit.inventory;
 
 import com.google.common.base.Preconditions;
+import io.papermc.paper.util.TickThread;
 import net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket;
 import net.minecraft.network.protocol.game.ClientboundSetCarriedItemPacket;
 import net.minecraft.server.level.ServerPlayer;
@@ -70,6 +71,7 @@ public class CraftInventoryPlayer extends CraftInventory implements org.bukkit.i
 
     @Override
     public void setItem(int index, ItemStack item) {
+        TickThread.ensureTickThread(getInventory().player, "Player inventory modification"); // ShreddedPaper
         super.setItem(index, item);
         if (this.getHolder() == null) return;
         ServerPlayer player = ((CraftPlayer) this.getHolder()).getHandle();
diff --git a/src/main/java/org/purpurmc/purpur/task/BossBarTask.java b/src/main/java/org/purpurmc/purpur/task/BossBarTask.java
index 114f273dd7f8b8a3c02f0651f6944859b33a65d4..bc501ce058f001a4c87bf2d513a855f1f35ff138 100644
--- a/src/main/java/org/purpurmc/purpur/task/BossBarTask.java
+++ b/src/main/java/org/purpurmc/purpur/task/BossBarTask.java
@@ -12,9 +12,10 @@ import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
 
 public abstract class BossBarTask extends BukkitRunnable {
-    private final Map<UUID, BossBar> bossbars = new HashMap<>();
+    private final Map<UUID, BossBar> bossbars = new ConcurrentHashMap<>(); // ShreddedPaper
     private boolean started;
 
     abstract BossBar createBossBar();
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index 6505f4bc7000de7b53f4f8fae2393d2c0a315c72..b19b33e02f289837cc8f11fe2e1467fce158e7a9 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -3,9 +3,18 @@ package org.spigotmc;
 import java.lang.management.ManagementFactory;
 import java.lang.management.MonitorInfo;
 import java.lang.management.ThreadInfo;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperTickThread;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
 import org.bukkit.Bukkit;
 
 public final class WatchdogThread extends io.papermc.paper.util.TickThread // Paper - rewrite chunk system
@@ -193,6 +202,11 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.dumpAllChunkLoadInfo(isLongTimeout); // Paper - rewrite chunk system
                 this.dumpTickingInfo(); // Paper - log detailed tick information
                 WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE ), log );
+                // ShreddedPaper start - Dump stuck worker threads
+                for (ThreadInfo worker : getStuckTickWorkerThreads()) {
+                    WatchdogThread.dumpThread( worker, log );
+                }
+                // ShreddedPaper end - Dump stuck worker threads
                 log.log( Level.SEVERE, "------------------------------" );
                 //
                 // Paper start - Only print full dump on long timeouts
@@ -245,6 +259,29 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
         }
     }
 
+    // ShreddedPaper start
+    private List<ThreadInfo> getStuckTickWorkerThreads() {
+        ThreadInfo[] threads = ManagementFactory.getThreadMXBean().dumpAllThreads( true, true );
+        return Arrays.stream(threads)
+                .filter(thread -> thread.getThreadName().startsWith("ShreddedPaperTickThread"))
+                .filter(thread -> Arrays.stream(thread.getStackTrace()).anyMatch(stack -> !stack.getClassName().startsWith("java") && !stack.getClassName().startsWith("jdk")))
+                .toList();
+    }
+
+    private static List<String> getCurrentLocksHeld(ThreadInfo thread) {
+        List<String> strings = new ArrayList<>();
+
+        for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
+            List<RegionPos> regions = level.chunkScheduler.getRegionLocker().getAllLockedRegions().stream().filter(entry -> entry.getValue().owner().threadId() == thread.getThreadId()).map(Map.Entry::getKey).toList();
+            if (!regions.isEmpty()) {
+                strings.add(level.convertable.getLevelId() + "=" + regions.stream().map(region -> "[" + region.x + "," + region.z + "]").toList());
+            }
+        }
+
+        return strings;
+    }
+    // ShreddedPaper end
+
     private static void dumpThread(ThreadInfo thread, Logger log)
     {
         log.log( Level.SEVERE, "------------------------------" );
@@ -254,6 +291,14 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
                 + " | Suspended: " + thread.isSuspended()
                 + " | Native: " + thread.isInNative()
                 + " | State: " + thread.getThreadState() );
+
+        // ShreddedPaper start - Dump region locks held by this thread
+        List<String> locksHeld = getCurrentLocksHeld(thread);
+        if (!locksHeld.isEmpty()) {
+            log.log( Level.SEVERE, "\tRegion locks held (regionSize=" + RegionPos.REGION_SIZE + " chunks): " + locksHeld);
+        }
+        // ShreddedPaper end - Dump region locks held by this thread
+
         if ( thread.getLockedMonitors().length != 0 )
         {
             log.log( Level.SEVERE, "\tThread is waiting on monitor(s):" );
