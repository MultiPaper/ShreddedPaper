From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kevin Raneri <kevin.raneri@gmail.com>
Date: Wed, 3 Feb 2021 23:02:38 -0600
Subject: [PATCH] Pufferfish

Pufferfish branding

Update branding

Pufferfish Utils

Pufferfish Config and Command

Add SIMD utilities

Add Sentry

Add option to disable books

Books are commonly the target of duping-related exploits. If you
anticipate that your server will be an early target of duping attacks in
the event that new exploits are found, you may want to consider removing
the ability for non-privileged players to edit books. This patch allows
you to easily disable books, should you want to preemptively remove this
functionality before additional exploits are found.

Optimize suffocation

The isInWall check to determine suffocation is quite expensive, and
often is completely unnecessary to check. We do two things here to
improve this:

1. We only check for suffocation once per 20 ticks. The maximum
no-damage ticks value means that this change should be extremely
difficult, if not impossible, for players to notice.

2. We additionally execute a check to see if the player can even take
damage in the first place. This check doesn't improve performance much
but is so much cheaper than the suffocation check that it's worth
keeping it.

Optimize mob spawning

This patch aims to reduce the main-thread impact of mob spawning by
offloading as much work as possible to other threads. It is possible for
inconsistencies to come up, but when they happen they never interfere
with the server's operation (they don't produce errors), and side
effects are limited to more or less mobs being spawned in any particular
tick.

It is possible to disable this optimization if it is not required or if
it interferes with any plugins. On servers with thousands of entities,
this can result in performance gains of up to 15%, which is significant
and, in my opinion, worth the low risk of minor mob-spawning-related
inconsistencies.

Simpler ShapelessRecipes comparison for Vanilla

Paper added a fancy sorting comparison due to Bukkit recipes breaking
the vanilla one, however this is far more advanced than what you need
for all the vanilla recipes.

Airplane
Copyright (C) 2020 Technove LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

Reduce projectile chunk loading

Airplane
Copyright (C) 2020 Technove LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

Only check for spooky season once an hour

Airplane
Copyright (C) 2020 Technove LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

Optimize random calls in chunk ticking

Especially at over 30,000 chunks these random calls are fairly heavy. We
use a different method here for checking lightning, and for checking
ice.

Lightning: Each chunk now keeps an int of how many ticks until the
lightning should strike. This int is a random number from 0 to 100000 * 2,
the multiplication is required to keep the probability the same.

Ice and snow: We just generate a single random number 0-16 and increment
it, while checking if it's 0 for the current chunk.

Depending on configuration for things that tick in a chunk, this is a
5-10% improvement.

Airplane
Copyright (C) 2020 Technove LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

Dynamic Activation of Brain

This replaces the current method of ticking an inactive entity's
pathfinder 1/4 times with a new method that's dynamic based off how far
away it is from a player. If an entity is within 32 blocks, it gets
ticked every tick. If it's within 45 blocks, it gets ticked every other
tick. If it's within 55 blocks, it gets ticked once every three ticks.
(these numbers have since been changed, but the idea is the same.)

Airplane
Copyright (C) 2020 Technove LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

Reduce chunk loading & lookups

Airplane
Copyright (C) 2020 Technove LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

Flare Profiler

Airplane
Copyright (C) 2020 Technove LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

Remove iterators from inventory contains

Early return optimization for target finding

Improve fluid direction caching

Implements a custom cache that better fits the needs of fluids
calculating whether a direction can be moved in or something. There's a
big javadoc on the FluidDirectionCache with some more information.

Cache climbing check for activation

Config to disable method profiler

Make EntityCollisionContext a live representation

While Context is in the name, it is not used as a context. Instead it is
always created, use temporarily, then thrown away. This means having a
lot of fields to initialize and make space for is useless. I cannot find
anywhere in the codebase where this is used as a context which may be
saved for later, so this should be safe assuming plugins don't use it
for some strange reason.

Better checking for useless move packets

Remove streams and iterators from range check

Skip cloning loot parameters

Small improvement in CPU, much larger improvement in allocations. As a
new loot context is created every time a player moves (along with a lot
of other times) the constant cloning churns out a lot of useless
objects.

Fix Paper#6045, block goal shouldn't load chunks

Reduce entity allocations

Remove lambda from ticking guard

Reduce entity fluid lookups if no fluids

Throttle goal selector during inactive ticking

Entity TTL

Option to disable end crystal dragon respawning

On servers that expect end crystal fights in the end dimension,
disabling this will prevent the server from performing an expensive
search to attempt respawning the ender dragon whenever a player places
an end crystal.

TPS catchup

Pufferfish Utils

Original license: GPL v3
Original project: https://github.com/pufferfish-gg/Pufferfish

Pufferfish: Optimize mob spawning

Original license: GPL v3
Original project: https://github.com/pufferfish-gg/Pufferfish

This patch aims to reduce the main-thread impact of mob spawning by
offloading as much work as possible to other threads. It is possible for
inconsistencies to come up, but when they happen they never interfere
with the server's operation (they don't produce errors), and side
effects are limited to more or less mobs being spawned in any particular
tick.

It is possible to disable this optimization if it is not required or if
it interferes with any plugins. On servers with thousands of entities,
this can result in performance gains of up to 15%, which is significant
and, in my opinion, worth the low risk of minor mob-spawning-related
inconsistencies.

diff --git a/build.gradle.kts b/build.gradle.kts
index d23ecfabf6bf1e355fb2efe5abd80236259ce3c4..4db7610b7812c124595f103f30c599ac0bc34067 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -51,6 +51,14 @@ dependencies {
     implementation("org.mozilla:rhino-engine:1.7.14") // Purpur
     implementation("dev.omega24:upnp4j:1.0") // Purpur
 
+    // Pufferfish start
+    implementation("org.yaml:snakeyaml:1.32")
+    implementation ("me.carleslc.Simple-YAML:Simple-Yaml:1.8.4") {
+        exclude(group="org.yaml", module="snakeyaml")
+    }
+    // Pufferfish end
+    implementation("com.github.technove:Flare:34637f3f87") // Pufferfish - flare
+
     testImplementation("io.github.classgraph:classgraph:4.8.47") // Paper - mob goal test
     testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
     testImplementation("org.hamcrest:hamcrest:2.2")
@@ -71,6 +79,14 @@ paperweight {
     craftBukkitPackageVersion.set("v1_20_R4") // also needs to be updated in MappingEnvironment
 }
 
+
+// Pufferfish Start
+tasks.withType<JavaCompile> {
+    val compilerArgs = options.compilerArgs
+    compilerArgs.add("--add-modules=jdk.incubator.vector")
+}
+// Pufferfish End
+
 tasks.jar {
     archiveClassifier.set("dev")
 
diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index 7620c72a4c243cbeea245203ce03a97cbfa7d922..b35a9f4c5f8960864c402ede8a51fb5ab9c4fcc0 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -240,7 +240,8 @@ public class TimingsExport extends Thread {
         parent.put("config", createObject(
             pair("spigot", mapAsJSON(Bukkit.spigot().getSpigotConfig(), null)),
             pair("bukkit", mapAsJSON(Bukkit.spigot().getBukkitConfig(), null)),
-            pair("paper", mapAsJSON(Bukkit.spigot().getPaperConfig(), null))
+            pair("paper", mapAsJSON(Bukkit.spigot().getPaperConfig(), null)), // Pufferfish
+            pair("pufferfish", mapAsJSON(gg.pufferfish.pufferfish.PufferfishConfig.getConfigCopy(), null)) // Pufferfish
         ));
 
         new TimingsExport(listeners, parent, history).start();
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
index 41b9405d6759d865e0d14dd4f95163e9690e967d..091b1ae822e1c0517e59572e7a9bda11e998c0ee 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
@@ -26,7 +26,7 @@ public abstract class AreaMap<E> {
 
     // we use linked for better iteration.
     // map of: coordinate to set of objects in coordinate
-    protected final Long2ObjectOpenHashMap<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> areaMap = new Long2ObjectOpenHashMap<>(1024, 0.7f);
+    protected Long2ObjectOpenHashMap<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> areaMap = new Long2ObjectOpenHashMap<>(1024, 0.7f); // Pufferfish - not actually final
     protected final PooledLinkedHashSets<E> pooledHashSets;
 
     protected final ChangeCallback<E> addCallback;
@@ -160,7 +160,8 @@ public abstract class AreaMap<E> {
     protected abstract PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getEmptySetFor(final E object);
 
     // expensive op, only for debug
-    protected void validate(final E object, final int viewDistance) {
+    protected void validate0(final E object, final int viewDistance) { // Pufferfish - rename this thing just in case it gets used I'd rather a compile time error.
+        if (true) throw new UnsupportedOperationException(); // Pufferfish - not going to put in the effort to fix this if it doesn't ever get used.
         int entiesGot = 0;
         int expectedEntries = (2 * viewDistance + 1);
         expectedEntries *= expectedEntries;
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
index 46954db7ecd35ac4018fdf476df7c8020d7ce6c8..1ad890a244bdf6df48a8db68cb43450e08c788a6 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
@@ -5,7 +5,7 @@ import net.minecraft.server.level.ServerPlayer;
 /**
  * @author Spottedleaf
  */
-public final class PlayerAreaMap extends AreaMap<ServerPlayer> {
+public class PlayerAreaMap extends AreaMap<ServerPlayer> { // Pufferfish - not actually final
 
     public PlayerAreaMap() {
         super();
diff --git a/src/main/java/gg/airplane/structs/FluidDirectionCache.java b/src/main/java/gg/airplane/structs/FluidDirectionCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa8467b9dda1f7707e41f50ac7b3e9d7343723ec
--- /dev/null
+++ b/src/main/java/gg/airplane/structs/FluidDirectionCache.java
@@ -0,0 +1,136 @@
+package gg.airplane.structs;
+
+import it.unimi.dsi.fastutil.HashCommon;
+
+/**
+ * This is a replacement for the cache used in FluidTypeFlowing.
+ * The requirements for the previous cache were:
+ *  - Store 200 entries
+ *  - Look for the flag in the cache
+ *  - If it exists, move to front of cache
+ *  - If it doesn't exist, remove last entry in cache and insert in front
+ *
+ * This class accomplishes something similar, however has a few different
+ * requirements put into place to make this more optimize:
+ *
+ *  - maxDistance is the most amount of entries to be checked, instead
+ *    of having to check the entire list.
+ *  - In combination with that, entries are all tracked by age and how
+ *    frequently they're used. This enables us to remove old entries,
+ *    without constantly shifting any around.
+ *
+ * Usage of the previous map would have to reset the head every single usage,
+ * shifting the entire map. Here, nothing happens except an increment when
+ * the cache is hit, and when it needs to replace an old element only a single
+ * element is modified.
+ */
+public class FluidDirectionCache<T> {
+
+    private static class FluidDirectionEntry<T> {
+        private final T data;
+        private final boolean flag;
+        private int uses = 0;
+        private int age = 0;
+
+        private FluidDirectionEntry(T data, boolean flag) {
+            this.data = data;
+            this.flag = flag;
+        }
+
+        public int getValue() {
+            return this.uses - (this.age >> 1); // age isn't as important as uses
+        }
+
+        public void incrementUses() {
+            this.uses = this.uses + 1 & Integer.MAX_VALUE;
+        }
+
+        public void incrementAge() {
+            this.age = this.age + 1 & Integer.MAX_VALUE;
+        }
+    }
+
+    private final FluidDirectionEntry[] entries;
+    private final int mask;
+    private final int maxDistance; // the most amount of entries to check for a value
+
+    public FluidDirectionCache(int size) {
+        int arraySize = HashCommon.nextPowerOfTwo(size);
+        this.entries = new FluidDirectionEntry[arraySize];
+        this.mask = arraySize - 1;
+        this.maxDistance = Math.min(arraySize, 4);
+    }
+
+    public Boolean getValue(T data) {
+        FluidDirectionEntry curr;
+        int pos;
+
+        if ((curr = this.entries[pos = HashCommon.mix(data.hashCode()) & this.mask]) == null) {
+            return null;
+        } else if (data.equals(curr.data)) {
+            curr.incrementUses();
+            return curr.flag;
+        }
+
+        int checked = 1; // start at 1 because we already checked the first spot above
+
+        while ((curr = this.entries[pos = (pos + 1) & this.mask]) != null) {
+            if (data.equals(curr.data)) {
+                curr.incrementUses();
+                return curr.flag;
+            } else if (++checked >= this.maxDistance) {
+                break;
+            }
+        }
+
+        return null;
+    }
+
+    public void putValue(T data, boolean flag) {
+        FluidDirectionEntry<T> curr;
+        int pos;
+
+        if ((curr = this.entries[pos = HashCommon.mix(data.hashCode()) & this.mask]) == null) {
+            this.entries[pos] = new FluidDirectionEntry<>(data, flag); // add
+            return;
+        } else if (data.equals(curr.data)) {
+            curr.incrementUses();
+            return;
+        }
+
+        int checked = 1; // start at 1 because we already checked the first spot above
+
+        while ((curr = this.entries[pos = (pos + 1) & this.mask]) != null) {
+            if (data.equals(curr.data)) {
+                curr.incrementUses();
+                return;
+            } else if (++checked >= this.maxDistance) {
+                this.forceAdd(data, flag);
+                return;
+            }
+        }
+
+        this.entries[pos] = new FluidDirectionEntry<>(data, flag); // add
+    }
+
+    private void forceAdd(T data, boolean flag) {
+        int expectedPos = HashCommon.mix(data.hashCode()) & this.mask;
+
+        int toRemovePos = expectedPos;
+        FluidDirectionEntry entryToRemove = this.entries[toRemovePos];
+
+        for (int i = expectedPos + 1; i < expectedPos + this.maxDistance; i++) {
+            int pos = i & this.mask;
+            FluidDirectionEntry entry = this.entries[pos];
+            if (entry.getValue() < entryToRemove.getValue()) {
+                toRemovePos = pos;
+                entryToRemove = entry;
+            }
+
+            entry.incrementAge(); // use this as a mechanism to age the other entries
+        }
+
+        // remove the least used/oldest entry
+        this.entries[toRemovePos] = new FluidDirectionEntry(data, flag);
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/PufferfishCommand.java b/src/main/java/gg/pufferfish/pufferfish/PufferfishCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..020368da69b9a492155f6de6297f74732f4ab6ea
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/PufferfishCommand.java
@@ -0,0 +1,68 @@
+package gg.pufferfish.pufferfish;
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.md_5.bungee.api.ChatColor;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class PufferfishCommand extends Command {
+
+    public PufferfishCommand() {
+        super("pufferfish");
+        this.description = "Pufferfish related commands";
+        this.usageMessage = "/pufferfish [reload | version]";
+        this.setPermission("bukkit.command.pufferfish");
+    }
+    
+    public static void init() {
+        MinecraftServer.getServer().server.getCommandMap().register("pufferfish", "Pufferfish", new PufferfishCommand());
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        if (args.length == 1) {
+            return Stream.of("reload", "version")
+              .filter(arg -> arg.startsWith(args[0].toLowerCase()))
+              .collect(Collectors.toList());
+        }
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+        String prefix = ChatColor.of("#12fff6") + "" + ChatColor.BOLD + "Pufferfish Â» " + ChatColor.of("#e8f9f9");
+
+        if (args.length != 1) {
+            sender.sendMessage(prefix + "Usage: " + usageMessage);
+            args = new String[]{"version"};
+        }
+
+        if (args[0].equalsIgnoreCase("reload")) {
+            MinecraftServer console = MinecraftServer.getServer();
+            try {
+                PufferfishConfig.load();
+            } catch (IOException e) {
+                sender.sendMessage(Component.text("Failed to reload.", NamedTextColor.RED));
+                e.printStackTrace();
+                return true;
+            }
+            console.server.reloadCount++;
+
+            Command.broadcastCommandMessage(sender, prefix + "Pufferfish configuration has been reloaded.");
+        } else if (args[0].equalsIgnoreCase("version")) {
+            Command.broadcastCommandMessage(sender, prefix + "This server is running " + Bukkit.getName() + " version " + Bukkit.getVersion() + " (Implementing API version " + Bukkit.getBukkitVersion() + ")");
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/PufferfishConfig.java b/src/main/java/gg/pufferfish/pufferfish/PufferfishConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d918b0adedf6c3054c40b327f03941e75c4b517
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/PufferfishConfig.java
@@ -0,0 +1,332 @@
+package gg.pufferfish.pufferfish;
+
+import gg.pufferfish.pufferfish.simd.SIMDDetection;
+import java.io.File;
+import java.io.IOException;
+import java.util.Collections;
+import net.minecraft.core.registries.BuiltInRegistries;
+import java.util.Locale;
+import java.util.Map;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.TagKey;
+import org.apache.logging.log4j.Level;
+import org.bukkit.configuration.ConfigurationSection;
+import net.minecraft.world.entity.EntityType;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.List;
+import gg.pufferfish.pufferfish.flare.FlareCommand;
+import net.minecraft.server.MinecraftServer;
+import org.apache.logging.log4j.Level;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.MemoryConfiguration;
+import org.jetbrains.annotations.Nullable;
+import org.simpleyaml.configuration.comments.CommentType;
+import org.simpleyaml.configuration.file.YamlFile;
+import org.simpleyaml.exceptions.InvalidConfigurationException;
+import org.bukkit.command.SimpleCommandMap;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.List;
+import java.net.URI;
+import java.util.Collections;
+
+public class PufferfishConfig {
+	
+	private static final YamlFile config = new YamlFile();
+	private static int updates = 0;
+	
+	private static ConfigurationSection convertToBukkit(org.simpleyaml.configuration.ConfigurationSection section) {
+		ConfigurationSection newSection = new MemoryConfiguration();
+		for (String key : section.getKeys(false)) {
+			if (section.isConfigurationSection(key)) {
+				newSection.set(key, convertToBukkit(section.getConfigurationSection(key)));
+			} else {
+				newSection.set(key, section.get(key));
+			}
+		}
+		return newSection;
+	}
+	
+	public static ConfigurationSection getConfigCopy() {
+		return convertToBukkit(config);
+	}
+	
+	public static int getUpdates() {
+		return updates;
+	}
+	
+	public static void load() throws IOException {
+		File configFile = new File("pufferfish.yml");
+		
+		if (configFile.exists()) {
+			try {
+				config.load(configFile);
+			} catch (InvalidConfigurationException e) {
+				throw new IOException(e);
+			}
+		}
+		
+		getString("info.version", "1.0");
+		setComment("info",
+				"Pufferfish Configuration",
+				"Check out Pufferfish Host for maximum performance server hosting: https://pufferfish.host",
+				"Join our Discord for support: https://discord.gg/reZw4vQV9H",
+				"Download new builds at https://ci.pufferfish.host/job/Pufferfish");
+		
+		for (Method method : PufferfishConfig.class.getDeclaredMethods()) {
+			if (Modifier.isStatic(method.getModifiers()) && Modifier.isPrivate(method.getModifiers()) && method.getParameterCount() == 0 &&
+					method.getReturnType() == Void.TYPE && !method.getName().startsWith("lambda")) {
+				method.setAccessible(true);
+				try {
+					method.invoke(null);
+				} catch (Throwable t) {
+					MinecraftServer.LOGGER.warn("Failed to load configuration option from " + method.getName(), t);
+				}
+			}
+		}
+		
+		updates++;
+		
+		config.save(configFile);
+		
+		// Attempt to detect vectorization
+		try {
+			SIMDDetection.isEnabled = SIMDDetection.canEnable(PufferfishLogger.LOGGER);
+			SIMDDetection.versionLimited = SIMDDetection.getJavaVersion() < 17 || SIMDDetection.getJavaVersion() > 21;
+		} catch (NoClassDefFoundError | Exception ignored) {
+			ignored.printStackTrace();
+		}
+		
+		if (SIMDDetection.isEnabled) {
+			PufferfishLogger.LOGGER.info("SIMD operations detected as functional. Will replace some operations with faster versions.");
+		} else if (SIMDDetection.versionLimited) {
+			PufferfishLogger.LOGGER.warning("Will not enable SIMD! These optimizations are only safely supported on Java 17-21.");
+		} else {
+			PufferfishLogger.LOGGER.warning("SIMD operations are available for your server, but are not configured!");
+			PufferfishLogger.LOGGER.warning("To enable additional optimizations, add \"--add-modules=jdk.incubator.vector\" to your startup flags, BEFORE the \"-jar\".");
+			PufferfishLogger.LOGGER.warning("If you have already added this flag, then SIMD operations are not supported on your JVM or CPU.");
+			PufferfishLogger.LOGGER.warning("Debug: Java: " + System.getProperty("java.version") + ", test run: " + SIMDDetection.testRun);
+		}
+	}
+	
+	private static void setComment(String key, String... comment) {
+		if (config.contains(key)) {
+			config.setComment(key, String.join("\n", comment), CommentType.BLOCK);
+		}
+	}
+	
+	private static void ensureDefault(String key, Object defaultValue, String... comment) {
+		if (!config.contains(key)) {
+			config.set(key, defaultValue);
+			config.setComment(key, String.join("\n", comment), CommentType.BLOCK);
+		}
+	}
+	
+	private static boolean getBoolean(String key, boolean defaultValue, String... comment) {
+		return getBoolean(key, null, defaultValue, comment);
+	}
+	
+	private static boolean getBoolean(String key, @Nullable String oldKey, boolean defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getBoolean(key, defaultValue);
+	}
+	
+	private static int getInt(String key, int defaultValue, String... comment) {
+		return getInt(key, null, defaultValue, comment);
+	}
+	
+	private static int getInt(String key, @Nullable String oldKey, int defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getInt(key, defaultValue);
+	}
+	
+	private static double getDouble(String key, double defaultValue, String... comment) {
+		return getDouble(key, null, defaultValue, comment);
+	}
+	
+	private static double getDouble(String key, @Nullable String oldKey, double defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getDouble(key, defaultValue);
+	}
+	
+	private static String getString(String key, String defaultValue, String... comment) {
+		return getOldString(key, null, defaultValue, comment);
+	}
+	
+	private static String getOldString(String key, @Nullable String oldKey, String defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getString(key, defaultValue);
+	}
+	
+	private static List<String> getStringList(String key, List<String> defaultValue, String... comment) {
+		return getStringList(key, null, defaultValue, comment);
+	}
+	
+	private static List<String> getStringList(String key, @Nullable String oldKey, List<String> defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getStringList(key);
+	}
+	
+	public static String sentryDsn;
+	private static void sentry() {
+		String sentryEnvironment = System.getenv("SENTRY_DSN");
+		String sentryConfig = getString("sentry-dsn", "", "Sentry DSN for improved error logging, leave blank to disable", "Obtain from https://sentry.io/");
+		
+		sentryDsn = sentryEnvironment == null ? sentryConfig : sentryEnvironment;
+		if (sentryDsn != null && !sentryDsn.isBlank()) {
+			gg.pufferfish.pufferfish.sentry.SentryManager.init();
+		}
+	}
+	
+	public static boolean enableBooks;
+	private static void books() {
+		enableBooks = getBoolean("enable-books", true,
+				"Whether or not books should be writeable.",
+				"Servers that anticipate being a target for duping may want to consider",
+				"disabling this option.",
+				"This can be overridden per-player with the permission pufferfish.usebooks");
+	}
+
+	public static boolean tpsCatchup;
+	private static void tpsCatchup() {
+		tpsCatchup = getBoolean("tps-catchup", true,
+				"If this setting is true, the server will run faster after a lag spike in",
+				"an attempt to maintain 20 TPS. This option (defaults to true per",
+				"spigot/paper) can cause mobs to move fast after a lag spike.");
+	}
+	
+	public static boolean enableSuffocationOptimization;
+	private static void suffocationOptimization() {
+		enableSuffocationOptimization = getBoolean("enable-suffocation-optimization", true,
+				"Optimizes the suffocation check by selectively skipping",
+				"the check in a way that still appears vanilla. This should",
+				"be left enabled on most servers, but is provided as a",
+				"configuration option if the vanilla deviation is undesirable.");
+	}
+	
+	public static boolean enableAsyncMobSpawning;
+	public static boolean asyncMobSpawningInitialized;
+	private static void asyncMobSpawning() {
+		boolean temp = getBoolean("enable-async-mob-spawning", true,
+				"Whether or not asynchronous mob spawning should be enabled.",
+				"On servers with many entities, this can improve performance by up to 15%. You must have",
+				"paper's per-player-mob-spawns setting set to true for this to work.",
+				"One quick note - this does not actually spawn mobs async (that would be very unsafe).",
+				"This just offloads some expensive calculations that are required for mob spawning.");
+		
+		// This prevents us from changing the value during a reload.
+		if (!asyncMobSpawningInitialized) {
+			asyncMobSpawningInitialized = true;
+			enableAsyncMobSpawning = temp;
+		}
+	}
+	
+    public static int maxProjectileLoadsPerTick;
+    public static int maxProjectileLoadsPerProjectile;
+    private static void projectileLoading() {
+        maxProjectileLoadsPerTick = getInt("projectile.max-loads-per-tick", 10, "Controls how many chunks are allowed", "to be sync loaded by projectiles in a tick.");
+        maxProjectileLoadsPerProjectile = getInt("projectile.max-loads-per-projectile", 10, "Controls how many chunks a projectile", "can load in its lifetime before it gets", "automatically removed.");
+
+        setComment("projectile", "Optimizes projectile settings");
+    }
+
+
+    public static boolean dearEnabled;
+    public static int startDistance;
+    public static int startDistanceSquared;
+    public static int maximumActivationPrio;
+    public static int activationDistanceMod;
+
+    private static void dynamicActivationOfBrains() throws IOException {
+        dearEnabled = getBoolean("dab.enabled", "activation-range.enabled", true);
+        startDistance = getInt("dab.start-distance", "activation-range.start-distance", 12,
+                "This value determines how far away an entity has to be",
+                "from the player to start being effected by DEAR.");
+        startDistanceSquared = startDistance * startDistance;
+        maximumActivationPrio = getInt("dab.max-tick-freq", "activation-range.max-tick-freq", 20,
+                "This value defines how often in ticks, the furthest entity",
+                "will get their pathfinders and behaviors ticked. 20 = 1s");
+        activationDistanceMod = getInt("dab.activation-dist-mod", "activation-range.activation-dist-mod", 8,
+                "This value defines how much distance modifies an entity's",
+                "tick frequency. freq = (distanceToPlayer^2) / (2^value)",
+                "If you want further away entities to tick less often, use 7.",
+                "If you want further away entities to tick more often, try 9.");
+
+        for (EntityType<?> entityType : BuiltInRegistries.ENTITY_TYPE) {
+            entityType.dabEnabled = true; // reset all, before setting the ones to true
+        }
+        getStringList("dab.blacklisted-entities", "activation-range.blacklisted-entities", Collections.emptyList(), "A list of entities to ignore for activation")
+                .forEach(name -> EntityType.byString(name).ifPresentOrElse(entityType -> {
+                    entityType.dabEnabled = false;
+                }, () -> MinecraftServer.LOGGER.warn("Unknown entity \"" + name + "\"")));
+
+        setComment("dab", "Optimizes entity brains when", "they're far away from the player");
+    }
+	
+	public static Map<String, Integer> projectileTimeouts;
+	private static void projectileTimeouts() {
+		// Set some defaults
+		getInt("entity_timeouts.SNOWBALL", -1);
+		getInt("entity_timeouts.LLAMA_SPIT", -1);
+		setComment("entity_timeouts",
+				"These values define a entity's maximum lifespan. If an",
+				"entity is in this list and it has survived for longer than",
+				"that number of ticks, then it will be removed. Setting a value to",
+				"-1 disables this feature.");
+		
+		for (EntityType<?> entityType : BuiltInRegistries.ENTITY_TYPE) {
+			String type = EntityType.getKey(entityType).getPath().toUpperCase(Locale.ROOT);
+			entityType.ttl = config.getInt("entity_timeouts." + type, -1);
+		}
+	}
+    
+    public static boolean throttleInactiveGoalSelectorTick;
+	private static void inactiveGoalSelectorThrottle() {
+		throttleInactiveGoalSelectorTick = getBoolean("inactive-goal-selector-throttle", "inactive-goal-selector-disable", true,
+				"Throttles the AI goal selector in entity inactive ticks.",
+				"This can improve performance by a few percent, but has minor gameplay implications.");
+	}
+
+	public static boolean allowEndCrystalRespawn;
+	private static void allowEndCrystalRespawn() {
+		allowEndCrystalRespawn = getBoolean("allow-end-crystal-respawn", true,
+				"Allows end crystals to respawn the ender dragon.",
+				"On servers that expect end crystal fights in the end dimension, disabling this",
+				"will prevent the server from performing an expensive search to attempt respawning",
+				"the ender dragon whenever a player places an end crystal.");
+	}
+
+    public static URI profileWebUrl;
+    private static void profilerOptions() {
+        profileWebUrl = URI.create(getString("flare.url", "https://flare.airplane.gg", "Sets the server to use for profiles."));
+
+        setComment("flare", "Configures Flare, the built-in profiler");
+    }
+
+
+    public static String accessToken;
+    private static void airplaneWebServices() {
+        accessToken = getString("web-services.token", "");
+        // todo lookup token (off-thread) and let users know if their token is valid
+        if (accessToken.length() > 0) {
+            gg.pufferfish.pufferfish.flare.FlareSetup.init(); // Pufferfish
+            SimpleCommandMap commandMap = MinecraftServer.getServer().server.getCommandMap();
+            if (commandMap.getCommand("flare") == null) {
+                commandMap.register("flare", "Pufferfish", new FlareCommand());
+            }
+        }
+
+        setComment("web-services", "Options for connecting to Pufferfish/Airplane's online utilities");
+
+    }
+
+
+    public static boolean disableMethodProfiler;
+    private static void miscSettings() {
+        disableMethodProfiler = getBoolean("misc.disable-method-profiler", true);
+        setComment("misc", "Settings for things that don't belong elsewhere");
+    }
+
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/PufferfishLogger.java b/src/main/java/gg/pufferfish/pufferfish/PufferfishLogger.java
new file mode 100644
index 0000000000000000000000000000000000000000..53f2df00c6809618a9ee3d2ea72e85e8052fbcf1
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/PufferfishLogger.java
@@ -0,0 +1,16 @@
+package gg.pufferfish.pufferfish;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.bukkit.Bukkit;
+
+public class PufferfishLogger extends Logger {
+    public static final PufferfishLogger LOGGER = new PufferfishLogger();
+
+    private PufferfishLogger() {
+        super("Pufferfish", null);
+
+        setParent(Bukkit.getLogger());
+        setLevel(Level.ALL);
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/PufferfishVersionFetcher.java b/src/main/java/gg/pufferfish/pufferfish/PufferfishVersionFetcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..06323dcc745aed16123980fc559d7b65c42f1e1c
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/PufferfishVersionFetcher.java
@@ -0,0 +1,132 @@
+package gg.pufferfish.pufferfish;
+
+import com.destroystokyo.paper.VersionHistoryManager;
+import com.destroystokyo.paper.util.VersionFetcher;
+import com.google.gson.Gson;
+import com.google.gson.JsonObject;
+import io.papermc.paper.ServerBuildInfo;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.JoinConfiguration;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextDecoration;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.http.HttpClient;
+import java.net.http.HttpRequest;
+import java.net.http.HttpResponse;
+import java.nio.charset.StandardCharsets;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.GREEN;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+public class PufferfishVersionFetcher implements VersionFetcher {
+	
+	private static final Logger LOGGER = Logger.getLogger("PufferfishVersionFetcher");
+	private static final HttpClient client = HttpClient.newHttpClient();
+	
+	private static final URI JENKINS_URI = URI.create("https://ci.pufferfish.host/job/Pufferfish-1.21/lastSuccessfulBuild/buildNumber");
+	private static final String GITHUB_FORMAT = "https://api.github.com/repos/pufferfish-gg/Pufferfish/compare/ver/1.21...%s";
+	
+	private static final HttpResponse.BodyHandler<JsonObject> JSON_OBJECT_BODY_HANDLER = responseInfo -> HttpResponse.BodySubscribers
+			.mapping(
+					HttpResponse.BodySubscribers.ofString(StandardCharsets.UTF_8),
+					string -> new Gson().fromJson(string, JsonObject.class)
+			);
+	
+	@Override
+	public long getCacheTime() {
+		return TimeUnit.MINUTES.toMillis(30);
+	}
+	
+	@Override
+	public @NotNull Component getVersionMessage(final @NotNull String serverVersion) {
+		@NotNull Component component;
+
+		if (ServerBuildInfo.buildInfo().buildNumber().isPresent()) {
+			component = this.fetchJenkinsVersion(ServerBuildInfo.buildInfo().buildNumber().getAsInt());
+		} else if (ServerBuildInfo.buildInfo().gitCommit().isPresent()) {
+			component = this.fetchGithubVersion(ServerBuildInfo.buildInfo().gitCommit().get());
+		} else {
+			component = text("Unknown server version.", RED);
+		}
+
+		final @Nullable Component history = this.getHistory();
+		return history != null ? Component
+				.join(JoinConfiguration.noSeparators(), component, Component.newline(), this.getHistory()) : component;
+	}
+	
+	private @NotNull Component fetchJenkinsVersion(final int versionNumber) {
+		final HttpRequest request = HttpRequest.newBuilder(JENKINS_URI).build();
+		try {
+			final HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
+			if (response.statusCode() != 200) {
+				return text("Received invalid status code (" + response.statusCode() + ") from server.", RED);
+			}
+			
+			int latestVersionNumber;
+			try {
+				latestVersionNumber = Integer.parseInt(response.body());
+			} catch (NumberFormatException e) {
+				LOGGER.log(Level.WARNING, "Received invalid response from Jenkins \"" + response.body() + "\".");
+				return text("Received invalid response from server.", RED);
+			}
+			
+			final int versionDiff = latestVersionNumber - versionNumber;
+			return this.getResponseMessage(versionDiff);
+		} catch (IOException | InterruptedException e) {
+			LOGGER.log(Level.WARNING, "Failed to look up version from Jenkins", e);
+			return text("Failed to retrieve version from server.", RED);
+		}
+	}
+	
+	// Based off code contributed by Techcable <Techcable@outlook.com> in Paper/GH-65
+	private @NotNull Component fetchGithubVersion(final @NotNull String hash) {
+		final URI uri = URI.create(String.format(GITHUB_FORMAT, hash));
+		final HttpRequest request = HttpRequest.newBuilder(uri).build();
+		try {
+			final HttpResponse<JsonObject> response = client.send(request, JSON_OBJECT_BODY_HANDLER);
+			if (response.statusCode() != 200) {
+				return text("Received invalid status code (" + response.statusCode() + ") from server.", RED);
+			}
+			
+			final JsonObject obj = response.body();
+			final int versionDiff = obj.get("behind_by").getAsInt();
+			
+			return this.getResponseMessage(versionDiff);
+		} catch (IOException | InterruptedException e) {
+			LOGGER.log(Level.WARNING, "Failed to look up version from GitHub", e);
+			return text("Failed to retrieve version from server.", RED);
+		}
+	}
+	
+	private @NotNull Component getResponseMessage(final int versionDiff) {
+		return switch (Math.max(-1, Math.min(1, versionDiff))) {
+			case -1 -> text("You are running an unsupported version of Pufferfish.", RED);
+			case 0 -> text("You are on the latest version!", GREEN);
+			default -> text("You are running " + versionDiff + " version" + (versionDiff == 1 ? "" : "s") + " behind. " +
+							"Please update your server when possible to maintain stability and security, and to receive the latest optimizations.",
+					RED);
+		};
+	}
+	
+	private @Nullable Component getHistory() {
+		final VersionHistoryManager.VersionData data = VersionHistoryManager.INSTANCE.getVersionData();
+		if (data == null) {
+			return null;
+		}
+		
+		final String oldVersion = data.getOldVersion();
+		if (oldVersion == null) {
+			return null;
+		}
+		
+		return Component.text("Previous version: " + oldVersion, NamedTextColor.GRAY, TextDecoration.ITALIC);
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/gg/pufferfish/pufferfish/compat/ServerConfigurations.java b/src/main/java/gg/pufferfish/pufferfish/compat/ServerConfigurations.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ad189d52b27560424ddb311d0817a334637dc95
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/compat/ServerConfigurations.java
@@ -0,0 +1,78 @@
+package gg.pufferfish.pufferfish.compat;
+
+import co.aikar.timings.TimingsManager;
+import com.google.common.io.Files;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.stream.Collectors;
+
+public class ServerConfigurations {
+
+    public static final String[] configurationFiles = new String[]{
+      "server.properties",
+      "bukkit.yml",
+      "spigot.yml",
+      // "paper.yml", // TODO: Figure out what to do with this.
+      "pufferfish.yml"
+    };
+
+    public static Map<String, String> getCleanCopies() throws IOException {
+        Map<String, String> files = new HashMap<>(configurationFiles.length);
+        for (String file : configurationFiles) {
+            files.put(file, getCleanCopy(file));
+        }
+        return files;
+    }
+
+    public static String getCleanCopy(String configName) throws IOException {
+        File file = new File(configName);
+        List<String> hiddenConfigs = TimingsManager.hiddenConfigs;
+
+        switch (Files.getFileExtension(configName)) {
+            case "properties": {
+                Properties properties = new Properties();
+                try (FileInputStream inputStream = new FileInputStream(file)) {
+                    properties.load(inputStream);
+                }
+                for (String hiddenConfig : hiddenConfigs) {
+                    properties.remove(hiddenConfig);
+                }
+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+                properties.store(outputStream, "");
+                return Arrays.stream(outputStream.toString()
+                  .split("\n"))
+                  .filter(line -> !line.startsWith("#"))
+                  .collect(Collectors.joining("\n"));
+            }
+            case "yml": {
+                YamlConfiguration configuration = new YamlConfiguration();
+                try {
+                    configuration.load(file);
+                } catch (InvalidConfigurationException e) {
+                    throw new IOException(e);
+                }
+                configuration.options().header(null);
+                for (String key : configuration.getKeys(true)) {
+                    if (hiddenConfigs.contains(key)) {
+                        configuration.set(key, null);
+                    }
+                }
+                return configuration.saveToString();
+            }
+            default:
+                throw new IllegalArgumentException("Bad file type " + configName);
+        }
+    }
+
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/CustomCategories.java b/src/main/java/gg/pufferfish/pufferfish/flare/CustomCategories.java
new file mode 100644
index 0000000000000000000000000000000000000000..401b42e29bccb5251684062f10b2e0f8b091bc95
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/CustomCategories.java
@@ -0,0 +1,8 @@
+package gg.pufferfish.pufferfish.flare;
+
+import co.technove.flare.live.category.GraphCategory;
+
+public class CustomCategories {
+    public static final GraphCategory MC_PERF = new GraphCategory("MC Performance");
+    public static final GraphCategory ENTITIES_AND_CHUNKS = new GraphCategory("Entities & Chunks");
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/FlareCommand.java b/src/main/java/gg/pufferfish/pufferfish/flare/FlareCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..eec169b4e9eee504c8fe72f066f2d7efb7263bc4
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/FlareCommand.java
@@ -0,0 +1,136 @@
+package gg.pufferfish.pufferfish.flare;
+
+import co.technove.flare.exceptions.UserReportableException;
+import co.technove.flare.internal.profiling.ProfileType;
+import gg.pufferfish.pufferfish.PufferfishConfig;
+import io.papermc.paper.util.MCUtil;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.event.ClickEvent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.minecraft.server.MinecraftServer;
+import org.apache.logging.log4j.Level;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.util.StringUtil;
+import org.jetbrains.annotations.NotNull;
+
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class FlareCommand extends Command {
+
+    private static final String BASE_URL = "https://blog.airplane.gg/flare-tutorial/#setting-the-access-token";
+    private static final TextColor HEX = TextColor.fromHexString("#e3eaea");
+    private static final Component PREFIX = Component.text()
+      .append(Component.text("Flare â")
+        .color(TextColor.fromHexString("#6a7eda"))
+        .decoration(TextDecoration.BOLD, true)
+        .append(Component.text(" ", HEX)
+          .decoration(TextDecoration.BOLD, false)))
+      .asComponent();
+
+    public FlareCommand() {
+        super("flare", "Profile your server with Flare", "/flare", Collections.singletonList("profile"));
+        this.setPermission("airplane.flare");
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, String @NotNull [] args) {
+        if (!testPermission(sender)) return true;
+        if (PufferfishConfig.accessToken.length() == 0) {
+            Component clickable = Component.text(BASE_URL, HEX, TextDecoration.UNDERLINED).clickEvent(ClickEvent.clickEvent(ClickEvent.Action.OPEN_URL, BASE_URL));
+
+            sender.sendMessage(PREFIX.append(Component.text("Flare currently requires an access token to use. To learn more, visit ").color(HEX).append(clickable)));
+            return true;
+        }
+
+        if (!FlareSetup.isSupported()) {
+            sender.sendMessage(PREFIX.append(
+              Component.text("Profiling is not supported in this environment, check your startup logs for the error.", NamedTextColor.RED)));
+            return true;
+        }
+        if (ProfilingManager.isProfiling()) {
+            if (args.length == 1 && args[0].equalsIgnoreCase("status")) {
+                sender.sendMessage(PREFIX.append(Component.text("Current profile has been ran for " + ProfilingManager.getTimeRan().toString(), HEX)));
+                return true;
+            }
+            if (ProfilingManager.stop()) {
+                if (!(sender instanceof ConsoleCommandSender)) {
+                    sender.sendMessage(PREFIX.append(Component.text("Profiling has been stopped.", HEX)));
+                }
+            } else {
+                sender.sendMessage(PREFIX.append(Component.text("Profiling has already been stopped.", HEX)));
+            }
+        } else {
+            ProfileType profileType = ProfileType.ITIMER;
+            if (args.length > 0) {
+                try {
+                    profileType = ProfileType.valueOf(args[0].toUpperCase());
+                } catch (Exception e) {
+                    sender.sendMessage(PREFIX.append(Component
+                      .text("Invalid profile type ", HEX)
+                      .append(Component.text(args[0], HEX, TextDecoration.BOLD)
+                        .append(Component.text("!", HEX)))
+                    ));
+                }
+            }
+            ProfileType finalProfileType = profileType;
+            MCUtil.scheduleAsyncTask(() -> {
+                try {
+                    if (ProfilingManager.start(finalProfileType)) {
+                        if (!(sender instanceof ConsoleCommandSender)) {
+                            sender.sendMessage(PREFIX.append(Component
+                              .text("Flare has been started: " + ProfilingManager.getProfilingUri(), HEX)
+                              .clickEvent(ClickEvent.openUrl(ProfilingManager.getProfilingUri()))
+                            ));
+                            sender.sendMessage(PREFIX.append(Component.text("  Run /" + commandLabel + " to stop the Flare.", HEX)));
+                        }
+                    } else {
+                        sender.sendMessage(PREFIX.append(Component
+                          .text("Flare has already been started: " + ProfilingManager.getProfilingUri(), HEX)
+                          .clickEvent(ClickEvent.openUrl(ProfilingManager.getProfilingUri()))
+                        ));
+                    }
+                } catch (UserReportableException e) {
+                    sender.sendMessage(Component.text("Flare failed to start: " + e.getUserError(), NamedTextColor.RED));
+                    if (e.getCause() != null) {
+                        MinecraftServer.LOGGER.warn("Flare failed to start", e);
+                    }
+                }
+            });
+        }
+        return true;
+    }
+
+    @Override
+    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, String @NotNull [] args) throws IllegalArgumentException {
+        List<String> list = new ArrayList<>();
+        if (ProfilingManager.isProfiling()) {
+            if (args.length == 1) {
+                String lastWord = args[0];
+                if (StringUtil.startsWithIgnoreCase("status", lastWord)) {
+                    list.add("status");
+                }
+                if (StringUtil.startsWithIgnoreCase("stop", lastWord)) {
+                    list.add("stop");
+                }
+            }
+        } else {
+            if (args.length <= 1) {
+                String lastWord = args.length == 0 ? "" : args[0];
+                for (ProfileType value : ProfileType.values()) {
+                    if (StringUtil.startsWithIgnoreCase(value.getInternalName(), lastWord)) {
+                        list.add(value.name().toLowerCase());
+                    }
+                }
+            }
+        }
+        return list;
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/FlareSetup.java b/src/main/java/gg/pufferfish/pufferfish/flare/FlareSetup.java
new file mode 100644
index 0000000000000000000000000000000000000000..cd22e4dcc8b7b57b10a95ef084637249a98e524f
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/FlareSetup.java
@@ -0,0 +1,33 @@
+package gg.pufferfish.pufferfish.flare;
+
+import co.technove.flare.FlareInitializer;
+import co.technove.flare.internal.profiling.InitializationException;
+import net.minecraft.server.MinecraftServer;
+import org.apache.logging.log4j.Level;
+
+public class FlareSetup {
+
+    private static boolean initialized = false;
+    private static boolean supported = false;
+
+    public static void init() {
+        if (initialized) {
+            return;
+        }
+
+        initialized = true;
+        try {
+            for (String warning : FlareInitializer.initialize()) {
+                MinecraftServer.LOGGER.warn("Flare warning: " + warning);
+            }
+            supported = true;
+        } catch (InitializationException e) {
+            MinecraftServer.LOGGER.warn("Failed to enable Flare:", e);
+        }
+    }
+
+    public static boolean isSupported() {
+        return supported;
+    }
+
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/PluginLookup.java b/src/main/java/gg/pufferfish/pufferfish/flare/PluginLookup.java
new file mode 100644
index 0000000000000000000000000000000000000000..74aab5eb4b54ffbaf19b8976ffb8ca4a64584006
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/PluginLookup.java
@@ -0,0 +1,44 @@
+package gg.pufferfish.pufferfish.flare;
+
+import com.google.common.cache.Cache;
+import com.google.common.cache.CacheBuilder;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.PluginClassLoader;
+
+import java.util.Optional;
+import java.util.concurrent.TimeUnit;
+
+public class PluginLookup {
+    private static final Cache<String, String> pluginNameCache = CacheBuilder.newBuilder()
+      .expireAfterAccess(1, TimeUnit.MINUTES)
+      .maximumSize(1024)
+      .build();
+
+    public static Optional<String> getPluginForClass(String name) {
+        if (name.startsWith("net.minecraft") || name.startsWith("java.") || name.startsWith("com.mojang") ||
+          name.startsWith("com.google") || name.startsWith("it.unimi") || name.startsWith("sun")) {
+            return Optional.empty();
+        }
+
+        String existing = pluginNameCache.getIfPresent(name);
+        if (existing != null) {
+            return Optional.ofNullable(existing.isEmpty() ? null : existing);
+        }
+
+        String newValue = "";
+
+        for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
+            ClassLoader classLoader = plugin.getClass().getClassLoader();
+            if (classLoader instanceof PluginClassLoader) {
+                if (((PluginClassLoader) classLoader)._airplane_hasClass(name)) {
+                    newValue = plugin.getName();
+                    break;
+                }
+            }
+        }
+
+        pluginNameCache.put(name, newValue);
+        return Optional.ofNullable(newValue.isEmpty() ? null : newValue);
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/ProfilingManager.java b/src/main/java/gg/pufferfish/pufferfish/flare/ProfilingManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..57cf697b0916a3b0ac0232422a5a4ba423427dc3
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/ProfilingManager.java
@@ -0,0 +1,154 @@
+package gg.pufferfish.pufferfish.flare;
+
+import co.technove.flare.Flare;
+import co.technove.flare.FlareAuth;
+import co.technove.flare.FlareBuilder;
+import co.technove.flare.exceptions.UserReportableException;
+import co.technove.flare.internal.profiling.ProfileType;
+import gg.pufferfish.pufferfish.PufferfishConfig;
+import gg.pufferfish.pufferfish.PufferfishLogger;
+import gg.pufferfish.pufferfish.compat.ServerConfigurations;
+import gg.pufferfish.pufferfish.flare.collectors.GCEventCollector;
+import gg.pufferfish.pufferfish.flare.collectors.StatCollector;
+import gg.pufferfish.pufferfish.flare.collectors.TPSCollector;
+import gg.pufferfish.pufferfish.flare.collectors.WorldCountCollector;
+import org.bukkit.Bukkit;
+import oshi.SystemInfo;
+import oshi.hardware.CentralProcessor;
+import oshi.hardware.GlobalMemory;
+import oshi.hardware.HardwareAbstractionLayer;
+import oshi.hardware.VirtualMemory;
+import oshi.software.os.OperatingSystem;
+
+import java.io.IOException;
+import java.net.URI;
+import java.time.Duration;
+import java.util.Objects;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+
+public class ProfilingManager {
+
+    private static Flare currentFlare;
+    private static ScheduledFuture<?> currentTask = null;
+    private static ScheduledExecutorService ses = new ScheduledThreadPoolExecutor(1);
+
+    public static synchronized boolean isProfiling() {
+        return currentFlare != null && currentFlare.isRunning();
+    }
+
+    public static synchronized String getProfilingUri() {
+        return Objects.requireNonNull(currentFlare).getURI().map(URI::toString).orElse("Flare is not running");
+    }
+
+    public static Duration getTimeRan() {
+        Flare flare = currentFlare; // copy reference so no need to sync
+        if (flare == null) {
+            return Duration.ofMillis(0);
+        }
+        return flare.getCurrentDuration();
+    }
+
+    public static synchronized boolean start(ProfileType profileType) throws UserReportableException {
+        if (currentFlare != null && !currentFlare.isRunning()) {
+            currentFlare = null; // errored out
+        }
+        if (isProfiling()) {
+            return false;
+        }
+        if (Bukkit.isPrimaryThread()) {
+            throw new UserReportableException("Profiles should be started off-thread");
+        }
+
+        try {
+            OperatingSystem os = new SystemInfo().getOperatingSystem();
+
+            SystemInfo systemInfo = new SystemInfo();
+            HardwareAbstractionLayer hardware = systemInfo.getHardware();
+
+            CentralProcessor processor = hardware.getProcessor();
+            CentralProcessor.ProcessorIdentifier processorIdentifier = processor.getProcessorIdentifier();
+
+            GlobalMemory memory = hardware.getMemory();
+            VirtualMemory virtualMemory = memory.getVirtualMemory();
+
+            FlareBuilder builder = new FlareBuilder()
+                    .withProfileType(profileType)
+                    .withMemoryProfiling(true)
+                    .withAuth(FlareAuth.fromTokenAndUrl(PufferfishConfig.accessToken, PufferfishConfig.profileWebUrl))
+
+                    .withFiles(ServerConfigurations.getCleanCopies())
+                    .withVersion("Primary Version", Bukkit.getVersion())
+                    .withVersion("Bukkit Version", Bukkit.getBukkitVersion())
+                    .withVersion("Minecraft Version", Bukkit.getMinecraftVersion())
+
+                    .withGraphCategories(CustomCategories.ENTITIES_AND_CHUNKS, CustomCategories.MC_PERF)
+                    .withCollectors(new TPSCollector(), new WorldCountCollector(), new GCEventCollector(), new StatCollector())
+                    .withClassIdentifier(PluginLookup::getPluginForClass)
+
+                    .withHardware(new FlareBuilder.HardwareBuilder()
+                            .setCoreCount(processor.getPhysicalProcessorCount())
+                            .setThreadCount(processor.getLogicalProcessorCount())
+                            .setCpuModel(processorIdentifier.getName())
+                            .setCpuFrequency(processor.getMaxFreq())
+
+                            .setTotalMemory(memory.getTotal())
+                            .setTotalSwap(virtualMemory.getSwapTotal())
+                            .setTotalVirtual(virtualMemory.getVirtualMax())
+                    )
+
+                    .withOperatingSystem(new FlareBuilder.OperatingSystemBuilder()
+                            .setManufacturer(os.getManufacturer())
+                            .setFamily(os.getFamily())
+                            .setVersion(os.getVersionInfo().toString())
+                            .setBitness(os.getBitness())
+                    );
+
+            currentFlare = builder.build();
+        } catch (IOException e) {
+            PufferfishLogger.LOGGER.log(Level.WARNING, "Failed to read configuration files:", e);
+            throw new UserReportableException("Failed to load configuration files, check logs for further details.");
+        }
+
+        try {
+            currentFlare.start();
+        } catch (IllegalStateException e) {
+            PufferfishLogger.LOGGER.log(Level.WARNING, "Error starting Flare:", e);
+            throw new UserReportableException("Failed to start Flare, check logs for further details.");
+        }
+
+        currentTask = ses.schedule(ProfilingManager::stop, 15, TimeUnit.MINUTES);
+        PufferfishLogger.LOGGER.log(Level.INFO, "Flare has been started: " + getProfilingUri());
+        return true;
+    }
+
+    public static synchronized boolean stop() {
+        if (!isProfiling()) {
+            return false;
+        }
+        if (!currentFlare.isRunning()) {
+            currentFlare = null;
+            return true;
+        }
+        PufferfishLogger.LOGGER.log(Level.INFO, "Flare has been stopped: " + getProfilingUri());
+        try {
+            currentFlare.stop();
+        } catch (IllegalStateException e) {
+            PufferfishLogger.LOGGER.log(Level.WARNING, "Error occurred stopping Flare", e);
+        }
+        currentFlare = null;
+
+        try {
+            currentTask.cancel(true);
+        } catch (Throwable t) {
+            PufferfishLogger.LOGGER.log(Level.WARNING, "Error occurred stopping Flare", t);
+        }
+
+        currentTask = null;
+        return true;
+    }
+
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/collectors/GCEventCollector.java b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/GCEventCollector.java
new file mode 100644
index 0000000000000000000000000000000000000000..d426575c669020f369960107da1e2de2f11f082f
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/GCEventCollector.java
@@ -0,0 +1,66 @@
+package gg.pufferfish.pufferfish.flare.collectors;
+
+import co.technove.flare.Flare;
+import co.technove.flare.internal.FlareInternal;
+import co.technove.flare.live.CollectorData;
+import co.technove.flare.live.EventCollector;
+import co.technove.flare.live.LiveEvent;
+import co.technove.flare.live.category.GraphCategory;
+import co.technove.flare.live.formatter.DataFormatter;
+import com.google.common.collect.ImmutableMap;
+import com.sun.management.GarbageCollectionNotificationInfo;
+
+import javax.management.ListenerNotFoundException;
+import javax.management.Notification;
+import javax.management.NotificationEmitter;
+import javax.management.NotificationListener;
+import javax.management.openmbean.CompositeData;
+import java.lang.management.GarbageCollectorMXBean;
+import java.lang.management.ManagementFactory;
+
+public class GCEventCollector extends EventCollector implements NotificationListener {
+
+    private static final CollectorData MINOR_GC = new CollectorData("builtin:gc:minor", "Minor GC", "A small pause in the program to allow Garbage Collection to run.", DataFormatter.MILLISECONDS, GraphCategory.SYSTEM);
+    private static final CollectorData MAJOR_GC = new CollectorData("builtin:gc:major", "Major GC", "A large pause in the program to allow Garbage Collection to run.", DataFormatter.MILLISECONDS, GraphCategory.SYSTEM);
+    private static final CollectorData UNKNOWN_GC = new CollectorData("builtin:gc:generic", "Major GC", "A run of the Garbage Collection.", DataFormatter.MILLISECONDS, GraphCategory.SYSTEM);
+
+    public GCEventCollector() {
+        super(MINOR_GC, MAJOR_GC, UNKNOWN_GC);
+    }
+
+    private static CollectorData fromString(String string) {
+        if (string.endsWith("minor GC")) {
+            return MINOR_GC;
+        } else if (string.endsWith("major GC")) {
+            return MAJOR_GC;
+        }
+        return UNKNOWN_GC;
+    }
+
+    @Override
+    public void start(Flare flare) {
+        for (GarbageCollectorMXBean garbageCollectorBean : ManagementFactory.getGarbageCollectorMXBeans()) {
+            NotificationEmitter notificationEmitter = (NotificationEmitter) garbageCollectorBean;
+            notificationEmitter.addNotificationListener(this, null, null);
+        }
+    }
+
+    @Override
+    public void stop(Flare flare) {
+        for (GarbageCollectorMXBean garbageCollectorBean : ManagementFactory.getGarbageCollectorMXBeans()) {
+            NotificationEmitter notificationEmitter = (NotificationEmitter) garbageCollectorBean;
+            try {
+                notificationEmitter.removeNotificationListener(this);
+            } catch (ListenerNotFoundException e) {
+            }
+        }
+    }
+
+    @Override
+    public void handleNotification(Notification notification, Object o) {
+        if (notification.getType().equals(GarbageCollectionNotificationInfo.GARBAGE_COLLECTION_NOTIFICATION)) {
+            GarbageCollectionNotificationInfo gcInfo = GarbageCollectionNotificationInfo.from((CompositeData) notification.getUserData());
+            reportEvent(new LiveEvent(fromString(gcInfo.getGcAction()), System.currentTimeMillis(), (int) gcInfo.getGcInfo().getDuration(), ImmutableMap.of()));
+        }
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/collectors/StatCollector.java b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/StatCollector.java
new file mode 100644
index 0000000000000000000000000000000000000000..a22c6dbae53667e4c72464fa27153aee30c7946e
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/StatCollector.java
@@ -0,0 +1,41 @@
+package gg.pufferfish.pufferfish.flare.collectors;
+
+import co.technove.flare.live.CollectorData;
+import co.technove.flare.live.LiveCollector;
+import co.technove.flare.live.category.GraphCategory;
+import co.technove.flare.live.formatter.DataFormatter;
+import com.sun.management.OperatingSystemMXBean;
+import oshi.SystemInfo;
+import oshi.hardware.CentralProcessor;
+
+import java.lang.management.ManagementFactory;
+import java.time.Duration;
+
+public class StatCollector extends LiveCollector {
+
+    private static final CollectorData CPU = new CollectorData("builtin:stat:cpu", "CPU Load", "The total amount of CPU usage across all cores.", DataFormatter.PERCENT, GraphCategory.SYSTEM);
+    private static final CollectorData CPU_PROCESS = new CollectorData("builtin:stat:cpu_process", "Process CPU", "The amount of CPU being used by this process.", DataFormatter.PERCENT, GraphCategory.SYSTEM);
+    private static final CollectorData MEMORY = new CollectorData("builtin:stat:memory_used", "Memory", "The amount of memory being used currently.", DataFormatter.BYTES, GraphCategory.SYSTEM);
+    private static final CollectorData MEMORY_TOTAL = new CollectorData("builtin:stat:memory_total", "Memory Total", "The total amount of memory allocated.", DataFormatter.BYTES, GraphCategory.SYSTEM);
+
+    private final OperatingSystemMXBean bean;
+    private final CentralProcessor processor;
+
+    public StatCollector() {
+        super(CPU, CPU_PROCESS, MEMORY, MEMORY_TOTAL);
+        this.interval = Duration.ofSeconds(5);
+
+        this.bean = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();
+        this.processor = new SystemInfo().getHardware().getProcessor();
+    }
+
+    @Override
+    public void run() {
+        Runtime runtime = Runtime.getRuntime();
+
+        this.report(CPU, this.processor.getSystemLoadAverage(1)[0] / 100); // percentage
+        this.report(CPU_PROCESS, this.bean.getProcessCpuLoad());
+        this.report(MEMORY, runtime.totalMemory() - runtime.freeMemory());
+        this.report(MEMORY_TOTAL, runtime.totalMemory());
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/collectors/TPSCollector.java b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/TPSCollector.java
new file mode 100644
index 0000000000000000000000000000000000000000..40447d00aefb5ffedb8a2ee87155a04088f0649f
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/TPSCollector.java
@@ -0,0 +1,31 @@
+package gg.pufferfish.pufferfish.flare.collectors;
+
+import co.technove.flare.live.CollectorData;
+import co.technove.flare.live.LiveCollector;
+import co.technove.flare.live.formatter.SuffixFormatter;
+import gg.pufferfish.pufferfish.flare.CustomCategories;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+
+import java.time.Duration;
+import java.util.Arrays;
+
+public class TPSCollector extends LiveCollector {
+    private static final CollectorData TPS = new CollectorData("airplane:tps", "TPS", "Ticks per second, or how fast the server updates. For a smooth server this should be a constant 20TPS.", SuffixFormatter.of("TPS"), CustomCategories.MC_PERF);
+    private static final CollectorData MSPT = new CollectorData("airplane:mspt", "MSPT", "Milliseconds per tick, which can show how well your server is performing. This value should always be under 50mspt.", SuffixFormatter.of("mspt"), CustomCategories.MC_PERF);
+
+    public TPSCollector() {
+        super(TPS, MSPT);
+
+        this.interval = Duration.ofSeconds(5);
+    }
+
+    @Override
+    public void run() {
+        long[] times = MinecraftServer.getServer().tickTimes5s.getTimes();
+        double mspt = ((double) Arrays.stream(times).sum() / (double) times.length) * 1.0E-6D;
+
+        this.report(TPS, Math.min(20D, Math.round(Bukkit.getServer().getTPS()[0] * 100d) / 100d));
+        this.report(MSPT, (double) Math.round(mspt * 100d) / 100d);
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/collectors/WorldCountCollector.java b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/WorldCountCollector.java
new file mode 100644
index 0000000000000000000000000000000000000000..029d840e28d67d26d3c0dd6785e25dbf15f9226c
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/WorldCountCollector.java
@@ -0,0 +1,45 @@
+package gg.pufferfish.pufferfish.flare.collectors;
+
+import co.technove.flare.live.CollectorData;
+import co.technove.flare.live.LiveCollector;
+import co.technove.flare.live.formatter.SuffixFormatter;
+import gg.pufferfish.pufferfish.flare.CustomCategories;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+
+import java.time.Duration;
+
+public class WorldCountCollector extends LiveCollector {
+
+    private static final CollectorData PLAYER_COUNT = new CollectorData("airplane:world:playercount", "Player Count", "The number of players currently on the server.", new SuffixFormatter(" Player", " Players"), CustomCategories.ENTITIES_AND_CHUNKS);
+    private static final CollectorData ENTITY_COUNT = new CollectorData("airplane:world:entitycount", "Entity Count", "The number of entities in all worlds", new SuffixFormatter(" Entity", " Entities"), CustomCategories.ENTITIES_AND_CHUNKS);
+    private static final CollectorData CHUNK_COUNT = new CollectorData("airplane:world:chunkcount", "Chunk Count", "The number of chunks currently loaded.", new SuffixFormatter(" Chunk", " Chunks"), CustomCategories.ENTITIES_AND_CHUNKS);
+    private static final CollectorData TILE_ENTITY_COUNT = new CollectorData("airplane:world:blockentitycount", "Block Entity Count", "The number of block entities currently loaded.", new SuffixFormatter(" Block Entity", " Block Entities"), CustomCategories.ENTITIES_AND_CHUNKS);
+
+    public WorldCountCollector() {
+        super(PLAYER_COUNT, ENTITY_COUNT, CHUNK_COUNT, TILE_ENTITY_COUNT);
+
+        this.interval = Duration.ofSeconds(5);
+    }
+
+    @Override
+    public void run() {
+        if (true) return; // This doesn't work, and it's not worth fixing at the moment.
+        int entities = 0;
+        int chunkCount = 0;
+        int tileEntityCount = 0;
+
+        if (!Bukkit.isStopping()) {
+            for (World world : Bukkit.getWorlds()) {
+                world.getEntityCount();
+                chunkCount += world.getChunkCount();
+                tileEntityCount += world.getTileEntityCount();
+            }
+        }
+
+        this.report(PLAYER_COUNT, Bukkit.getOnlinePlayers().size());
+        this.report(ENTITY_COUNT, entities);
+        this.report(CHUNK_COUNT, chunkCount);
+        this.report(TILE_ENTITY_COUNT, tileEntityCount);
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/sentry/PufferfishSentryAppender.java b/src/main/java/gg/pufferfish/pufferfish/sentry/PufferfishSentryAppender.java
new file mode 100644
index 0000000000000000000000000000000000000000..731ef11c7a025ae95ed8a757b530d834733d0621
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/sentry/PufferfishSentryAppender.java
@@ -0,0 +1,135 @@
+package gg.pufferfish.pufferfish.sentry;
+
+import com.google.common.reflect.TypeToken;
+import com.google.gson.Gson;
+import io.sentry.Breadcrumb;
+import io.sentry.Sentry;
+import io.sentry.SentryEvent;
+import io.sentry.SentryLevel;
+import io.sentry.protocol.Message;
+import io.sentry.protocol.User;
+import java.util.Map;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Marker;
+import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.core.Logger;
+import org.apache.logging.log4j.core.appender.AbstractAppender;
+import org.apache.logging.log4j.core.filter.AbstractFilter;
+
+public class PufferfishSentryAppender extends AbstractAppender {
+	
+	private static final org.apache.logging.log4j.Logger logger = LogManager.getLogger(PufferfishSentryAppender.class);
+	private static final Gson GSON = new Gson();
+	
+	public PufferfishSentryAppender() {
+		super("PufferfishSentryAdapter", new SentryFilter(), null);
+	}
+	
+	@Override
+	public void append(LogEvent logEvent) {
+		if (logEvent.getThrown() != null && logEvent.getLevel().isMoreSpecificThan(Level.WARN)) {
+			try {
+				logException(logEvent);
+			} catch (Exception e) {
+				logger.warn("Failed to log event with sentry", e);
+			}
+		} else {
+			try {
+				logBreadcrumb(logEvent);
+			} catch (Exception e) {
+				logger.warn("Failed to log event with sentry", e);
+			}
+		}
+	}
+	
+	private void logException(LogEvent e) {
+		SentryEvent event = new SentryEvent(e.getThrown());
+		
+		Message sentryMessage = new Message();
+		sentryMessage.setMessage(e.getMessage().getFormattedMessage());
+		
+		event.setThrowable(e.getThrown());
+		event.setLevel(getLevel(e.getLevel()));
+		event.setLogger(e.getLoggerName());
+		event.setTransaction(e.getLoggerName());
+		event.setExtra("thread_name", e.getThreadName());
+		
+		boolean hasContext = e.getContextData() != null;
+		
+		if (hasContext && e.getContextData().containsKey("pufferfishsentry_playerid")) {
+			User user = new User();
+			user.setId(e.getContextData().getValue("pufferfishsentry_playerid"));
+			user.setUsername(e.getContextData().getValue("pufferfishsentry_playername"));
+			event.setUser(user);
+		}
+		
+		if (hasContext && e.getContextData().containsKey("pufferfishsentry_pluginname")) {
+			event.setExtra("plugin.name", e.getContextData().getValue("pufferfishsentry_pluginname"));
+			event.setExtra("plugin.version", e.getContextData().getValue("pufferfishsentry_pluginversion"));
+			event.setTransaction(e.getContextData().getValue("pufferfishsentry_pluginname"));
+		}
+		
+		if (hasContext && e.getContextData().containsKey("pufferfishsentry_eventdata")) {
+			Map<String, String> eventFields = GSON.fromJson((String) e.getContextData().getValue("pufferfishsentry_eventdata"), new TypeToken<Map<String, String>>() {}.getType());
+			if (eventFields != null) {
+				event.setExtra("event", eventFields);
+			}
+		}
+		
+		Sentry.captureEvent(event);
+	}
+	
+	private void logBreadcrumb(LogEvent e) {
+		Breadcrumb breadcrumb = new Breadcrumb();
+		
+		breadcrumb.setLevel(getLevel(e.getLevel()));
+		breadcrumb.setCategory(e.getLoggerName());
+		breadcrumb.setType(e.getLoggerName());
+		breadcrumb.setMessage(e.getMessage().getFormattedMessage());
+		
+		Sentry.addBreadcrumb(breadcrumb);
+	}
+	
+	private SentryLevel getLevel(Level level) {
+		switch (level.getStandardLevel()) {
+			case TRACE:
+			case DEBUG:
+				return SentryLevel.DEBUG;
+			case WARN:
+				return SentryLevel.WARNING;
+			case ERROR:
+				return SentryLevel.ERROR;
+			case FATAL:
+				return SentryLevel.FATAL;
+			case INFO:
+			default:
+				return SentryLevel.INFO;
+		}
+	}
+	
+	private static class SentryFilter extends AbstractFilter {
+		
+		@Override
+		public Result filter(Logger logger, org.apache.logging.log4j.Level level, Marker marker, String msg,
+				Object... params) {
+			return this.filter(logger.getName());
+		}
+		
+		@Override
+		public Result filter(Logger logger, org.apache.logging.log4j.Level level, Marker marker, Object msg, Throwable t) {
+			return this.filter(logger.getName());
+		}
+		
+		@Override
+		public Result filter(LogEvent event) {
+			return this.filter(event == null ? null : event.getLoggerName());
+		}
+		
+		private Result filter(String loggerName) {
+			return loggerName != null && loggerName.startsWith("gg.castaway.pufferfish.sentry") ? Result.DENY
+					: Result.NEUTRAL;
+		}
+		
+	}
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/sentry/SentryManager.java b/src/main/java/gg/pufferfish/pufferfish/sentry/SentryManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b29210ad0bbb4ada150f23357f0c80d331c996d
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/sentry/SentryManager.java
@@ -0,0 +1,40 @@
+package gg.pufferfish.pufferfish.sentry;
+
+import gg.pufferfish.pufferfish.PufferfishConfig;
+import io.sentry.Sentry;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class SentryManager {
+	
+	private static final Logger logger = LogManager.getLogger(SentryManager.class);
+	
+	private SentryManager() {
+	
+	}
+	
+	private static boolean initialized = false;
+	
+	public static synchronized void init() {
+		if (initialized) {
+			return;
+		}
+		try {
+			initialized = true;
+			
+			Sentry.init(options -> {
+				options.setDsn(PufferfishConfig.sentryDsn);
+				options.setMaxBreadcrumbs(100);
+			});
+			
+			PufferfishSentryAppender appender = new PufferfishSentryAppender();
+			appender.start();
+			((org.apache.logging.log4j.core.Logger) LogManager.getRootLogger()).addAppender(appender);
+			logger.info("Sentry logging started!");
+		} catch (Exception e) {
+			logger.warn("Failed to initialize sentry!", e);
+			initialized = false;
+		}
+	}
+	
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/util/AsyncExecutor.java b/src/main/java/gg/pufferfish/pufferfish/util/AsyncExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e5323d5d9af25c8a85c4b34a6be76cfc54384cf
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/util/AsyncExecutor.java
@@ -0,0 +1,73 @@
+package gg.pufferfish.pufferfish.util;
+
+import com.google.common.collect.Queues;
+import gg.pufferfish.pufferfish.PufferfishLogger;
+import java.util.Queue;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.logging.Level;
+
+public class AsyncExecutor implements Runnable {
+	
+	private final Queue<Runnable> jobs = Queues.newArrayDeque();
+	private final Lock mutex = new ReentrantLock();
+	private final Condition cond = mutex.newCondition();
+	private final Thread thread;
+	private volatile boolean killswitch = false;
+	
+	public AsyncExecutor(String threadName) {
+		this.thread = new Thread(this, threadName);
+	}
+	
+	public void start() {
+		thread.start();
+	}
+	
+	public void kill() {
+		killswitch = true;
+		cond.signalAll();
+	}
+	
+	public void submit(Runnable runnable) {
+		mutex.lock();
+		try {
+			jobs.offer(runnable);
+			cond.signalAll();
+		} finally {
+			mutex.unlock();
+		}
+	}
+	
+	@Override
+	public void run() {
+		while (!killswitch) {
+			try {
+				Runnable runnable = takeRunnable();
+				if (runnable != null) {
+					runnable.run();
+				}
+			} catch (InterruptedException e) {
+				Thread.currentThread().interrupt();
+			} catch (Exception e) {
+				PufferfishLogger.LOGGER.log(Level.SEVERE, e, () -> "Failed to execute async job for thread " + thread.getName());
+			}
+		}
+	}
+	
+	private Runnable takeRunnable() throws InterruptedException {
+		mutex.lock();
+		try {
+			while (jobs.isEmpty() && !killswitch) {
+				cond.await();
+			}
+			
+			if (jobs.isEmpty()) return null; // We've set killswitch
+			
+			return jobs.remove();
+		} finally {
+			mutex.unlock();
+		}
+	}
+	
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/util/AsyncPlayerAreaMap.java b/src/main/java/gg/pufferfish/pufferfish/util/AsyncPlayerAreaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..fdcb62d12164024a5f354d60cc863821a18d1b2a
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/util/AsyncPlayerAreaMap.java
@@ -0,0 +1,31 @@
+package gg.pufferfish.pufferfish.util;
+
+import com.destroystokyo.paper.util.misc.PlayerAreaMap;
+import com.destroystokyo.paper.util.misc.PooledLinkedHashSets;
+import java.util.concurrent.ConcurrentHashMap;
+import net.minecraft.server.level.ServerPlayer;
+
+public final class AsyncPlayerAreaMap extends PlayerAreaMap {
+	
+	public AsyncPlayerAreaMap() {
+		super();
+		this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+	}
+	
+	public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets) {
+		super(pooledHashSets);
+		this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+	}
+	
+	public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets, final ChangeCallback<ServerPlayer> addCallback,
+			final ChangeCallback<ServerPlayer> removeCallback) {
+		this(pooledHashSets, addCallback, removeCallback, null);
+	}
+	
+	public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets, final ChangeCallback<ServerPlayer> addCallback,
+			final ChangeCallback<ServerPlayer> removeCallback, final ChangeSourceCallback<ServerPlayer> changeSourceCallback) {
+		super(pooledHashSets, addCallback, removeCallback, changeSourceCallback);
+		this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+	}
+
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/util/IterableWrapper.java b/src/main/java/gg/pufferfish/pufferfish/util/IterableWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1929840254a3e6d721816f4a20415bea1742580
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/util/IterableWrapper.java
@@ -0,0 +1,20 @@
+package gg.pufferfish.pufferfish.util;
+
+import java.util.Iterator;
+import org.jetbrains.annotations.NotNull;
+
+public class IterableWrapper<T> implements Iterable<T> {
+
+	private final Iterator<T> iterator;
+
+	public IterableWrapper(Iterator<T> iterator) {
+		this.iterator = iterator;
+	}
+
+	@NotNull
+	@Override
+	public Iterator<T> iterator() {
+		return iterator;
+	}
+
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/util/Long2ObjectOpenHashMapWrapper.java b/src/main/java/gg/pufferfish/pufferfish/util/Long2ObjectOpenHashMapWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..facd55463d44cb7e3d2ca6892982f5497b8dded1
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/util/Long2ObjectOpenHashMapWrapper.java
@@ -0,0 +1,40 @@
+package gg.pufferfish.pufferfish.util;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import java.util.Map;
+import org.jetbrains.annotations.Nullable;
+
+public class Long2ObjectOpenHashMapWrapper<V> extends Long2ObjectOpenHashMap<V> {
+	
+	private final Map<Long, V> backingMap;
+	
+	public Long2ObjectOpenHashMapWrapper(Map<Long, V> map) {
+		backingMap = map;
+	}
+	
+	@Override
+	public V put(Long key, V value) {
+		return backingMap.put(key, value);
+	}
+	
+	@Override
+	public V get(Object key) {
+		return backingMap.get(key);
+	}
+	
+	@Override
+	public V remove(Object key) {
+		return backingMap.remove(key);
+	}
+	
+	@Nullable
+	@Override
+	public V putIfAbsent(Long key, V value) {
+		return backingMap.putIfAbsent(key, value);
+	}
+	
+	@Override
+	public int size() {
+		return backingMap.size();
+	}
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 678a448edb5e167d5d2d3d162034312b8a0bf468..d2dc8cd9688784e75edc56cdfd337c17c3b6648e 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -319,6 +319,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public volatile Thread shutdownThread; // Paper
     public volatile boolean abnormalExit = false; // Paper
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
+    public gg.pufferfish.pufferfish.util.AsyncExecutor mobSpawnExecutor = new gg.pufferfish.pufferfish.util.AsyncExecutor("MobSpawning"); // Pufferfish - optimize mob spawning
 
     public static <S extends MinecraftServer> S spin(Function<Thread, S> serverFactory) {
         AtomicReference<S> atomicreference = new AtomicReference();
@@ -2591,7 +2592,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public ProfilerFiller getProfiler() {
-        //if (true || gg.pufferfish.pufferfish.PufferfishConfig.disableMethodProfiler) return net.minecraft.util.profiling.InactiveProfiler.INSTANCE; // Pufferfish // Purpur // Purpur - TODO: Pufferfish
+        if (gg.pufferfish.pufferfish.PufferfishConfig.disableMethodProfiler) return net.minecraft.util.profiling.InactiveProfiler.INSTANCE;
         return this.profiler;
     }
 
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 956df6b435bf04f67f321715cceafd7c1e0165e5..60444929e3e0fb6e53f6df2b41cbc52222d26600 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -243,6 +243,8 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         org.purpurmc.purpur.PurpurConfig.registerCommands();
         // Purpur end
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // Paper - load version history now
+        gg.pufferfish.pufferfish.PufferfishConfig.load(); // Pufferfish
+        gg.pufferfish.pufferfish.PufferfishCommand.init(); // Pufferfish
 
         this.setPvpAllowed(dedicatedserverproperties.pvp);
         this.setFlightAllowed(dedicatedserverproperties.allowFlight);
@@ -389,6 +391,8 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
 
             org.purpurmc.purpur.task.BossBarTask.startAll(); // Purpur
             if (org.purpurmc.purpur.PurpurConfig.beeCountPayload) org.purpurmc.purpur.task.BeehiveTask.instance().register(); // Purpur
+
+            if (gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning) mobSpawnExecutor.start(); // Pufferfish
             return true;
         }
     }
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 345f143b0eeb77acb96e4bc716f3b23782ac782f..5e856f53652658bd4c99ff9e61590fe94dcd8816 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -244,10 +244,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     public final io.papermc.paper.util.player.NearbyPlayers nearbyPlayers;
     // Paper end
-    // Paper start - optimise chunk tick iteration
     public final it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>();
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobSpawnMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
-    // Paper end - optimise chunk tick iteration
 
     public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
         super(new RegionStorageInfo(session.getLevelId(), world.dimension(), "chunk"), session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
@@ -1463,8 +1461,28 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             return ChunkMap.this.level.getServer().getScaledTrackingDistance(initialDistance);
         }
 
+        private static int getHighestRange(Entity parent, int highest) {
+            List<Entity> passengers = parent.getPassengers();
+
+            for (int i = 0, size = passengers.size(); i < size; i++) {
+                Entity entity = passengers.get(i);
+                int range = entity.getType().clientTrackingRange() * 16;
+                range = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, range); // Paper
+
+                if (range > highest) { // Paper - we need the lowest range thanks to the fact that our tracker doesn't account for passenger logic // Tuinity - not anymore!
+                    highest = range;
+                }
+
+                highest = getHighestRange(entity, highest);
+            }
+
+            return highest;
+        }
+
         private int getEffectiveRange() {
             int i = this.range;
+            // Pufferfish start - remove iterators and streams
+            /*
             Iterator iterator = this.entity.getIndirectPassengers().iterator();
 
             while (iterator.hasNext()) {
@@ -1476,6 +1494,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     i = j;
                 }
             }
+             */
+            i = getHighestRange(this.entity, i);
+            // Pufferfish end
 
             return this.scaledRange(i);
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 25aff82dd74ee87f67632af48a2a8e7436fb1a84..e80e14c7b512a3e4e46586c8816dbe05a9cdf0da 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -75,6 +75,9 @@ public class ServerChunkCache extends ChunkSource {
     private final LevelChunk[] lastLoadedChunks = new LevelChunk[4 * 4];
     // Paper end
 
+    public boolean firstRunSpawnCounts = true; // Pufferfish
+    public final java.util.concurrent.atomic.AtomicBoolean _pufferfish_spawnCountsReady = new java.util.concurrent.atomic.AtomicBoolean(false); // Pufferfish - optimize countmobs
+
     public ServerChunkCache(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor workerExecutor, ChunkGenerator chunkGenerator, int viewDistance, int simulationDistance, boolean dsync, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory) {
         this.level = world;
         this.mainThreadProcessor = new ServerChunkCache.MainThreadExecutor(world);
@@ -518,6 +521,7 @@ public class ServerChunkCache extends ChunkSource {
                 int naturalSpawnChunkCount = k;
                 NaturalSpawner.SpawnState spawnercreature_d; // moved down
                 if ((this.spawnFriendlies || this.spawnEnemies) && this.level.paperConfig().entities.spawning.perPlayerMobSpawns) { // don't count mobs when animals and monsters are disabled
+                    if (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning) { // Pufferfish - moved down when async processing
                     // re-set mob counts
                     for (ServerPlayer player : this.level.players) {
                         // Paper start - per player mob spawning backoff
@@ -532,14 +536,18 @@ public class ServerChunkCache extends ChunkSource {
                         }
                         // Paper end - per player mob spawning backoff
                     }
-                    spawnercreature_d = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, null, true);
+                    lastSpawnState = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, null, true); // Pufferfish - async mob spawning
+                    } // Pufferfish - (endif) moved down when async processing
                 } else {
-                    spawnercreature_d = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false);
+                    // Pufferfish start - async mob spawning
+                    lastSpawnState = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false);
+                    _pufferfish_spawnCountsReady.set(true);
+                    // Pufferfish end
                 }
                 // Paper end - Optional per player mob spawns
                 // this.level.timings.countNaturalMobs.stopTiming(); // Paper - timings // Purpur
 
-                this.lastSpawnState = spawnercreature_d;
+                // this.lastSpawnState = spawnercreature_d; // Pufferfish - this is managed asynchronously
                 //gameprofilerfiller.popPush("spawnAndTick"); // Purpur
                 boolean flag = this.level.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING) && !this.level.players().isEmpty(); // CraftBukkit
 
@@ -629,8 +637,8 @@ public class ServerChunkCache extends ChunkSource {
                     if (tick && chunk1.chunkStatus.isOrAfter(net.minecraft.server.level.FullChunkStatus.ENTITY_TICKING)) {
                         // Paper end - optimise chunk tick iteration
                         chunk1.incrementInhabitedTime(j);
-                        if (spawn && flag && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair)) { // Spigot // Paper - optimise chunk tick iteration
-                            NaturalSpawner.spawnForChunk(this.level, chunk1, spawnercreature_d, this.spawnFriendlies, this.spawnEnemies, flag1);
+                        if (spawn && flag && (this.spawnEnemies || this.spawnFriendlies) && (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning || _pufferfish_spawnCountsReady.get()) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair)) { // Spigot // Paper - optimise chunk tick iteration
+                            NaturalSpawner.spawnForChunk(this.level, chunk1, lastSpawnState, this.spawnFriendlies, this.spawnEnemies, flag1); // Pufferfish
                         }
 
                         if (true || this.level.shouldTickBlocksAt(chunkcoordintpair.toLong())) { // Paper - optimise chunk tick iteration
@@ -677,6 +685,40 @@ public class ServerChunkCache extends ChunkSource {
             //gameprofilerfiller.pop(); // Purpur
             //gameprofilerfiller.pop(); // Purpur
         }
+    
+        // Pufferfish start - optimize mob spawning
+        if (gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning) {
+            for (ServerPlayer player : this.level.players) {
+                // Paper start - per player mob spawning backoff
+                for (int ii = 0; ii < ServerPlayer.MOBCATEGORY_TOTAL_ENUMS; ii++) {
+                    player.mobCounts[ii] = 0;
+
+                    int newBackoff = player.mobBackoffCounts[ii] - 1; // TODO make configurable bleed // TODO use nonlinear algorithm?
+                    if (newBackoff < 0) {
+                        newBackoff = 0;
+                    }
+                    player.mobBackoffCounts[ii] = newBackoff;
+                }
+                // Paper end - per player mob spawning backoff
+            }
+            if (firstRunSpawnCounts) {
+                firstRunSpawnCounts = false;
+                _pufferfish_spawnCountsReady.set(true);
+            }
+            if (_pufferfish_spawnCountsReady.getAndSet(false)) {
+                net.minecraft.server.MinecraftServer.getServer().mobSpawnExecutor.submit(() -> {
+                    int mapped = distanceManager.getNaturalSpawnChunkCount();
+                    io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator<Entity> objectiterator =
+                            level.entityTickList.entities.iterator(io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS);
+                    gg.pufferfish.pufferfish.util.IterableWrapper<Entity> wrappedIterator =
+                            new gg.pufferfish.pufferfish.util.IterableWrapper<>(objectiterator);
+                    lastSpawnState = NaturalSpawner.createState(mapped, wrappedIterator, this::getFullChunk, null, true);
+                    objectiterator.finishedIterating();
+                    _pufferfish_spawnCountsReady.set(true);
+                });
+            }
+        }
+        // Pufferfish end
     }
 
     private void getFullChunk(long pos, Consumer<LevelChunk> chunkConsumer) {
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 7924e3c597164f71056cd58dd167ee8b1d41b9c3..4c5017026e8a07508a43b1baa9617e8c8b6e659f 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -921,6 +921,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             //this.timings.entityTick.startTiming(); // Spigot // Purpur
             this.entityTickList.forEach((entity) -> {
+                entity.activatedPriorityReset = false; // Pufferfish - DAB
                 if (!entity.isRemoved()) {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
                         entity.discard();
@@ -1038,7 +1039,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         //gameprofilerfiller.push("thunder"); // Purpur
         final BlockPos.MutableBlockPos blockposition = this.chunkTickMutablePosition; // Paper - use mutable to reduce allocation rate, final to force compile fail on change
 
-        if (!this.paperConfig().environment.disableThunder && flag && this.isThundering() && this.spigotConfig.thunderChance > 0 && this.random.nextInt(this.spigotConfig.thunderChance) == 0) { // Spigot // Paper - Option to disable thunder
+        if (!this.paperConfig().environment.disableThunder && flag && this.isThundering() && this.spigotConfig.thunderChance > 0 && /*this.random.nextInt(this.spigotConfig.thunderChance) == 0 &&*/ chunk.shouldDoLightning(this.random)) { // Spigot // Paper - Option to disable thunder // Pufferfish - replace random with shouldDoLightning
             blockposition.set(this.findLightningTargetAround(this.getBlockRandomPos(j, 0, k, 15))); // Paper
 
             if (this.isRainingAt(blockposition)) {
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 64f5d5ed295fd4bddb2d27f6fefcdf36c29d3254..176e54f1c5f4feb98bee8876c304f6e248909e9c 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1177,6 +1177,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
     @Override
     public void handleEditBook(ServerboundEditBookPacket packet) {
+        if (!gg.pufferfish.pufferfish.PufferfishConfig.enableBooks && !this.player.getBukkitEntity().hasPermission("pufferfish.usebooks")) return; // Pufferfish
         // Paper start - Book size limits
         if (!this.cserver.isPrimaryThread()) {
             List<String> pageList = packet.pages();
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 7c8a3a6af8d5fdbb2341fe4012686bfc4f79a312..579ee25fc358bb6c5d4129e12036b66c35ac2d9b 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -427,6 +427,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public boolean freezeLocked = false; // Paper - Freeze Tick Lock API
     public boolean fixedPose = false; // Paper - Expand Pose API
     public @Nullable Boolean immuneToFire = null; // Purpur - Fire immune API
+    public boolean activatedPriorityReset = false; // Pufferfish - DAB
+    public int activatedPriority = gg.pufferfish.pufferfish.PufferfishConfig.maximumActivationPrio; // Pufferfish - DAB (golf score)
+    public final BlockPos.MutableBlockPos cachedBlockPos = new BlockPos.MutableBlockPos(); // Pufferfish - reduce entity allocations
 
     public void setOrigin(@javax.annotation.Nonnull Location location) {
         this.origin = location.toVector();
@@ -884,6 +887,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public void tick() {
+        // Pufferfish start - entity TTL
+        if (type != EntityType.PLAYER && type.ttl >= 0 && this.tickCount >= type.ttl) {
+            discard();
+            return;
+        }
+        // Pufferfish end - entity TTL
         this.baseTick();
     }
 
@@ -4553,16 +4562,18 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     // Purpur end
 
     public boolean updateFluidHeightAndDoFluidPushing(TagKey<Fluid> tag, double speed) {
-        if (this.touchingUnloadedChunk()) {
+        if (false && this.touchingUnloadedChunk()) { // Pufferfish - cost of a lookup here is the same cost as below, so skip
             return false;
         } else {
             AABB axisalignedbb = this.getBoundingBox().deflate(0.001D);
-            int i = Mth.floor(axisalignedbb.minX);
-            int j = Mth.ceil(axisalignedbb.maxX);
-            int k = Mth.floor(axisalignedbb.minY);
-            int l = Mth.ceil(axisalignedbb.maxY);
-            int i1 = Mth.floor(axisalignedbb.minZ);
-            int j1 = Mth.ceil(axisalignedbb.maxZ);
+            // Pufferfish start - rename
+            int minBlockX = Mth.floor(axisalignedbb.minX);
+            int maxBlockX = Mth.ceil(axisalignedbb.maxX);
+            int minBlockY = Mth.floor(axisalignedbb.minY);
+            int maxBlockY = Mth.ceil(axisalignedbb.maxY);
+            int minBlockZ = Mth.floor(axisalignedbb.minZ);
+            int maxBlockZ = Mth.ceil(axisalignedbb.maxZ);
+            // Pufferfish end
             double d1 = 0.0D;
             boolean flag = this.isPushedByFluid();
             boolean flag1 = false;
@@ -4570,14 +4581,61 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             int k1 = 0;
             BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
 
-            for (int l1 = i; l1 < j; ++l1) {
-                for (int i2 = k; i2 < l; ++i2) {
-                    for (int j2 = i1; j2 < j1; ++j2) {
-                        blockposition_mutableblockposition.set(l1, i2, j2);
-                        FluidState fluid = this.level().getFluidState(blockposition_mutableblockposition);
+            // Pufferfish start - based off CollisionUtil.getCollisionsForBlocksOrWorldBorder
+            final int minSection = io.papermc.paper.util.WorldUtil.getMinSection(this.level());
+            final int maxSection = io.papermc.paper.util.WorldUtil.getMaxSection(this.level());
+            final int minBlock = minSection << 4;
+            final int maxBlock = (maxSection << 4) | 15;
+
+            // special cases:
+            if (minBlockY > maxBlock || maxBlockY < minBlock) {
+                // no point in checking
+                return false;
+            }
+
+            int minYIterate = Math.max(minBlock, minBlockY);
+            int maxYIterate = Math.min(maxBlock, maxBlockY);
+
+            int minChunkX = minBlockX >> 4;
+            int maxChunkX = maxBlockX >> 4;
+
+            int minChunkZ = minBlockZ >> 4;
+            int maxChunkZ = maxBlockZ >> 4;
+
+            for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
+                int minZ = currChunkZ == minChunkZ ? minBlockZ & 15 : 0; // coordinate in chunk
+                int maxZ = currChunkZ == maxChunkZ ? maxBlockZ & 15 : 16; // coordinate in chunk
+
+                for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
+                    int minX = currChunkX == minChunkX ? minBlockX & 15 : 0; // coordinate in chunk
+                    int maxX = currChunkX == maxChunkX ? maxBlockX & 15 : 16; // coordinate in chunk
+
+                    net.minecraft.world.level.chunk.ChunkAccess chunk = this.level().getChunkIfLoadedImmediately(currChunkX, currChunkZ);
+                    if (chunk == null) {
+                        return false; // if we're touching an unloaded chunk then it's false
+                    }
+
+                    net.minecraft.world.level.chunk.LevelChunkSection[] sections = chunk.getSections();
+
+                    for (int currY = minYIterate; currY < maxYIterate; ++currY) {
+                        net.minecraft.world.level.chunk.LevelChunkSection section = sections[(currY >> 4) - minSection];
+
+                        if (section == null || section.hasOnlyAir() || section.fluidStateCount == 0) { // if no fluids, nothing in this section
+                            // empty
+                            // skip to next section
+                            currY = (currY & ~(15)) + 15; // increment by 15: iterator loop increments by the extra one
+                            continue;
+                        }
+
+                        net.minecraft.world.level.chunk.PalettedContainer<BlockState> blocks = section.states;
+
+                        for (int currZ = minZ; currZ < maxZ; ++currZ) {
+                            for (int currX = minX; currX < maxX; ++currX) {
+                                FluidState fluid = blocks.get(currX & 15, currY & 15, currZ & 15).getFluidState();
 
                         if (fluid.is(tag)) {
-                            double d2 = (double) ((float) i2 + fluid.getHeight(this.level(), blockposition_mutableblockposition));
+                            blockposition_mutableblockposition.set((currChunkX << 4) + currX, currY, (currChunkZ << 4) + currZ);
+                            double d2 = (double) ((float) currY + fluid.getHeight(this.level(), blockposition_mutableblockposition));
 
                             if (d2 >= axisalignedbb.minY) {
                                 flag1 = true;
@@ -4599,9 +4657,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                                 // CraftBukkit end
                             }
                         }
+                            }
+                        }
                     }
                 }
             }
+            // Pufferfish end
 
             if (vec3d.length() > 0.0D) {
                 if (k1 > 0) {
diff --git a/src/main/java/net/minecraft/world/entity/EntityType.java b/src/main/java/net/minecraft/world/entity/EntityType.java
index 8120f39a9689dae1233b243b74825e9ff110eac3..32a1b5a1d01fd4dc603a76fde259f3a0d4749fad 100644
--- a/src/main/java/net/minecraft/world/entity/EntityType.java
+++ b/src/main/java/net/minecraft/world/entity/EntityType.java
@@ -316,6 +316,8 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
     private final boolean canSpawnFarFromPlayer;
     private final int clientTrackingRange;
     private final int updateInterval;
+    public boolean dabEnabled = false; // Pufferfish
+    public int ttl = -1; // Pufferfish
     @Nullable
     private String descriptionId;
     @Nullable
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 667938f7a1fdfe29d59cc578379911c5aa703b82..472598d554c6c4134f06443b8ef06c3a726cd830 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -150,7 +150,6 @@ import org.bukkit.event.entity.EntityTeleportEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
 // CraftBukkit end
 
-import co.aikar.timings.MinecraftTimings; // Paper
 
 public abstract class LivingEntity extends Entity implements Attackable {
 
@@ -432,7 +431,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
             boolean flag = this instanceof net.minecraft.world.entity.player.Player;
 
             if (!this.level().isClientSide) {
-                if (this.isInWall()) {
+                if (shouldCheckForSuffocation() && this.isInWall()) { // Pufferfish - optimize suffocation
                     this.hurt(this.damageSources().inWall(), 1.0F);
                 } else if (flag && !this.level().getWorldBorder().isWithinBounds(this.getBoundingBox())) {
                     double d0 = this.level().getWorldBorder().getDistanceToBorder(this) + this.level().getWorldBorder().getDamageSafeZone();
@@ -1466,6 +1465,19 @@ public abstract class LivingEntity extends Entity implements Attackable {
         return this.getHealth() <= 0.0F;
     }
 
+    // Pufferfish start - optimize suffocation
+    public boolean couldPossiblyBeHurt(float amount) {
+        if ((float) this.invulnerableTime > (float) this.invulnerableDuration / 2.0F && amount <= this.lastHurt) {
+            return false;
+        }
+        return true;
+    }
+
+    public boolean shouldCheckForSuffocation() {
+        return !gg.pufferfish.pufferfish.PufferfishConfig.enableSuffocationOptimization || (tickCount % 10 == 0 && couldPossiblyBeHurt(1.0F));
+    }
+    // Pufferfish end
+
     @Override
     public boolean hurt(DamageSource source, float amount) {
         if (this.isInvulnerableTo(source)) {
@@ -2101,6 +2113,20 @@ public abstract class LivingEntity extends Entity implements Attackable {
         return this.lastClimbablePos;
     }
 
+
+    // Pufferfish start
+    private boolean cachedOnClimable = false;
+    private BlockPos lastClimbingPosition = null;
+
+    public boolean onClimableCached() {
+        if (!this.blockPosition().equals(this.lastClimbingPosition)) {
+            this.cachedOnClimable = this.onClimbable();
+            this.lastClimbingPosition = this.blockPosition();
+        }
+        return this.cachedOnClimable;
+    }
+    // Pufferfish end
+
     public boolean onClimbable() {
         if (this.isSpectator()) {
             return false;
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index 174117898f349f83810d45152ca96ececa2a5be5..c4d964aeac21f0809149e1d50182985fd1dd0938 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -238,14 +238,16 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Targeti
         return this.lookControl;
     }
 
+    int _pufferfish_inactiveTickDisableCounter = 0; // Pufferfish - throttle inactive goal selector ticking
     // Paper start
     @Override
     public void inactiveTick() {
         super.inactiveTick();
-        if (this.goalSelector.inactiveTick()) {
+        boolean isThrottled = gg.pufferfish.pufferfish.PufferfishConfig.throttleInactiveGoalSelectorTick && _pufferfish_inactiveTickDisableCounter++ % 20 != 0; // Pufferfish - throttle inactive goal selector ticking
+        if (this.goalSelector.inactiveTick(this.activatedPriority, true) && !isThrottled) { // Pufferfish - pass activated priroity // Pufferfish - throttle inactive goal selector ticking
             this.goalSelector.tick();
         }
-        if (this.targetSelector.inactiveTick()) {
+        if (this.targetSelector.inactiveTick(this.activatedPriority, true)) { // Pufferfish - pass activated priority
             this.targetSelector.tick();
         }
     }
@@ -1000,16 +1002,20 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Targeti
 
         if (i % 2 != 0 && this.tickCount > 1) {
             //gameprofilerfiller.push("targetSelector"); // Purpur
+            if (this.targetSelector.inactiveTick(this.activatedPriority, false)) // Pufferfish - use this to alternate ticking
             this.targetSelector.tickRunningGoals(false);
             //gameprofilerfiller.pop(); // Purpur
             //gameprofilerfiller.push("goalSelector"); // Purpur
+            if (this.goalSelector.inactiveTick(this.activatedPriority, false)) // Pufferfish - use this to alternate ticking
             this.goalSelector.tickRunningGoals(false);
             //gameprofilerfiller.pop(); // Purpur
         } else {
             //gameprofilerfiller.push("targetSelector"); // Purpur
+            if (this.targetSelector.inactiveTick(this.activatedPriority, false)) // Pufferfish - use this to alternate ticking
             this.targetSelector.tick();
             //gameprofilerfiller.pop(); // Purpur
             //gameprofilerfiller.push("goalSelector"); // Purpur
+            if (this.goalSelector.inactiveTick(this.activatedPriority, false)) // Pufferfish - use this to alternate ticking
             this.goalSelector.tick();
             //gameprofilerfiller.pop(); // Purpur
         }
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index c51b429822d56761f69c49ecd4addfab7b90bad8..7d217606c3d14c4a43487c0b47ba35dbd095756f 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -23,6 +23,7 @@ public class AttributeMap {
     private final Set<AttributeInstance> dirtyAttributes = new ObjectOpenHashSet<>();
     private final AttributeSupplier supplier;
     private final net.minecraft.world.entity.LivingEntity entity; // Purpur
+    private final java.util.function.Function<Holder<Attribute>, AttributeInstance> createInstance; // Pufferfish
 
     public AttributeMap(AttributeSupplier defaultAttributes) {
         // Purpur start
@@ -32,6 +33,7 @@ public class AttributeMap {
         this.entity = entity;
         // Purpur end
         this.supplier = defaultAttributes;
+        this.createInstance = attributex -> this.supplier.createInstance(this::onAttributeModified, attributex); // Pufferfish
     }
 
     private void onAttributeModified(AttributeInstance instance) {
@@ -48,9 +50,10 @@ public class AttributeMap {
         return this.attributes.values().stream().filter(attribute -> attribute.getAttribute().value().isClientSyncable() && (entity == null || entity.shouldSendAttribute(attribute.getAttribute().value()))).collect(Collectors.toList()); // Purpur
     }
 
+
     @Nullable
     public AttributeInstance getInstance(Holder<Attribute> attribute) {
-        return this.attributes.computeIfAbsent(attribute, attributex -> this.supplier.createInstance(this::onAttributeModified, attributex));
+        return this.attributes.computeIfAbsent(attribute, this.createInstance); // Pufferfish - cache lambda, as for some reason java allocates it anyways
     }
 
     public boolean hasAttribute(Holder<Attribute> attribute) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/VillagerPanicTrigger.java b/src/main/java/net/minecraft/world/entity/ai/behavior/VillagerPanicTrigger.java
index 758f62416ca9c02351348ac0d41deeb4624abc0e..69130969c9a434ec2361e573c9a1ec9f462dfda2 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/VillagerPanicTrigger.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/VillagerPanicTrigger.java
@@ -36,7 +36,11 @@ public class VillagerPanicTrigger extends Behavior<Villager> {
 
     @Override
     protected void tick(ServerLevel world, Villager entity, long time) {
-        if (time % 100L == 0L) {
+        // Pufferfish start
+        if (entity.nextGolemPanic < 0) entity.nextGolemPanic = time + 100;
+        if (--entity.nextGolemPanic < time) {
+            entity.nextGolemPanic = -1;
+            // Pufferfish end
             entity.spawnGolemIfNeeded(world, time, 3);
         }
     }
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
index b4e4670536f6dcea109c029d75d9710cb386f1d0..3703228bed288252645d08d46f1af095af976838 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -43,9 +43,12 @@ public class GoalSelector {
     }
 
     // Paper start
-    public boolean inactiveTick() {
+    public boolean inactiveTick(int tickRate, boolean inactive) { // Pufferfish start
+        if (inactive && !gg.pufferfish.pufferfish.PufferfishConfig.dearEnabled) tickRate = 4; // reset to Paper's
+        tickRate = Math.min(tickRate, 3);
         this.curRate++;
-        return this.curRate % 3 == 0; // TODO newGoalRate was already unused in 1.20.4, check if this is correct
+        return this.curRate % tickRate == 0; // TODO newGoalRate was already unused in 1.20.4, check if this is correct
+        // Pufferfish end
     }
     public boolean hasTasks() {
         for (WrappedGoal task : this.availableGoals) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
index aee0147649d458b87d92496eda0c1723ebe570d2..89e9ea999d2fbd81a1d74382ef3fcd675fc8b94e 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
@@ -121,6 +121,7 @@ public abstract class MoveToBlockGoal extends Goal {
                 for (int m = 0; m <= l; m = m > 0 ? -m : 1 - m) {
                     for (int n = m < l && m > -l ? l : 0; n <= l; n = n > 0 ? -n : 1 - n) {
                         mutableBlockPos.setWithOffset(blockPos, m, k - 1, n);
+                        if (!this.mob.level().hasChunkAt(mutableBlockPos)) continue; // Pufferfish - if this block isn't loaded, continue
                         if (this.mob.isWithinRestriction(mutableBlockPos) && this.isValidTarget(this.mob.level(), mutableBlockPos)) {
                             this.blockPos = mutableBlockPos;
                             this.mob.movingTarget = mutableBlockPos == BlockPos.ZERO ? null : mutableBlockPos.immutable(); // Paper
diff --git a/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java b/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
index 7463eefb7d09ea55fe8780210e7e967c2fe7896d..13b8141bdb2a1663431be645eb091f9e7638f3d0 100644
--- a/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
+++ b/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
@@ -80,9 +80,18 @@ public class TargetingConditions {
                 }
 
                 if (this.range > 0.0) {
-                    double d = this.testInvisible ? targetEntity.getVisibilityPercent(baseEntity) : 1.0;
-                    double e = Math.max((this.useFollowRange ? this.getFollowRange(baseEntity) : this.range) * d, 2.0); // Paper - Fix MC-145656
+                    // Pufferfish start - check range before getting visibility
+                    // d = invisibility percent, e = follow range adjusted for invisibility, f = distance
                     double f = baseEntity.distanceToSqr(targetEntity.getX(), targetEntity.getY(), targetEntity.getZ());
+                    double followRangeRaw = this.useFollowRange ? this.getFollowRange(baseEntity) : this.range;
+
+                    if (f > followRangeRaw * followRangeRaw) { // the actual follow range will always be this value or smaller, so if the distance is larger then it never will return true after getting invis
+                        return false;
+                    }
+
+                    double d = this.testInvisible ? targetEntity.getVisibilityPercent(baseEntity) : 1.0;
+                    double e = Math.max((followRangeRaw) * d, 2.0); // Paper - Fix MC-145656
+                    // Pufferfish end
                     if (f > e * e) {
                         return false;
                     }
diff --git a/src/main/java/net/minecraft/world/entity/ambient/Bat.java b/src/main/java/net/minecraft/world/entity/ambient/Bat.java
index 47a7c7f9527e1c4ea457eeafe0e11145653a871f..1f9d5d41ee8b167dbd346c413a0b1167dec5439e 100644
--- a/src/main/java/net/minecraft/world/entity/ambient/Bat.java
+++ b/src/main/java/net/minecraft/world/entity/ambient/Bat.java
@@ -317,13 +317,23 @@ public class Bat extends AmbientCreature {
     }
 
     public static boolean isHalloweenSeason(Level level) { return level.purpurConfig.forceHalloweenSeason || isHalloween(); } // Purpur
+
+    // Pufferfish start - only check for spooky season once an hour
+    private static boolean isSpookySeason = false;
+    private static final int ONE_HOUR = 20 * 60 * 60;
+    private static int lastSpookyCheck = -ONE_HOUR;
     private static boolean isHalloween() {
+        if (net.minecraft.server.MinecraftServer.currentTick - lastSpookyCheck > ONE_HOUR) {
         LocalDate localdate = LocalDate.now();
         int i = localdate.get(ChronoField.DAY_OF_MONTH);
         int j = localdate.get(ChronoField.MONTH_OF_YEAR);
 
-        return j == 10 && i >= 20 || j == 11 && i <= 3;
+        isSpookySeason = j == 10 && i >= 20 || j == 11 && i <= 3;
+        lastSpookyCheck = net.minecraft.server.MinecraftServer.currentTick;
+        }
+        return isSpookySeason;
     }
+    // Pufferfish end
 
     private void setupAnimationStates() {
         if (this.isResting()) {
diff --git a/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java b/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
index bca7b7192debb3a34a08047010a2438e7b7e2a78..7b8120e5687897e45bddf2c3ba837ec90fec5519 100644
--- a/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
+++ b/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
@@ -250,10 +250,12 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationS
         return 0.4F;
     }
 
+    private int behaviorTick = 0; // Pufferfish
     @Override
     protected void customServerAiStep() {
         //this.level().getProfiler().push("allayBrain"); // Purpur
         //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider // Purpur - TODO: Pufferfish
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish
         this.getBrain().tick((ServerLevel) this.level(), this);
         //this.level().getProfiler().pop(); // Purpur
         //this.level().getProfiler().push("allayActivityUpdate"); // Purpur
diff --git a/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java b/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java
index d330f79e860662bc93a1703215e66e6564d181b9..b0ce172a0ff5721b49543d84a299b023171320a0 100644
--- a/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java
+++ b/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java
@@ -305,10 +305,12 @@ public class Axolotl extends Animal implements LerpingModel, VariantHolder<Axolo
         return true;
     }
 
+    private int behaviorTick = 0; // Pufferfish
     @Override
     protected void customServerAiStep() {
         //this.level().getProfiler().push("axolotlBrain"); // Purpur
         //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider // Purpur - TODO: Pufferfish
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish
         this.getBrain().tick((ServerLevel) this.level(), this);
         //this.level().getProfiler().pop(); // Purpur
         //this.level().getProfiler().push("axolotlActivityUpdate"); // Purpur
diff --git a/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java b/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
index ee8c232ddaa518377bdfa54e83ffc04f7a2f2c9a..1709976b663d0b7f0a59e8fb8ecffdc9527160c5 100644
--- a/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
+++ b/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
@@ -235,10 +235,12 @@ public class Frog extends Animal implements VariantHolder<Holder<FrogVariant>> {
             .ifPresent(this::setVariant);
     }
 
+    private int behaviorTick = 0; // Pufferfish
     @Override
     protected void customServerAiStep() {
         //this.level().getProfiler().push("frogBrain"); // Purpur
         //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider // Purpur - TODO: Pufferfish
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish
         this.getBrain().tick((ServerLevel)this.level(), this);
         //this.level().getProfiler().pop(); // Purpur
         //this.level().getProfiler().push("frogActivityUpdate"); // Purpur
diff --git a/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java b/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java
index 09c4cf772df4644413e40055fedcdf42ee8064fd..4facfcb297872e2cb75eb2e488a0374a6b32fd9c 100644
--- a/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java
+++ b/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java
@@ -120,10 +120,12 @@ public class Tadpole extends AbstractFish {
         return SoundEvents.TADPOLE_FLOP;
     }
 
+    private int behaviorTick = 0; // Pufferfish
     @Override
     protected void customServerAiStep() {
         //this.level().getProfiler().push("tadpoleBrain"); // Purpur
         //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider // Purpur - TODO: Pufferfish
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish
         this.getBrain().tick((ServerLevel) this.level(), this);
         //this.level().getProfiler().pop(); // Purpur
         //this.level().getProfiler().push("tadpoleActivityUpdate"); // Purpur
diff --git a/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java b/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java
index aa548cba6134652751d73b6774e88f9f6d9ee0ed..eb243c1190d8c2ba0fdd3cca62f978c8fad7c5c6 100644
--- a/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java
+++ b/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java
@@ -222,10 +222,12 @@ public class Goat extends Animal {
         return (Brain<Goat>) super.getBrain(); // CraftBukkit - decompile error
     }
 
+    private int behaviorTick = 0; // Pufferfish
     @Override
     protected void customServerAiStep() {
         //this.level().getProfiler().push("goatBrain"); // Purpur
         //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider // Purpur - TODO: Pufferfish
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish
         this.getBrain().tick((ServerLevel) this.level(), this);
         //this.level().getProfiler().pop(); // Purpur
         //this.level().getProfiler().push("goatActivityUpdate"); // Purpur
diff --git a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
index 4a98027a12c2535d1df3a9f6390eb85146398403..9facda1076794b9efe9a43e2d5f032246e8ee59e 100644
--- a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -295,6 +295,13 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
         this.bossEvent.setName(this.getDisplayName());
     }
 
+    // Pufferfish start - optimize suffocation
+    @Override
+    public boolean shouldCheckForSuffocation() {
+        return true;
+    }
+    // Pufferfish end
+
     @Override
     protected SoundEvent getAmbientSound() {
         return SoundEvents.WITHER_AMBIENT;
diff --git a/src/main/java/net/minecraft/world/entity/monster/EnderMan.java b/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
index 5b49a6b1884c33bedafca5cff0214cdfccd87302..356c4a26dabcf07374234ee2fc6b796bec1d7b40 100644
--- a/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
+++ b/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
@@ -347,11 +347,17 @@ public class EnderMan extends Monster implements NeutralMob {
     private boolean teleport(double x, double y, double z) {
         BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos(x, y, z);
 
-        while (blockposition_mutableblockposition.getY() > this.level().getMinBuildHeight() && !this.level().getBlockState(blockposition_mutableblockposition).blocksMotion()) {
+        // Pufferfish start - single chunk lookup
+        net.minecraft.world.level.chunk.LevelChunk chunk = this.level().getChunkIfLoaded(blockposition_mutableblockposition);
+        if (chunk == null) {
+            return false;
+        }
+        // Pufferfish end
+        while (blockposition_mutableblockposition.getY() > this.level().getMinBuildHeight() && !chunk.getBlockState(blockposition_mutableblockposition).blocksMotion()) { // Pufferfish
             blockposition_mutableblockposition.move(Direction.DOWN);
         }
 
-        BlockState iblockdata = this.level().getBlockState(blockposition_mutableblockposition);
+        BlockState iblockdata = chunk.getBlockState(blockposition_mutableblockposition); // Pufferfish
         boolean flag = iblockdata.blocksMotion();
         boolean flag1 = iblockdata.getFluidState().is(FluidTags.WATER);
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java b/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java
index 757d2b7bcb83f5bdcddf85a00e90288f3b82a2d6..9b1e254adddb26a7583de0a59b4e358b19505bf8 100644
--- a/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java
+++ b/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java
@@ -190,10 +190,12 @@ public class Hoglin extends Animal implements Enemy, HoglinBase {
         return (Brain<Hoglin>)super.getBrain();
     }
 
+    private int behaviorTick; // Pufferfish
     @Override
     protected void customServerAiStep() {
         //this.level().getProfiler().push("hoglinBrain"); // Purpur
         //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider // Purpur - TODO: Pufferfish
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish
         this.getBrain().tick((ServerLevel)this.level(), this);
         //this.level().getProfiler().pop(); // Purpur
         HoglinAi.updateActivity(this);
diff --git a/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java b/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java
index 1b5977aa14d9a7254e7692bb152cc2808d52107a..c6cdaecbfb38a8e43b3cce0ce75f98ecd6b18935 100644
--- a/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java
+++ b/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java
@@ -326,10 +326,12 @@ public class Piglin extends AbstractPiglin implements CrossbowAttackMob, Invento
         return !this.cannotHunt;
     }
 
+    private int behaviorTick; // Pufferfish
     @Override
     protected void customServerAiStep() {
         //this.level().getProfiler().push("piglinBrain"); // Purpur
         //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider // Purpur - TODO: Pufferfish
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish
         this.getBrain().tick((ServerLevel) this.level(), this);
         //this.level().getProfiler().pop(); // Purpur
         PiglinAi.updateActivity(this);
diff --git a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
index 0bb577ec9ba0d23a741ccf067ac35f6be68312ca..e972fec0d9774e3af82c8fab2426917361b496a1 100644
--- a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
+++ b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
@@ -295,12 +295,14 @@ public class Warden extends Monster implements VibrationSystem {
 
     }
 
+    private int behaviorTick = 0; // Pufferfish
     @Override
     protected void customServerAiStep() {
         ServerLevel worldserver = (ServerLevel) this.level();
 
         //worldserver.getProfiler().push("wardenBrain"); // Purpur
         //if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - TODO: Move to Ridables patch
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish
         this.getBrain().tick(worldserver, this);
         //this.level().getProfiler().pop(); // Purpur
         super.customServerAiStep();
diff --git a/src/main/java/net/minecraft/world/entity/npc/Villager.java b/src/main/java/net/minecraft/world/entity/npc/Villager.java
index 4be218129188c1be8736940170a861adc10fdb7d..971f2d594ead143f34911eea857203aac5bdd0b5 100644
--- a/src/main/java/net/minecraft/world/entity/npc/Villager.java
+++ b/src/main/java/net/minecraft/world/entity/npc/Villager.java
@@ -145,6 +145,8 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     private boolean isLobotomized = false; public boolean isLobotomized() { return this.isLobotomized; } // Purpur
     private int notLobotomizedCount = 0; // Purpur
 
+    public long nextGolemPanic = -1; // Pufferfish
+
     public Villager(EntityType<? extends Villager> entityType, Level world) {
         this(entityType, world, VillagerType.PLAINS);
     }
@@ -333,6 +335,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     }
     // Spigot End
 
+    private int behaviorTick = 0; // Pufferfish
     @Override
     @Deprecated // Paper
     protected void customServerAiStep() {
@@ -350,13 +353,12 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
             this.isLobotomized = false;
         }
         // Purpur end
-        if (!inactive) this.getBrain().tick((ServerLevel) this.level(), this); // Paper
-        else if (this.isLobotomized && shouldRestock()) restock(); // Purpur
-        /*// Purpur start // Purpur - TODO: Pufferfish
-        if (!inactive && (getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) { // Purpur - only use brain if no rider
+        // Pufferfish start
+        if (!inactive && this.behaviorTick++ % this.activatedPriority == 0) {
             this.getBrain().tick((ServerLevel) this.level(), this); // Paper
         }
-        // Purpur end*/ // Purpur - TODO: Pufferfish
+        // Pufferfish end
+        else if (this.isLobotomized && shouldRestock()) restock(); // Purpur
         //this.level().getProfiler().pop(); // Purpur
         if (this.assignProfessionWhenSpawned) {
             this.assignProfessionWhenSpawned = false;
diff --git a/src/main/java/net/minecraft/world/entity/player/Inventory.java b/src/main/java/net/minecraft/world/entity/player/Inventory.java
index ca7fbe4f8c1e1d2fb90095aa35be4dda3029c23e..fb118aad4501055f7116f9b878d58b0ad15097d0 100644
--- a/src/main/java/net/minecraft/world/entity/player/Inventory.java
+++ b/src/main/java/net/minecraft/world/entity/player/Inventory.java
@@ -643,6 +643,8 @@ public class Inventory implements Container, Nameable {
     }
 
     public boolean contains(ItemStack stack) {
+        // Pufferfish start - don't allocate iterators
+        /*
         Iterator iterator = this.compartments.iterator();
 
         while (iterator.hasNext()) {
@@ -657,6 +659,18 @@ public class Inventory implements Container, Nameable {
                 }
             }
         }
+         */
+        for (int i = 0; i < this.compartments.size(); i++) {
+            List<ItemStack> list = this.compartments.get(i);
+            for (int j = 0; j < list.size(); j++) {
+                ItemStack itemstack1 = list.get(j);
+
+                if (!itemstack1.isEmpty() && ItemStack.isSameItemSameComponents(itemstack1, stack)) {
+                    return true;
+                }
+            }
+        }
+        // Pufferfish end
 
         return false;
     }
diff --git a/src/main/java/net/minecraft/world/entity/projectile/Projectile.java b/src/main/java/net/minecraft/world/entity/projectile/Projectile.java
index e4d4ff0ef4a0f3283aa42fe2304816cd6d9475a8..a69cd350b6c1e66fc0e81917e23bccc1bc0ab75d 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/Projectile.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/Projectile.java
@@ -46,6 +46,36 @@ public abstract class Projectile extends Entity implements TraceableEntity {
         super(type, world);
     }
 
+    // Pufferfish start
+    private static int loadedThisTick = 0;
+    private static int loadedTick;
+
+    private int loadedLifetime = 0;
+    @Override
+    public void setPos(double x, double y, double z) {
+        int currentTick = net.minecraft.server.MinecraftServer.currentTick;
+        if (loadedTick != currentTick) {
+            loadedTick = currentTick;
+            loadedThisTick = 0;
+        }
+        int previousX = Mth.floor(this.getX()) >> 4, previousZ = Mth.floor(this.getZ()) >> 4;
+        int newX = Mth.floor(x) >> 4, newZ = Mth.floor(z) >> 4;
+        if (previousX != newX || previousZ != newZ) {
+            boolean isLoaded = ((net.minecraft.server.level.ServerChunkCache) this.level().getChunkSource()).getChunkAtIfLoadedImmediately(newX, newZ) != null;
+            if (!isLoaded) {
+                if (Projectile.loadedThisTick > gg.pufferfish.pufferfish.PufferfishConfig.maxProjectileLoadsPerTick) {
+                    if (++this.loadedLifetime > gg.pufferfish.pufferfish.PufferfishConfig.maxProjectileLoadsPerProjectile) {
+                        this.discard();
+                    }
+                    return;
+                }
+                Projectile.loadedThisTick++;
+            }
+        }
+        super.setPos(x, y, z);
+    }
+    // Pufferfish end
+
     public void setOwner(@Nullable Entity entity) {
         if (entity != null) {
             this.ownerUUID = entity.getUUID();
diff --git a/src/main/java/net/minecraft/world/item/EndCrystalItem.java b/src/main/java/net/minecraft/world/item/EndCrystalItem.java
index 8fb564f43e2f1194d2ad68d35c4df6b921d50cfc..4c827c26656ac487cc8c66eeb67e4f38a29fec36 100644
--- a/src/main/java/net/minecraft/world/item/EndCrystalItem.java
+++ b/src/main/java/net/minecraft/world/item/EndCrystalItem.java
@@ -57,7 +57,7 @@ public class EndCrystalItem extends Item {
                         world.gameEvent((Entity) context.getPlayer(), (Holder) GameEvent.ENTITY_PLACE, blockposition1);
                         EndDragonFight enderdragonbattle = ((ServerLevel) world).getDragonFight();
 
-                        if (enderdragonbattle != null) {
+                        if (enderdragonbattle != null && gg.pufferfish.pufferfish.PufferfishConfig.allowEndCrystalRespawn) { // Pufferfish
                             enderdragonbattle.tryRespawn(aboveBlockPosition); // Paper - Perf: Do crystal-portal proximity check before entity lookup
                         }
                     }
diff --git a/src/main/java/net/minecraft/world/item/crafting/ShapelessRecipe.java b/src/main/java/net/minecraft/world/item/crafting/ShapelessRecipe.java
index 3554109bcc4651ca93b6275c914e57e007e2204e..f656c5c54210f62aafe8377782284ae158bd58a4 100644
--- a/src/main/java/net/minecraft/world/item/crafting/ShapelessRecipe.java
+++ b/src/main/java/net/minecraft/world/item/crafting/ShapelessRecipe.java
@@ -27,8 +27,13 @@ public class ShapelessRecipe extends io.papermc.paper.inventory.recipe.RecipeBoo
     final CraftingBookCategory category;
     final ItemStack result;
     final NonNullList<Ingredient> ingredients;
+    private final boolean isBukkit; // Pufferfish
 
+    // Pufferfish start
     public ShapelessRecipe(String group, CraftingBookCategory category, ItemStack result, NonNullList<Ingredient> ingredients) {
+        this(group, category, result, ingredients, false);
+    }
+    public ShapelessRecipe(String group, CraftingBookCategory category, ItemStack result, NonNullList<Ingredient> ingredients, boolean isBukkit) { this.isBukkit = isBukkit; // Pufferfish end
         this.group = group;
         this.category = category;
         this.result = result;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 4beada452d014ec7dc7c167466ec2af3c5bfcd33..5e04a2cc65eca2d0cc20b1580b3d7518010f1e78 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1827,7 +1827,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     }
 
     public ProfilerFiller getProfiler() {
-        //if (true || gg.pufferfish.pufferfish.PufferfishConfig.disableMethodProfiler) return net.minecraft.util.profiling.InactiveProfiler.INSTANCE; // Pufferfish // Purpur // Purpur - TODO: Pufferfish
+        if (gg.pufferfish.pufferfish.PufferfishConfig.disableMethodProfiler) return net.minecraft.util.profiling.InactiveProfiler.INSTANCE; // Pufferfish
         return (ProfilerFiller) this.profiler.get();
     }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 8fea185d3b7213dfef3c94ab7cc38bd008c38d29..5bc079d4edb08f0d3597af6e8f0ce403213434db 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -88,6 +88,18 @@ public class LevelChunk extends ChunkAccess {
     private final LevelChunkTicks<Fluid> fluidTicks;
     public volatile FullChunkStatus chunkStatus = FullChunkStatus.INACCESSIBLE; // Paper - rewrite chunk system
 
+    // Pufferfish start - instead of using a random every time the chunk is ticked, define when lightning strikes preemptively
+    private int lightningTick;
+    // shouldDoLightning compiles down to 29 bytes, which with the default of 35 byte inlining should guarantee an inline
+    public final boolean shouldDoLightning(net.minecraft.util.RandomSource random) {
+        if (this.lightningTick-- <= 0) {
+            this.lightningTick = random.nextInt(this.level.spigotConfig.thunderChance) << 1;
+            return true;
+        }
+        return false;
+    }
+    // Pufferfish end
+
     public LevelChunk(Level world, ChunkPos pos) {
         this(world, pos, UpgradeData.EMPTY, new LevelChunkTicks<>(), new LevelChunkTicks<>(), 0L, (LevelChunkSection[]) null, (LevelChunk.PostLoadProcessor) null, (BlendingData) null);
     }
@@ -111,6 +123,8 @@ public class LevelChunk extends ChunkAccess {
         this.postLoad = entityLoader;
         this.blockTicks = blockTickScheduler;
         this.fluidTicks = fluidTickScheduler;
+
+        this.lightningTick = new java.util.Random().nextInt(100000) << 1; // Pufferfish - initialize lightning tick
     }
 
     // CraftBukkit start
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
index a2a5aef769ee8bb638a5a9f3da9812fa4a85dda5..6d4e8aaa14226032b59d0f38c97f1754f67b9359 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -22,6 +22,7 @@ public class LevelChunkSection {
     short nonEmptyBlockCount; // Paper - package private
     private short tickingBlockCount;
     private short tickingFluidCount;
+    public short fluidStateCount; // Pufferfish
     public final PalettedContainer<BlockState> states;
     // CraftBukkit start - read/write
     private PalettedContainer<Holder<Biome>> biomes;
@@ -102,6 +103,7 @@ public class LevelChunkSection {
 
         if (!fluid.isEmpty()) {
             --this.tickingFluidCount;
+            --this.fluidStateCount; // Pufferfish
         }
 
         if (!state.isAir()) {
@@ -116,6 +118,7 @@ public class LevelChunkSection {
 
         if (!fluid1.isEmpty()) {
             ++this.tickingFluidCount;
+            ++this.fluidStateCount; // Pufferfish
         }
 
         this.updateBlockCallback(x, y, z, iblockdata1, state); // Paper - optimise collisions
@@ -162,6 +165,7 @@ public class LevelChunkSection {
                     if (fluid.isRandomlyTicking()) {
                         this.tickingFluidCount = (short) (this.tickingFluidCount + 1);
                     }
+                    this.fluidStateCount++; // Pufferfish
                 }
 
                 // Paper start - optimise collisions
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
index 83a39f900551e39d5af6f17a339a386ddee4feef..0c8c534fc69172387f188af5282accfed7597ac7 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
@@ -9,7 +9,7 @@ import javax.annotation.Nullable;
 import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
-    private final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entities = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(true); // Paper - rewrite this, always keep this updated - why would we EVER tick an entity that's not ticking?
+    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entities = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(true); // Paper - rewrite this, always keep this updated - why would we EVER tick an entity that's not ticking? // Pufferfish - private->public
 
     private void ensureActiveIsNotIterated() {
         // Paper - replace with better logic, do not delay removals
diff --git a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
index a091c51476214977d7a9729b5c72e8478fe4a391..16f1ed279fb05d47d97692f26d083683dd942dc4 100644
--- a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
+++ b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
@@ -45,6 +45,8 @@ public abstract class FlowingFluid extends Fluid {
     public static final BooleanProperty FALLING = BlockStateProperties.FALLING;
     public static final IntegerProperty LEVEL = BlockStateProperties.LEVEL_FLOWING;
     private static final int CACHE_SIZE = 200;
+    // Pufferfish start - use our own cache
+    /*
     private static final ThreadLocal<Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey>> OCCLUSION_CACHE = ThreadLocal.withInitial(() -> {
         Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey> object2bytelinkedopenhashmap = new Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey>(200) {
             protected void rehash(int i) {}
@@ -53,6 +55,14 @@ public abstract class FlowingFluid extends Fluid {
         object2bytelinkedopenhashmap.defaultReturnValue((byte) 127);
         return object2bytelinkedopenhashmap;
     });
+     */
+
+    private static final ThreadLocal<gg.airplane.structs.FluidDirectionCache<Block.BlockStatePairKey>> localFluidDirectionCache = ThreadLocal.withInitial(() -> {
+        // Pufferfish todo - mess with this number for performance
+        //  with 2048 it seems very infrequent on a small world that it has to remove old entries
+        return new gg.airplane.structs.FluidDirectionCache<>(2048);
+    });
+    // Pufferfish end
     private final Map<FluidState, VoxelShape> shapes = Maps.newIdentityHashMap();
 
     public FlowingFluid() {}
@@ -251,6 +261,8 @@ public abstract class FlowingFluid extends Fluid {
             return false;
         }
         // Paper end - optimise collisions
+        // Pufferfish start - modify to use our cache
+        /*
         Object2ByteLinkedOpenHashMap object2bytelinkedopenhashmap;
 
         if (!state.getBlock().hasDynamicShape() && !fromState.getBlock().hasDynamicShape()) {
@@ -258,9 +270,16 @@ public abstract class FlowingFluid extends Fluid {
         } else {
             object2bytelinkedopenhashmap = null;
         }
+         */
+        gg.airplane.structs.FluidDirectionCache<Block.BlockStatePairKey> cache = null;
+
+        if (!state.getBlock().hasDynamicShape() && !fromState.getBlock().hasDynamicShape()) {
+            cache = localFluidDirectionCache.get();
+        }
 
         Block.BlockStatePairKey block_a;
 
+        /*
         if (object2bytelinkedopenhashmap != null) {
             block_a = new Block.BlockStatePairKey(state, fromState, face);
             byte b0 = object2bytelinkedopenhashmap.getAndMoveToFirst(block_a);
@@ -271,11 +290,22 @@ public abstract class FlowingFluid extends Fluid {
         } else {
             block_a = null;
         }
+         */
+        if (cache != null) {
+            block_a = new Block.BlockStatePairKey(state, fromState, face);
+            Boolean flag = cache.getValue(block_a);
+            if (flag != null) {
+                return flag;
+            }
+        } else {
+            block_a = null;
+        }
 
         VoxelShape voxelshape = state.getCollisionShape(world, pos);
         VoxelShape voxelshape1 = fromState.getCollisionShape(world, fromPos);
         boolean flag = !Shapes.mergedFaceOccludes(voxelshape, voxelshape1, face);
 
+        /*
         if (object2bytelinkedopenhashmap != null) {
             if (object2bytelinkedopenhashmap.size() == 200) {
                 object2bytelinkedopenhashmap.removeLastByte();
@@ -283,6 +313,11 @@ public abstract class FlowingFluid extends Fluid {
 
             object2bytelinkedopenhashmap.putAndMoveToFirst(block_a, (byte) (flag ? 1 : 0));
         }
+         */
+        if (cache != null) {
+            cache.putValue(block_a, flag);
+        }
+        // Pufferfish end
 
         return flag;
     }
diff --git a/src/main/java/net/minecraft/world/level/storage/loot/LootParams.java b/src/main/java/net/minecraft/world/level/storage/loot/LootParams.java
index 37a0002bbe6539648db5219bb373e0404ae48dc0..ca0571d232e102c4b177a1ea44b96f5f0f440211 100644
--- a/src/main/java/net/minecraft/world/level/storage/loot/LootParams.java
+++ b/src/main/java/net/minecraft/world/level/storage/loot/LootParams.java
@@ -21,8 +21,10 @@ public class LootParams {
 
     public LootParams(ServerLevel world, Map<LootContextParam<?>, Object> parameters, Map<ResourceLocation, LootParams.DynamicDrop> dynamicDrops, float luck) {
         this.level = world;
-        this.params = parameters;
-        this.dynamicDrops = dynamicDrops;
+        // Pufferfish start - use unmodifiable maps instead of immutable ones to skip the copy
+        this.params = java.util.Collections.unmodifiableMap(parameters);
+        this.dynamicDrops = java.util.Collections.unmodifiableMap(dynamicDrops);
+        // Pufferfish end
         this.luck = luck;
     }
 
diff --git a/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java b/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java
index 88a4a72bb390947dc17e5da09a99b2d1b3ac4621..284c76ddb9724b44bb2e93f590685c728e843e6d 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java
@@ -17,50 +17,69 @@ public class EntityCollisionContext implements CollisionContext {
             return defaultValue;
         }
     };
-    private final boolean descending;
-    private final double entityBottom;
-    private final ItemStack heldItem;
-    private final Predicate<FluidState> canStandOnFluid;
+    // Pufferfish start - remove these and pray no plugin uses them
+    // private final boolean descending;
+    // private final double entityBottom;
+    // private final ItemStack heldItem;
+    // private final Predicate<FluidState> canStandOnFluid;
+    // Pufferfish end
     @Nullable
     private final Entity entity;
 
     protected EntityCollisionContext(boolean descending, double minY, ItemStack heldItem, Predicate<FluidState> walkOnFluidPredicate, @Nullable Entity entity) {
-        this.descending = descending;
-        this.entityBottom = minY;
-        this.heldItem = heldItem;
-        this.canStandOnFluid = walkOnFluidPredicate;
+        // Pufferfish start - remove these
+        // this.descending = descending;
+        // this.entityBottom = minY;
+        // this.heldItem = heldItem;
+        // this.canStandOnFluid = walkOnFluidPredicate;
+        // Pufferfish end
         this.entity = entity;
     }
 
     @Deprecated
     protected EntityCollisionContext(Entity entity) {
-        this(
-            entity.isDescending(),
-            entity.getY(),
-            entity instanceof LivingEntity ? ((LivingEntity)entity).getMainHandItem() : ItemStack.EMPTY,
-            entity instanceof LivingEntity ? ((LivingEntity)entity)::canStandOnFluid : fluidState -> false,
-            entity
-        );
+        // Pufferfish start - remove this
+        // this(
+        //     entity.isDescending(),
+        //     entity.getY(),
+        //     entity instanceof LivingEntity ? ((LivingEntity)entity).getMainHandItem() : ItemStack.EMPTY,
+        //     entity instanceof LivingEntity ? ((LivingEntity)entity)::canStandOnFluid : fluidState -> false,
+        //     entity
+        // );
+        // Pufferfish end
+        this.entity = entity;
     }
 
     @Override
     public boolean isHoldingItem(Item item) {
-        return this.heldItem.is(item);
+        // Pufferfish start
+        Entity entity = this.entity;
+        if (entity instanceof LivingEntity livingEntity) {
+            return livingEntity.getMainHandItem().is(item);
+        }
+        return ItemStack.EMPTY.is(item);
+        // Pufferfish end
     }
 
     @Override
     public boolean canStandOnFluid(FluidState stateAbove, FluidState state) {
-        return this.canStandOnFluid.test(state) && !stateAbove.getType().isSame(state.getType());
+        // Pufferfish start
+        Entity entity = this.entity;
+        if (entity instanceof LivingEntity livingEntity) {
+            return livingEntity.canStandOnFluid(state) && !stateAbove.getType().isSame(state.getType());
+        }
+        return false;
+        // Pufferfish end
     }
 
     @Override
     public boolean isDescending() {
-        return this.descending;
+        return this.entity != null && this.entity.isDescending(); // Pufferfish
     }
 
     @Override
     public boolean isAbove(VoxelShape shape, BlockPos pos, boolean defaultValue) {
-        return this.entityBottom > (double)pos.getY() + shape.max(Direction.Axis.Y) - 1.0E-5F;
+        return (this.entity == null ? -Double.MAX_VALUE : entity.getY()) > (double)pos.getY() + shape.max(Direction.Axis.Y) - 1.0E-5F; // Pufferfish
     }
 
     @Nullable
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java
index 96d772eb02f79f8c478f5e6f065e387aa7665b18..c5ce412f321b8b4f31cc042893659e213b081f29 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java
@@ -45,6 +45,6 @@ public class CraftShapelessRecipe extends ShapelessRecipe implements CraftRecipe
             data.set(i, this.toNMS(ingred.get(i), true));
         }
 
-        MinecraftServer.getServer().getRecipeManager().addRecipe(new RecipeHolder<>(CraftNamespacedKey.toMinecraft(this.getKey()), new net.minecraft.world.item.crafting.ShapelessRecipe(this.getGroup(), CraftRecipe.getCategory(this.getCategory()), CraftItemStack.asNMSCopy(this.getResult()), data)));
+        MinecraftServer.getServer().getRecipeManager().addRecipe(new RecipeHolder<>(CraftNamespacedKey.toMinecraft(this.getKey()), new net.minecraft.world.item.crafting.ShapelessRecipe(this.getGroup(), CraftRecipe.getCategory(this.getCategory()), CraftItemStack.asNMSCopy(this.getResult()), data, true))); // Pufferfish
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index e29826bdfcdde938c1e1ea4092efccda13f52218..0d3a353c69a54b588e7a43ed1d286ee3253a8e8f 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -504,7 +504,7 @@ public final class CraftMagicNumbers implements UnsafeValues {
 
     @Override
     public com.destroystokyo.paper.util.VersionFetcher getVersionFetcher() {
-        return new com.destroystokyo.paper.PaperVersionFetcher(); // Purpur - TODO: Pufferfish
+        return new gg.pufferfish.pufferfish.PufferfishVersionFetcher(); // Pufferfish
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/util/ServerShutdownThread.java b/src/main/java/org/bukkit/craftbukkit/util/ServerShutdownThread.java
index e8e93538dfd71de86515d9405f728db1631e949a..3dff02fd97f001508e2f81192817bf1b0ef92446 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/ServerShutdownThread.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/ServerShutdownThread.java
@@ -11,6 +11,7 @@ public class ServerShutdownThread extends Thread {
 
     @Override
     public void run() {
+        try { gg.pufferfish.pufferfish.flare.ProfilingManager.stop(); } catch (Throwable t) {} // Pufferfish - shut down Flare if it's running
         try {
             // Paper start - try to shutdown on main
             server.safeShutdown(false, false);
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index f7644c5045b1accae4c0aaf44df26286c6cc5125..c9a10c0b952f7590a48d0b96cacd8e012543d805 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -38,6 +38,10 @@ import co.aikar.timings.MinecraftTimings;
 import net.minecraft.world.entity.schedule.Activity;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.AABB;
+// Pufferfish start
+import net.minecraft.world.phys.Vec3;
+import java.util.List;
+// Pufferfish end
 
 public class ActivationRange
 {
@@ -224,6 +228,25 @@ public class ActivationRange
                 }
                 // Paper end - Configurable marker ticking
                 ActivationRange.activateEntity(entity);
+
+                // Pufferfish start
+                if (gg.pufferfish.pufferfish.PufferfishConfig.dearEnabled && entity.getType().dabEnabled) {
+                    if (!entity.activatedPriorityReset) {
+                        entity.activatedPriorityReset = true;
+                        entity.activatedPriority = gg.pufferfish.pufferfish.PufferfishConfig.maximumActivationPrio;
+                    }
+                    Vec3 playerVec = player.position();
+                    Vec3 entityVec = entity.position();
+                    double diffX = playerVec.x - entityVec.x, diffY = playerVec.y - entityVec.y, diffZ = playerVec.z - entityVec.z;
+                    int squaredDistance = (int) (diffX * diffX + diffY * diffY + diffZ * diffZ);
+                    entity.activatedPriority = squaredDistance > gg.pufferfish.pufferfish.PufferfishConfig.startDistanceSquared ?
+                      Math.max(1, Math.min(squaredDistance >> gg.pufferfish.pufferfish.PufferfishConfig.activationDistanceMod, entity.activatedPriority)) :
+                      1;
+                } else {
+                    entity.activatedPriority = 1;
+                }
+                // Pufferfish end
+
             }
             // Paper end
         }
@@ -240,12 +263,12 @@ public class ActivationRange
         if ( MinecraftServer.currentTick > entity.activatedTick )
         {
             if ( entity.defaultActivationState )
-            {
+            { // Pufferfish - diff on change
                 entity.activatedTick = MinecraftServer.currentTick;
                 return;
             }
             if ( entity.activationType.boundingBox.intersects( entity.getBoundingBox() ) )
-            {
+            {  // Pufferfish - diff on change
                 entity.activatedTick = MinecraftServer.currentTick;
             }
         }
@@ -299,7 +322,7 @@ public class ActivationRange
         if ( entity instanceof LivingEntity )
         {
             LivingEntity living = (LivingEntity) entity;
-            if ( living.onClimbable() || living.jumping || living.hurtTime > 0 || living.activeEffects.size() > 0 || living.isFreezing()) // Paper
+            if ( living.onClimableCached() || living.jumping || living.hurtTime > 0 || living.activeEffects.size() > 0 || living.isFreezing() ) // Paper // Pufferfish - use cached
             {
                 return 1; // Paper
             }
