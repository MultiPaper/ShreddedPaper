From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sat, 4 May 2024 23:10:00 +0900
Subject: [PATCH] Multithread chunk ticking


diff --git a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
new file mode 100644
index 0000000000000000000000000000000000000000..51ce3a1324793f3560cd718d5aa37b33ebbaafa0
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
@@ -0,0 +1,57 @@
+package io.multipaper.shreddedpaper.region;
+
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.LevelChunk;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+
+public class LevelChunkRegion {
+
+    private final ServerLevel level;
+    private final RegionPos regionPos;
+    private final List<LevelChunk> levelChunks = new ArrayList<>(RegionPos.REGION_SIZE * RegionPos.REGION_SIZE);
+
+    public LevelChunkRegion(ServerLevel level, RegionPos regionPos) {
+        this.level = level;
+        this.regionPos = regionPos;
+    }
+
+    public synchronized void add(LevelChunk levelChunk) {
+        levelChunks.add(levelChunk);
+    }
+
+    public synchronized void remove(LevelChunk levelChunk) {
+        if (!levelChunks.remove(levelChunk)) {
+            throw new IllegalStateException("Tried to remove a chunk that wasn't in the region: " + levelChunk.getPos());
+        }
+    }
+
+    public ServerLevel getLevel() {
+        return level;
+    }
+
+    public RegionPos getRegionPos() {
+        return regionPos;
+    }
+
+    public void forEach(Consumer<LevelChunk> consumer) {
+        // This method has the chance of skipping a chunk if a chunk is removed via another thread during this iteration
+        for (int i = 0; i < levelChunks.size(); i++) {
+            try {
+                LevelChunk levelChunk = levelChunks.get(i);
+                if (levelChunk != null) {
+                    consumer.accept(levelChunk);
+                }
+            } catch (IndexOutOfBoundsException e) {
+                // Ignore - multithreaded modification
+            }
+        }
+    }
+
+    public boolean isEmpty() {
+        return levelChunks.isEmpty();
+    }
+
+}
diff --git a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..89724b9d82813cc5d42eb1a0a3d4bf50e406a3ca
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java
@@ -0,0 +1,60 @@
+package io.multipaper.shreddedpaper.region;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.LevelChunk;
+import io.multipaper.shreddedpaper.util.SimpleStampedLock;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+
+public class LevelChunkRegionMap {
+
+    private final ServerLevel level;
+    private final SimpleStampedLock regionsLock = new SimpleStampedLock();
+    private final Long2ObjectOpenHashMap<LevelChunkRegion> regions = new Long2ObjectOpenHashMap<>(2048, 0.5f);
+
+    public LevelChunkRegionMap(ServerLevel level) {
+        this.level = level;
+    }
+
+    public LevelChunkRegion getOrCreate(RegionPos regionPos) {
+        LevelChunkRegion levelChunkRegion = get(regionPos);
+
+        if (levelChunkRegion != null) {
+            return levelChunkRegion;
+        }
+
+        return regionsLock.write(() -> regions.computeIfAbsent(regionPos.longKey, k -> new LevelChunkRegion(level, regionPos)));
+    }
+
+    public LevelChunkRegion get(RegionPos regionPos) {
+        return regionsLock.optimisticRead(() -> regions.get(regionPos.longKey));
+    }
+
+    public void remove(RegionPos regionPos) {
+        regionsLock.write(() -> {
+            LevelChunkRegion region = regions.remove(regionPos.longKey);
+            if (!region.isEmpty()) {
+                // Guess this region has been modified by another thread, re-add it
+                regions.put(regionPos.longKey, region);
+            }
+        });
+    }
+
+    public void addTickingChunk(LevelChunk levelChunk) {
+        getOrCreate(RegionPos.forChunk(levelChunk.getPos())).add(levelChunk);
+    }
+
+    public void removeTickingChunk(LevelChunk levelChunk) {
+        getOrCreate(RegionPos.forChunk(levelChunk.getPos())).remove(levelChunk);
+    }
+
+    public void forEach(Consumer<LevelChunkRegion> consumer) {
+        List<LevelChunkRegion> regionsCopy = new ArrayList<>(regions.size());
+        regionsLock.read(() -> regionsCopy.addAll(regions.values()));
+        regionsCopy.forEach(consumer);
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
new file mode 100644
index 0000000000000000000000000000000000000000..41e3f42b860ec3a9c030d0e627908ea5c84a2694
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
@@ -0,0 +1,120 @@
+package io.multipaper.shreddedpaper.threading;
+
+import com.mojang.logging.LogUtils;
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.papermc.paper.util.player.NearbyPlayers;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerChunkCache;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.NaturalSpawner;
+import net.minecraft.world.level.chunk.LevelChunk;
+import io.multipaper.shreddedpaper.region.LevelChunkRegion;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+public class ShreddedPaperChunkTicker {
+
+    private static final ThreadLocal<LevelChunkRegion> currentlyTickingRegion = new ThreadLocal<>();
+
+    private final ServerChunkCache serverChunkCache;
+
+    public ShreddedPaperChunkTicker(ServerChunkCache serverChunkCache) {
+        this.serverChunkCache = serverChunkCache;
+    }
+
+    public CompletableFuture<Void> tickChunks(NaturalSpawner.SpawnState spawnercreature_d) {
+        ServerLevel level = this.serverChunkCache.chunkMap.level;
+        List<CompletableFuture<Void>> futures = new ArrayList<>();
+
+        level.chunkSource.tickingRegions.forEach(
+                region -> futures.add(this.tickRegion(level, region, spawnercreature_d))
+        );
+
+        return CompletableFuture.allOf(futures.toArray(CompletableFuture[]::new));
+    }
+
+    private CompletableFuture<Void> tickRegion(ServerLevel level, LevelChunkRegion region, NaturalSpawner.SpawnState spawnercreature_d) {
+        return level.chunkScheduler.schedule(region.getRegionPos(), () -> this._tickRegion(level, region, spawnercreature_d)).exceptionally(e -> {
+            LogUtils.getClassLogger().error("Exception ticking region {}", region.getRegionPos(), e);
+            MinecraftServer.chunkSystemCrash = new RuntimeException("Ticking thread crash while ticking region " + region.getRegionPos(), e);
+            return null;
+        });
+    }
+
+    public static boolean isCurrentlyTickingRegion(Level level, RegionPos regionPos) {
+        LevelChunkRegion region = currentlyTickingRegion.get();
+        return region != null && level.equals(region.getLevel()) && regionPos.equals(region.getRegionPos());
+    }
+
+    private void _tickRegion(ServerLevel level, LevelChunkRegion region, NaturalSpawner.SpawnState spawnercreature_d) {
+        try {
+            currentlyTickingRegion.set(region);
+
+            region.forEach(chunk -> this._tickChunk(level, chunk, spawnercreature_d));
+
+            if (region.isEmpty()) {
+                level.chunkSource.tickingRegions.remove(region.getRegionPos());
+            }
+        } finally {
+            currentlyTickingRegion.remove();
+        }
+    }
+
+    private void _tickChunk(ServerLevel level, LevelChunk chunk1, NaturalSpawner.SpawnState spawnercreature_d) {
+        // Start - Import the same variables as the original chunk ticking method to make copying new changes easier
+        int j = 1; // Inhabited time increment in ticks
+        boolean flag = level.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING) && !level.players().isEmpty(); // Should run mob spawning code
+        NearbyPlayers nearbyPlayers = level.chunkSource.chunkMap.getNearbyPlayers();
+        ChunkPos chunkcoordintpair = chunk1.getPos();
+        boolean flag1 = level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) != 0L && level.getLevelData().getGameTime() % level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) == 0L;
+        int l = level.getGameRules().getInt(GameRules.RULE_RANDOMTICKING);
+        // End
+
+        // Paper start - optimise chunk tick iteration
+        com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> playersNearby
+                = nearbyPlayers.getPlayers(chunkcoordintpair, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.SPAWN_RANGE);
+        if (playersNearby == null) {
+            return;
+        }
+        Object[] rawData = playersNearby.getRawData();
+        boolean spawn = false;
+        boolean tick = false;
+        for (int itr = 0, len = playersNearby.size(); itr < len; ++itr) {
+            ServerPlayer player = (ServerPlayer)rawData[itr];
+            if (player.isSpectator()) {
+                continue;
+            }
+
+            double distance = ChunkMap.euclideanDistanceSquared(chunkcoordintpair, player);
+            spawn |= player.lastEntitySpawnRadiusSquared >= distance;
+            tick |= ((double)io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) * ((double)io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) >= distance;
+            if (spawn & tick) {
+                break;
+            }
+        }
+        if (tick && chunk1.chunkStatus.isOrAfter(net.minecraft.server.level.FullChunkStatus.ENTITY_TICKING)) {
+            // Paper end - optimise chunk tick iteration
+            chunk1.incrementInhabitedTime(j);
+            // Pufferfish Code:
+            if (spawn && flag && (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning || level.getChunkSource()._pufferfish_spawnCountsReady.get()) && (level.chunkSource.spawnEnemies || level.chunkSource.spawnFriendlies) && level.getWorldBorder().isWithinBounds(chunkcoordintpair)) { // Spigot // Paper - optimise chunk tick iteration // Pufferfish
+                NaturalSpawner.spawnForChunk(level, chunk1, spawnercreature_d, level.chunkSource.spawnFriendlies, level.chunkSource.spawnEnemies, flag1); // Pufferfish
+            // Non-Pufferfish code:
+            // if (spawn && flag && (level.chunkSource.spawnEnemies || level.chunkSource.spawnFriendlies) && level.getWorldBorder().isWithinBounds(chunkcoordintpair)) { // Spigot // Paper - optimise chunk tick iteration
+            //     NaturalSpawner.spawnForChunk(level, chunk1, spawnercreature_d, level.chunkSource.spawnFriendlies, level.chunkSource.spawnEnemies, flag1);
+            }
+
+            if (true || level.shouldTickBlocksAt(chunkcoordintpair.toLong())) { // Paper - optimise chunk tick iteration
+                level.tickChunk(chunk1, l);
+                // if ((chunksTicked++ & 1) == 0) net.minecraft.server.MinecraftServer.getServer().executeMidTickTasks(); // Paper // ShreddedPaper - does this need to be implemented??
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java b/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java
index e3f56908cc8a9c3f4580def50fcfdc61bd495a71..c063d9a29f2e7a14ccb878c758db9692f9ae9c6d 100644
--- a/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java
+++ b/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java
@@ -101,23 +101,25 @@ public final class ChunkSystem {
     }
 
     public static void onChunkTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        chunk.level.getChunkSource().tickingChunks.add(chunk);
+        // chunk.level.getChunkSource().tickingChunks.add(chunk); // ShreddedPaper - unused, replaced by tickingRegions
         chunk.chunkStatus = net.minecraft.server.level.FullChunkStatus.BLOCK_TICKING;
         chunk.level.chunkSource.chunkMap.tickingGenerated.incrementAndGet();
+        chunk.level.getChunkSource().tickingRegions.addTickingChunk(chunk); // ShreddedPaper
     }
 
     public static void onChunkNotTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        chunk.level.getChunkSource().tickingChunks.remove(chunk);
+        // chunk.level.getChunkSource().tickingChunks.remove(chunk); // ShreddedPaper - unused, replaced by tickingRegions
         chunk.chunkStatus = net.minecraft.server.level.FullChunkStatus.FULL;
+        chunk.level.getChunkSource().tickingRegions.removeTickingChunk(chunk); // ShreddedPaper
     }
 
     public static void onChunkEntityTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        chunk.level.getChunkSource().entityTickingChunks.add(chunk);
+        // chunk.level.getChunkSource().entityTickingChunks.add(chunk); // ShreddedPaper - unused, replaced by tickingRegions
         chunk.chunkStatus = net.minecraft.server.level.FullChunkStatus.ENTITY_TICKING;
     }
 
     public static void onChunkNotEntityTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        chunk.level.getChunkSource().entityTickingChunks.remove(chunk);
+        // chunk.level.getChunkSource().entityTickingChunks.remove(chunk); // ShreddedPaper - unused, replaced by tickingRegions
         chunk.chunkStatus = net.minecraft.server.level.FullChunkStatus.BLOCK_TICKING;
     }
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index c617f12b7e44859a4edafc0deff844cd2148268d..1cfde8e63d039144846a743ddb2b40794a7c8f84 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1737,7 +1737,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.server.getScheduler().mainThreadHeartbeat(this.tickCount); // CraftBukkit
         //MinecraftTimings.bukkitSchedulerTimer.stopTiming(); // Spigot // Paper // Purpur
         // Paper start - Folia scheduler API
-        ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) Bukkit.getGlobalRegionScheduler()).tick();
+        // ShreddedPaper - moved global scheduler down
         getAllLevels().forEach(level -> {
             for (final Entity entity : level.getEntityLookup().getAllCopy()) { // Paper - rewrite chunk system
                 if (entity.isRemoved()) {
@@ -1789,6 +1789,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         //MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper // Purpur
 
         this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
+        List<CompletableFuture<Void>> futures = new ArrayList<>(); // ShreddedPaper - tick worlds async
         Iterator iterator = this.getAllLevels().iterator(); // Paper - Throw exception on world create while being ticked; move down
         while (iterator.hasNext()) {
             ServerLevel worldserver = (ServerLevel) iterator.next();
@@ -1815,12 +1816,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             try {
                 //worldserver.timings.doTick.startTiming(); // Spigot // Purpur
-                worldserver.tick(shouldKeepTicking);
+                futures.add(CompletableFuture.supplyAsync(() -> worldserver.tick(shouldKeepTicking), ShreddedPaperTickThread.getExecutor()).thenCompose(v -> v).thenRun(() -> { // ShreddedPaper - tick worlds async
                 // Paper start
                 for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
                     regionManager.recalculateRegions();
                 }
+                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
                 // Paper end
+                })); // ShreddedPaper - tick worlds async
                 //worldserver.timings.doTick.stopTiming(); // Spigot // Purpur
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
@@ -1831,10 +1834,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             //this.profiler.pop(); // Purpur
             //this.profiler.pop(); // Purpur
-            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+            // ShreddedPaper - moved optimize explosions up
         }
         this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
 
+        // ShreddedPaper start - tick worlds async
+        ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) Bukkit.getGlobalRegionScheduler()).tick(); // Run global region scheduler async to world ticking
+        for (CompletableFuture<Void> future : futures) {
+            this.managedBlock(future::isDone);
+            future.join();
+        }
+        // ShreddedPaper end - tick worlds async
+
         //this.profiler.popPush("connection"); // Purpur
         // MinecraftTimings.connectionTimer.startTiming(); // Spigot // Paper // Purpur
         this.getConnection().tick();
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index e80e14c7b512a3e4e46586c8816dbe05a9cdf0da..7a75de1ad600505ce44b299e8eabfece9b48c387 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -1,12 +1,10 @@
 package net.minecraft.server.level;
 
 import com.google.common.annotations.VisibleForTesting;
-import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.CompletableFuture;
@@ -21,7 +19,6 @@ import net.minecraft.core.SectionPos;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.util.VisibleForDebug;
-import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.thread.BlockableEventLoop;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.ai.village.poi.PoiManager;
@@ -44,6 +41,8 @@ import net.minecraft.world.level.levelgen.RandomState;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
+import io.multipaper.shreddedpaper.region.LevelChunkRegionMap;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperChunkTicker;
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -63,12 +62,14 @@ public class ServerChunkCache extends ChunkSource {
     private final long[] lastChunkPos = new long[4];
     private final ChunkStatus[] lastChunkStatus = new ChunkStatus[4];
     private final ChunkAccess[] lastChunk = new ChunkAccess[4];
+    private final ShreddedPaperChunkTicker shreddedPaperChunkTicker = new ShreddedPaperChunkTicker(this); // ShreddedPaper
     @Nullable
     @VisibleForDebug
     private NaturalSpawner.SpawnState lastSpawnState;
     // Paper start
-    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> tickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
-    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> entityTickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
+    public final LevelChunkRegionMap tickingRegions; // ShreddedPaper
+    // public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> tickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true); // ShreddedPaper - unused, ensure it remains that way
+    // public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> entityTickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true); // ShreddedPaper - unused, ensure it remains that way
     final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
     final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<LevelChunk> loadedChunkMap = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>(8192, 0.5f);
     final java.util.concurrent.atomic.AtomicLong chunkFutureAwaitCounter = new java.util.concurrent.atomic.AtomicLong(); // Paper - chunk system rewrite
@@ -80,6 +81,7 @@ public class ServerChunkCache extends ChunkSource {
 
     public ServerChunkCache(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor workerExecutor, ChunkGenerator chunkGenerator, int viewDistance, int simulationDistance, boolean dsync, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory) {
         this.level = world;
+        this.tickingRegions = new LevelChunkRegionMap(this.level); // ShreddedPaper
         this.mainThreadProcessor = new ServerChunkCache.MainThreadExecutor(world);
         this.mainThread = Thread.currentThread();
         File file = session.getDimensionPath(world.dimension()).resolve("data").toFile();
@@ -473,7 +475,8 @@ public class ServerChunkCache extends ChunkSource {
     // CraftBukkit end
 
     @Override
-    public void tick(BooleanSupplier shouldKeepTicking, boolean tickChunks) {
+    public CompletableFuture<Void> tick(BooleanSupplier shouldKeepTicking, boolean tickChunks) { // ShreddedPaper - run async
+        CompletableFuture<Void> future = CompletableFuture.completedFuture(null); // ShreddedPaper - run async
         //this.level.getProfiler().push("purge"); // Purpur
         //this.level.timings.doChunkMap.startTiming(); // Spigot // Purpur
         if (this.level.tickRateManager().runsNormally() || !tickChunks || this.level.spigotConfig.unloadFrozenChunks) { // Spigot
@@ -485,20 +488,25 @@ public class ServerChunkCache extends ChunkSource {
         if (tickChunks) {
             //this.level.timings.chunks.startTiming(); // Paper - timings // Purpur
             this.chunkMap.level.playerChunkLoader.tick(); // Paper - replace player chunk loader - this is mostly required to account for view distance changes
-            this.tickChunks();
+            future = future.thenCompose(v -> this.tickChunks()); // ShreddedPaper - run async
             //this.level.timings.chunks.stopTiming(); // Paper - timings // Purpur
-            this.chunkMap.tick();
+            future = future.thenRun(() -> this.chunkMap.tick()); // ShreddedPaper - run async
         }
 
+        future = future.thenRun(() -> { // ShreddedPaper - run async
         //this.level.timings.doChunkUnload.startTiming(); // Spigot // Purpur
         //this.level.getProfiler().popPush("unload"); // Purpur
         this.chunkMap.tick(shouldKeepTicking);
         //this.level.timings.doChunkUnload.stopTiming(); // Spigot // Purpur
         //this.level.getProfiler().pop(); // Purpur
         this.clearCache();
+        }); // ShreddedPaper - run async
+
+        return future; // ShreddedPaper - run async
     }
 
-    private void tickChunks() {
+    private CompletableFuture<Void> tickChunks() { // ShreddedPaper - run async
+        CompletableFuture<Void> future = CompletableFuture.completedFuture(null); // ShreddedPaper - run async
         long i = this.level.getGameTime();
         long j = i - this.lastInhabitedUpdate;
 
@@ -591,75 +599,76 @@ public class ServerChunkCache extends ChunkSource {
                 // Paper - optimise chunk tick iteration
 
                 int chunksTicked = 0; // Paper
+                future = future.thenCompose(v -> this.shreddedPaperChunkTicker.tickChunks(lastSpawnState)); // ShreddedPaper // Pufferfish - use lastSpawnState instead of spawnercreature_d
                 // Paper start - optimise chunk tick iteration
-                io.papermc.paper.util.player.NearbyPlayers nearbyPlayers = this.chunkMap.getNearbyPlayers(); // Paper - optimise chunk tick iteration
-                Iterator<LevelChunk> chunkIterator;
-                if (this.level.paperConfig().entities.spawning.perPlayerMobSpawns) {
-                    chunkIterator = this.tickingChunks.iterator();
-                } else {
-                    chunkIterator = this.tickingChunks.unsafeIterator();
-                    List<LevelChunk> shuffled = Lists.newArrayListWithCapacity(this.tickingChunks.size());
-                    while (chunkIterator.hasNext()) {
-                        shuffled.add(chunkIterator.next());
-                    }
-                    Util.shuffle(shuffled, this.level.random);
-                    chunkIterator = shuffled.iterator();
-                }
-                try {
-                // Paper end - optimise chunk tick iteration
-                while (chunkIterator.hasNext()) {
-                    LevelChunk chunk1 = chunkIterator.next();
-                    // Paper end - optimise chunk tick iteration
-                    ChunkPos chunkcoordintpair = chunk1.getPos();
-
-                    // Paper start - optimise chunk tick iteration
-                    com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> playersNearby
-                        = nearbyPlayers.getPlayers(chunkcoordintpair, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.SPAWN_RANGE);
-                    if (playersNearby == null) {
-                        continue;
-                    }
-                    Object[] rawData = playersNearby.getRawData();
-                    boolean spawn = false;
-                    boolean tick = false;
-                    for (int itr = 0, len = playersNearby.size(); itr < len; ++itr) {
-                        ServerPlayer player = (ServerPlayer)rawData[itr];
-                        if (player.isSpectator()) {
-                            continue;
-                        }
-
-                        double distance = ChunkMap.euclideanDistanceSquared(chunkcoordintpair, player);
-                        spawn |= player.lastEntitySpawnRadiusSquared >= distance;
-                        tick |= ((double)io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) * ((double)io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) >= distance;
-                        if (spawn & tick) {
-                            break;
-                        }
-                    }
-                    if (tick && chunk1.chunkStatus.isOrAfter(net.minecraft.server.level.FullChunkStatus.ENTITY_TICKING)) {
-                        // Paper end - optimise chunk tick iteration
-                        chunk1.incrementInhabitedTime(j);
-                        if (spawn && flag && (this.spawnEnemies || this.spawnFriendlies) && (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning || _pufferfish_spawnCountsReady.get()) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair)) { // Spigot // Paper - optimise chunk tick iteration
-                            NaturalSpawner.spawnForChunk(this.level, chunk1, lastSpawnState, this.spawnFriendlies, this.spawnEnemies, flag1); // Pufferfish
-                        }
-
-                        if (true || this.level.shouldTickBlocksAt(chunkcoordintpair.toLong())) { // Paper - optimise chunk tick iteration
-                            this.level.tickChunk(chunk1, l);
-                            if ((chunksTicked++ & 1) == 0) net.minecraft.server.MinecraftServer.getServer().executeMidTickTasks(); // Paper
-                        }
-                    }
-                }
-                // Paper start - optimise chunk tick iteration
-                } finally {
-                    if (chunkIterator instanceof io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator safeIterator) {
-                        safeIterator.finishedIterating();
-                    }
-                }
+//                io.papermc.paper.util.player.NearbyPlayers nearbyPlayers = this.chunkMap.getNearbyPlayers(); // Paper - optimise chunk tick iteration
+//                Iterator<LevelChunk> chunkIterator;
+//                if (this.level.paperConfig().entities.spawning.perPlayerMobSpawns) {
+//                    chunkIterator = this.tickingChunks.iterator();
+//                } else {
+//                    chunkIterator = this.tickingChunks.unsafeIterator();
+//                    List<LevelChunk> shuffled = Lists.newArrayListWithCapacity(this.tickingChunks.size());
+//                    while (chunkIterator.hasNext()) {
+//                        shuffled.add(chunkIterator.next());
+//                    }
+//                    Util.shuffle(shuffled, this.level.random);
+//                    chunkIterator = shuffled.iterator();
+//                }
+//                try {
+//                // Paper end - optimise chunk tick iteration
+//                while (chunkIterator.hasNext()) {
+//                    LevelChunk chunk1 = chunkIterator.next();
+//                    // Paper end - optimise chunk tick iteration
+//                    ChunkPos chunkcoordintpair = chunk1.getPos();
+//
+//                    // Paper start - optimise chunk tick iteration
+//                    com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> playersNearby
+//                        = nearbyPlayers.getPlayers(chunkcoordintpair, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.SPAWN_RANGE);
+//                    if (playersNearby == null) {
+//                        continue;
+//                    }
+//                    Object[] rawData = playersNearby.getRawData();
+//                    boolean spawn = false;
+//                    boolean tick = false;
+//                    for (int itr = 0, len = playersNearby.size(); itr < len; ++itr) {
+//                        ServerPlayer player = (ServerPlayer)rawData[itr];
+//                        if (player.isSpectator()) {
+//                            continue;
+//                        }
+//
+//                        double distance = ChunkMap.euclideanDistanceSquared(chunkcoordintpair, player);
+//                        spawn |= player.lastEntitySpawnRadiusSquared >= distance;
+//                        tick |= ((double)io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) * ((double)io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) >= distance;
+//                        if (spawn & tick) {
+//                            break;
+//                        }
+//                    }
+//                    if (tick && chunk1.chunkStatus.isOrAfter(net.minecraft.server.level.FullChunkStatus.ENTITY_TICKING)) {
+//                        // Paper end - optimise chunk tick iteration
+//                        chunk1.incrementInhabitedTime(j);
+//                        if (spawn && flag && (this.spawnEnemies || this.spawnFriendlies) && (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning || _pufferfish_spawnCountsReady.get()) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair)) { // Spigot // Paper - optimise chunk tick iteration
+//                            NaturalSpawner.spawnForChunk(this.level, chunk1, lastSpawnState, this.spawnFriendlies, this.spawnEnemies, flag1); // Pufferfish
+//                        }
+//
+//                        if (true || this.level.shouldTickBlocksAt(chunkcoordintpair.toLong())) { // Paper - optimise chunk tick iteration
+//                            this.level.tickChunk(chunk1, l);
+//                            if ((chunksTicked++ & 1) == 0) net.minecraft.server.MinecraftServer.getServer().executeMidTickTasks(); // Paper
+//                        }
+//                    }
+//                }
+//                // Paper start - optimise chunk tick iteration
+//                } finally {
+//                    if (chunkIterator instanceof io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator safeIterator) {
+//                        safeIterator.finishedIterating();
+//                    }
+//                }
                 // Paper end - optimise chunk tick iteration
                 // this.level.timings.chunkTicks.stopTiming(); // Paper // Purpur
 
                 //gameprofilerfiller.popPush("customSpawners"); // Purpur
                 if (flag) {
                     //try (co.aikar.timings.Timing ignored = this.level.timings.miscMobSpawning.startTiming()) { // Paper - timings // Purpur
-                    this.level.tickCustomSpawners(this.spawnEnemies, this.spawnFriendlies);
+                    future = future.thenRun(() -> this.level.tickCustomSpawners(this.spawnEnemies, this.spawnFriendlies)); // ShreddedPaper - run async
                     //} // Paper - timings // Purpur
                 }
             }
@@ -668,6 +677,7 @@ public class ServerChunkCache extends ChunkSource {
             // Paper - optimise chunk tick iteration
                 //this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timing // Purpur
             // Paper start - optimise chunk tick iteration
+            future = future.thenRun(() -> { // ShreddedPaper - run async
             if (!this.chunkMap.needsChangeBroadcasting.isEmpty()) {
                 it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<ChunkHolder> copy = this.chunkMap.needsChangeBroadcasting.clone();
                 this.chunkMap.needsChangeBroadcasting.clear();
@@ -679,14 +689,16 @@ public class ServerChunkCache extends ChunkSource {
                     }
                 }
             }
+            }); // ShreddedPaper - run async
             // Paper end - optimise chunk tick iteration
                 //this.level.timings.broadcastChunkUpdates.stopTiming(); // Paper - timing // Purpur
             // Paper - optimise chunk tick iteration
             //gameprofilerfiller.pop(); // Purpur
             //gameprofilerfiller.pop(); // Purpur
         }
-    
+
         // Pufferfish start - optimize mob spawning
+        future = future.thenRun(() -> { // ShreddedPaper - run async
         if (gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning) {
             for (ServerPlayer player : this.level.players) {
                 // Paper start - per player mob spawning backoff
@@ -718,7 +730,10 @@ public class ServerChunkCache extends ChunkSource {
                 });
             }
         }
+        }); // ShreddedPaper - run async
         // Pufferfish end
+
+        return future; // ShreddedPaper - run async
     }
 
     private void getFullChunk(long pos, Consumer<LevelChunk> chunkConsumer) {
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index e9eb7f3a28474bc6d3c9f787e8d09b4a80e7fffe..c9fb25304a19a12d24da44b752d8be3b078a59d5 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -30,6 +30,7 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -825,7 +826,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         return this.structureManager;
     }
 
-    public void tick(BooleanSupplier shouldKeepTicking) {
+    public CompletableFuture<Void> tick(BooleanSupplier shouldKeepTicking) { // ShreddedPaper - run async
         //ProfilerFiller gameprofilerfiller = this.getProfiler(); // Purpur
 
         this.handlingTick = true;
@@ -888,7 +889,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         //gameprofilerfiller.popPush("chunkSource"); // Purpur
         //this.timings.chunkProviderTick.startTiming(); // Paper - timings // Purpur
-        this.getChunkSource().tick(shouldKeepTicking, true);
+        return this.getChunkSource().tick(shouldKeepTicking, true).thenRun(() -> { // ShreddedPaper - run async
         //this.timings.chunkProviderTick.stopTiming(); // Paper - timings // Purpur
         //gameprofilerfiller.popPush("blockEvents"); // Purpur
         if (flag) {
@@ -951,6 +952,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         //gameprofilerfiller.push("entityManagement"); // Purpur
         //this.entityManager.tick(); // Paper - rewrite chunk system
+        }); // ShreddedPaper - run async
     }
 
     @Override
@@ -1021,7 +1023,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         });
     }
     // Paper start - optimise random block ticking
-    private final BlockPos.MutableBlockPos chunkTickMutablePosition = new BlockPos.MutableBlockPos();
+    private final ThreadLocal<BlockPos.MutableBlockPos> chunkTickMutablePosition = ThreadLocal.withInitial(BlockPos.MutableBlockPos::new); // ShreddedPaper - Needs to be thread-specific otherwise many threads will all try modifying the same position
     private final io.papermc.paper.util.math.ThreadUnsafeRandom randomTickRandom = new io.papermc.paper.util.math.ThreadUnsafeRandom(this.random.nextLong());
     // Paper end
 
@@ -1033,7 +1035,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         //ProfilerFiller gameprofilerfiller = this.getProfiler(); // Purpur
 
         //gameprofilerfiller.push("thunder"); // Purpur
-        final BlockPos.MutableBlockPos blockposition = this.chunkTickMutablePosition; // Paper - use mutable to reduce allocation rate, final to force compile fail on change
+        final BlockPos.MutableBlockPos blockposition = this.chunkTickMutablePosition.get(); // Paper - use mutable to reduce allocation rate, final to force compile fail on change // ShreddedPaper - is this really that necessary?
 
         if (!this.paperConfig().environment.disableThunder && flag && this.isThundering() && this.spigotConfig.thunderChance > 0 && /*this.random.nextInt(this.spigotConfig.thunderChance) == 0 &&*/ chunk.shouldDoLightning(this.random)) { // Spigot // Paper - Option to disable thunder // Pufferfish - replace random with shouldDoLightning
             blockposition.set(this.findLightningTargetAround(this.getBlockRandomPos(j, 0, k, 15))); // Paper
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkSource.java b/src/main/java/net/minecraft/world/level/chunk/ChunkSource.java
index 5dbb08f792d9ff0b7584d7ae9fae0dc02f40f385..37b50557ca9ab4ab0a5f5d7e817e1246caf68a95 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkSource.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkSource.java
@@ -1,6 +1,7 @@
 package net.minecraft.world.level.chunk;
 
 import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
 import java.util.function.BooleanSupplier;
 import javax.annotation.Nullable;
 import net.minecraft.world.level.ChunkPos;
@@ -31,7 +32,7 @@ public abstract class ChunkSource implements LightChunkGetter, AutoCloseable {
     @Nullable
     public abstract ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create);
 
-    public abstract void tick(BooleanSupplier shouldKeepTicking, boolean tickChunks);
+    public abstract CompletableFuture<Void> tick(BooleanSupplier shouldKeepTicking, boolean tickChunks); // ShreddedPaper - run async
 
     public abstract String gatherStats();
 
