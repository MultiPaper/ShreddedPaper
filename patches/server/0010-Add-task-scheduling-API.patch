From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 5 May 2024 23:21:04 +0900
Subject: [PATCH] Add task scheduling API


diff --git a/src/main/java/io/multipaper/shreddedpaper/ShreddedPaper.java b/src/main/java/io/multipaper/shreddedpaper/ShreddedPaper.java
new file mode 100644
index 0000000000000000000000000000000000000000..25899aea12e866834b7513e69b30aa14437bc945
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/ShreddedPaper.java
@@ -0,0 +1,78 @@
+package io.multipaper.shreddedpaper;
+
+import io.multipaper.shreddedpaper.threading.ShreddedPaperRegionScheduler;
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftWorld;
+import io.multipaper.shreddedpaper.region.RegionPos;
+
+public class ShreddedPaper {
+
+    public static void runSync(Location location, Runnable runnable) {
+        runSync(((CraftWorld) location.getWorld()).getHandle(), new BlockPos(location.getBlockX(), location.getBlockY(), location.getBlockZ()), runnable);
+    }
+
+    public static void runSync(Entity entity, Runnable runnable) {
+        entity.getBukkitEntity().taskScheduler.schedule(e -> runnable.run(), null, 1);
+    }
+
+    public static void runSync(ServerLevel serverLevel, BlockPos blockPos, Runnable runnable) {
+        runSync(serverLevel, new ChunkPos(blockPos), runnable);
+    }
+
+    public static void runSync(ServerLevel serverLevel, ChunkPos chunkPos, Runnable runnable) {
+        serverLevel.getChunkSource().tickingRegions.scheduleTask(RegionPos.forChunk(chunkPos), runnable);
+    }
+
+    public static void runSync(ServerLevel serverLevel1, ChunkPos chunkPos1, ServerLevel serverLevel2, ChunkPos chunkPos2, Runnable runnable) {
+        ShreddedPaperRegionScheduler.scheduleAcrossLevels(serverLevel1, RegionPos.forChunk(chunkPos1), serverLevel2, RegionPos.forChunk(chunkPos2), runnable);
+    }
+
+    public static void ensureSync(Location location, Runnable runnable) {
+        ensureSync(((CraftWorld) location.getWorld()).getHandle(), new BlockPos(location.getBlockX(), location.getBlockY(), location.getBlockZ()), runnable);
+    }
+
+    public static void ensureSync(Entity entity, Runnable runnable) {
+        if (!isSync((ServerLevel) entity.level(), entity.chunkPosition())) {
+            runSync(entity, runnable);
+        } else {
+            runnable.run();
+        }
+    }
+
+    public static void ensureSync(ServerLevel serverLevel, BlockPos blockPos, Runnable runnable) {
+        ensureSync(serverLevel, new ChunkPos(blockPos), runnable);
+    }
+
+    public static void ensureSync(ServerLevel serverLevel, ChunkPos chunkPos, Runnable runnable) {
+        if (!isSync(serverLevel, chunkPos)) {
+            runSync(serverLevel, chunkPos, runnable);
+        } else {
+            runnable.run();
+        }
+    }
+
+    public static void ensureSync(Entity entity1, ServerLevel serverLevel2, ChunkPos chunkPos2, Runnable runnable) {
+        if (!isSync((ServerLevel) entity1.level(), entity1.chunkPosition()) || !isSync(serverLevel2, chunkPos2)) {
+            runSync((ServerLevel) entity1.level(), entity1.chunkPosition(), serverLevel2, chunkPos2, runnable);
+        } else {
+            runnable.run();
+        }
+    }
+
+    public static void ensureSync(ServerLevel serverLevel1, ChunkPos chunkPos1, ServerLevel serverLevel2, ChunkPos chunkPos2, Runnable runnable) {
+        if (!isSync(serverLevel1, chunkPos1) || !isSync(serverLevel2, chunkPos2)) {
+            runSync(serverLevel1, chunkPos1, serverLevel2, chunkPos2, runnable);
+        } else {
+            runnable.run();
+        }
+    }
+
+    public static boolean isSync(ServerLevel serverLevel, ChunkPos chunkPos) {
+        return serverLevel.chunkScheduler.getRegionLocker().hasWriteLock(RegionPos.forChunk(chunkPos));
+    }
+
+}
diff --git a/src/main/java/io/multipaper/shreddedpaper/region/DelayedTask.java b/src/main/java/io/multipaper/shreddedpaper/region/DelayedTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..7f3344a89ceab9c362c48eabc8ec4b1487529e0c
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/region/DelayedTask.java
@@ -0,0 +1,29 @@
+package io.multipaper.shreddedpaper.region;
+
+import com.mojang.logging.LogUtils;
+import org.slf4j.Logger;
+
+public class DelayedTask implements Runnable {
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    private final Runnable task;
+    private long delay;
+
+    public DelayedTask(Runnable task, long delay) {
+        this.task = task;
+        this.delay = delay;
+    }
+
+    public boolean shouldRun() {
+        return --delay <= 0;
+    }
+
+    public void run() {
+        try {
+            task.run();
+        } catch (Throwable t) {
+            LOGGER.error("Error when executing task", t);
+        }
+    }
+
+}
diff --git a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
index 616beda72d0e6fb94e54da45484559b651b7ebdd..e7ad3b17b47e7a2e7bc38d8f414d3920e6aa5b28 100644
--- a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
+++ b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
@@ -1,5 +1,6 @@
 package io.multipaper.shreddedpaper.region;
 
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadedTaskQueue;
 import io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Entity;
@@ -7,6 +8,7 @@ import net.minecraft.world.level.chunk.LevelChunk;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.Consumer;
 
 public class LevelChunkRegion {
@@ -15,6 +17,8 @@ public class LevelChunkRegion {
     private final RegionPos regionPos;
     private final List<LevelChunk> levelChunks = new ArrayList<>(RegionPos.REGION_SIZE * RegionPos.REGION_SIZE);
     private final IteratorSafeOrderedReferenceSet<Entity> tickingEntities = new IteratorSafeOrderedReferenceSet<>(); // Use IteratorSafeOrderedReferenceSet to maintain entity tick order
+    private final ConcurrentLinkedQueue<DelayedTask> scheduledTasks = new ConcurrentLinkedQueue<>(); // Writable tasks
+    private final PrioritisedThreadedTaskQueue internalTasks = new PrioritisedThreadedTaskQueue(); // Read-only tasks
 
     public LevelChunkRegion(ServerLevel level, RegionPos regionPos) {
         this.level = level;
@@ -58,6 +62,14 @@ public class LevelChunkRegion {
         return level;
     }
 
+    public void scheduleTask(Runnable task, long delay) {
+        scheduledTasks.add(new DelayedTask(task, delay));
+    }
+
+    public PrioritisedThreadedTaskQueue getInternalTaskQueue() {
+        return internalTasks;
+    }
+
     public RegionPos getRegionPos() {
         return regionPos;
     }
@@ -76,10 +88,26 @@ public class LevelChunkRegion {
         }
     }
 
+    public void tickTasks() {
+        if (scheduledTasks.isEmpty()) return;
+
+        List<DelayedTask> toRun = new ArrayList<>();
+        for (DelayedTask task : scheduledTasks) {
+            // Check if a task should run before executing the tasks, as tasks may add more tasks while they are running
+            if (task.shouldRun()) {
+                toRun.add(task);
+            }
+        }
+
+        scheduledTasks.removeAll(toRun);
+        toRun.forEach(DelayedTask::run);
+    }
+
     public boolean isEmpty() {
         return levelChunks.isEmpty()
                 && tickingEntities.size() == 0
+                && scheduledTasks.isEmpty()
+                && internalTasks.getTotalTasksExecuted() >= internalTasks.getTotalTasksScheduled()
                 ;
     }
-
 }
diff --git a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java
index a7c9025433f0b0e260a1ff69022b7938dda6b541..af1f3ba71e44b4b49c106d1e45331641e030ec6c 100644
--- a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java
+++ b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java
@@ -9,6 +9,7 @@ import io.multipaper.shreddedpaper.util.SimpleStampedLock;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.Executor;
 import java.util.function.Consumer;
 
 public class LevelChunkRegionMap {
@@ -94,4 +95,36 @@ public class LevelChunkRegionMap {
         }
     }
 
+    /**
+     * Schedule a task to run on the given region's thread at the beginning of the next tick
+     */
+    public void scheduleTask(RegionPos regionPos, Runnable task) {
+        scheduleTask(regionPos, task, 0);
+    }
+
+    /**
+     * Schedule a task to run on the given region's thread after a certain number of ticks
+     */
+    public void scheduleTask(RegionPos regionPos, Runnable task, long delayInTicks) {
+        getOrCreate(regionPos).scheduleTask(task, delayInTicks);
+    }
+
+    /**
+     * Execute a task on the given region's thread at the next given opportunity.
+     * These tasks must <strong>NOT</strong> modify the chunk (blocks, entities, etc). These
+     * tasks must be read-only. Eg loading a chunk, saving data, sending packets, etc.
+     */
+    public void execute(RegionPos regionPos, Runnable task) {
+        getOrCreate(regionPos).getInternalTaskQueue().queueRunnable(task);
+    }
+
+    /**
+     * Executor that executes a task on the given region's thread at the next given opportunity.
+     * These tasks must <strong>NOT</strong> modify the chunk (blocks, entities, etc). These
+     * tasks must be read-only. Eg loading a chunk, saving data, sending packets, etc.
+     */
+    public Executor executorFor(RegionPos regionPos) {
+        return runnable -> execute(regionPos, runnable);
+    }
+
 }
\ No newline at end of file
diff --git a/src/main/java/io/multipaper/shreddedpaper/region/ShreddedPaperRegionSchedulerApiImpl.java b/src/main/java/io/multipaper/shreddedpaper/region/ShreddedPaperRegionSchedulerApiImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..692dee8b14e70b2a1e9af885a7f758601724e278
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/region/ShreddedPaperRegionSchedulerApiImpl.java
@@ -0,0 +1,142 @@
+package io.multipaper.shreddedpaper.region;
+
+import ca.spottedleaf.concurrentutil.util.Validate;
+import io.papermc.paper.threadedregions.scheduler.RegionScheduler;
+import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.plugin.IllegalPluginAccessException;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.logging.Level;
+
+public class ShreddedPaperRegionSchedulerApiImpl implements RegionScheduler {
+
+
+    @Override
+    public void execute(@NotNull Plugin plugin, @NotNull World world, int chunkX, int chunkZ, @NotNull Runnable run) {
+        run(plugin, world, chunkX, chunkZ, task -> run.run());
+    }
+
+    @Override
+    public @NotNull ScheduledTask run(@NotNull Plugin plugin, @NotNull World world, int chunkX, int chunkZ, @NotNull Consumer<ScheduledTask> task) {
+        return runDelayed(plugin, world, chunkX, chunkZ, task, 1);
+    }
+
+    @Override
+    public @NotNull ScheduledTask runDelayed(@NotNull Plugin plugin, @NotNull World world, int chunkX, int chunkZ, @NotNull Consumer<ScheduledTask> task, long delayTicks) {
+        return runAtFixedRate(plugin, world, chunkX, chunkZ, task, delayTicks, -1);
+    }
+
+    @Override
+    public @NotNull ScheduledTask runAtFixedRate(@NotNull Plugin plugin, @NotNull World world, int chunkX, int chunkZ, @NotNull Consumer<ScheduledTask> task, long initialDelayTicks, long periodTicks) {
+        Validate.notNull(plugin, "Plugin may not be null");
+        Validate.notNull(world, "World may not be null");
+        Validate.notNull(task, "Task may not be null");
+        if (initialDelayTicks <= 0) {
+            throw new IllegalArgumentException("Initial delay ticks may not be <= 0");
+        }
+        if (periodTicks == 0) {
+            throw new IllegalArgumentException("Period ticks may not be <= 0");
+        }
+
+        if (!plugin.isEnabled()) {
+            throw new IllegalPluginAccessException("Plugin attempted to register task while disabled");
+        }
+
+        return new RegionScheduledTask(plugin, world, chunkX, chunkZ, task, initialDelayTicks, periodTicks);
+    }
+
+    private class RegionScheduledTask implements ScheduledTask, Runnable {
+
+        private final Plugin plugin;
+        private final ServerLevel serverLevel;
+        private final RegionPos regionPos;
+        private final Consumer<ScheduledTask> task;
+        private final long periodTicks;
+        private final AtomicReference<ExecutionState> executionState = new AtomicReference<>(ExecutionState.IDLE);
+
+        public RegionScheduledTask(Plugin plugin, World world, int chunkX, int chunkZ, Consumer<ScheduledTask> task, long delayTicks, long periodTicks) {
+            this.plugin = plugin;
+            this.serverLevel = ((CraftWorld) world).getHandle();
+            this.task = task;
+            this.periodTicks = periodTicks;
+            this.regionPos = RegionPos.forChunk(new ChunkPos(chunkX, chunkZ));
+
+            schedule(delayTicks);
+        }
+
+        private void schedule(long delayTicks) {
+            serverLevel.getChunkSource().tickingRegions.scheduleTask(regionPos, this, delayTicks);
+        }
+
+        @Override
+        public @NotNull Plugin getOwningPlugin() {
+            return plugin;
+        }
+
+        @Override
+        public boolean isRepeatingTask() {
+            return periodTicks > 0;
+        }
+
+        @Override
+        public @NotNull CancelledState cancel() {
+            if (executionState.compareAndSet(ExecutionState.IDLE, ExecutionState.CANCELLED)) {
+                return CancelledState.CANCELLED_BY_CALLER;
+            }
+            if (executionState.compareAndSet(ExecutionState.RUNNING, ExecutionState.CANCELLED_RUNNING)) {
+                if (isRepeatingTask()) {
+                    return CancelledState.NEXT_RUNS_CANCELLED;
+                } else {
+                    return CancelledState.RUNNING;
+                }
+            }
+            return switch (executionState.get()) {
+                case IDLE, RUNNING -> {
+                    executionState.set(ExecutionState.CANCELLED);
+                    yield CancelledState.CANCELLED_BY_CALLER;
+                }
+                case CANCELLED -> CancelledState.CANCELLED_ALREADY;
+                case CANCELLED_RUNNING -> CancelledState.NEXT_RUNS_CANCELLED_ALREADY;
+                case FINISHED -> CancelledState.ALREADY_EXECUTED;
+            };
+        }
+
+        @Override
+        public @NotNull ExecutionState getExecutionState() {
+            return executionState.get();
+        }
+
+        @Override
+        public void run() {
+            if (!getOwningPlugin().isEnabled()) {
+                executionState.set(ExecutionState.CANCELLED);
+                return;
+            }
+
+            if (!executionState.compareAndSet(ExecutionState.IDLE, ExecutionState.RUNNING)) {
+                return;
+            }
+
+            try {
+                task.accept(this);
+            } catch (Throwable throwable) {
+                this.plugin.getLogger().log(Level.WARNING, "Region task for " + this.plugin.getDescription().getFullName() + " generated an exception", throwable);
+            } finally {
+                executionState.compareAndSet(ExecutionState.RUNNING, isRepeatingTask() ? ExecutionState.IDLE : ExecutionState.FINISHED);
+                executionState.compareAndSet(ExecutionState.CANCELLED_RUNNING, ExecutionState.CANCELLED);
+
+                if (isRepeatingTask()) {
+                    schedule(periodTicks);
+                }
+            }
+        }
+    }
+}
+
diff --git a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
index 56bd2dea24afbda142602fd0c352feedc6f431dd..d556478dddee218971a3b1015872e86ebaaf6048 100644
--- a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
+++ b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
@@ -13,6 +13,7 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.level.NaturalSpawner;
 import net.minecraft.world.level.chunk.LevelChunk;
 import io.multipaper.shreddedpaper.region.LevelChunkRegion;
+import org.bukkit.craftbukkit.entity.CraftEntity;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -57,10 +58,26 @@ public class ShreddedPaperChunkTicker {
         try {
             currentlyTickingRegion.set(region);
 
+            if (!(ShreddedPaperTickThread.isShreddedPaperTickThread())) {
+                throw new IllegalStateException("Ticking region " + level.convertable.getLevelId() + " " + region.getRegionPos() + " outside of ShreddedPaperTickThread!");
+            }
+
+            while (region.getInternalTaskQueue().executeTask()) ;
+
+            region.forEachTickingEntity(entity -> {
+                CraftEntity bukkitEntity = entity.getBukkitEntityRaw();
+                if (bukkitEntity != null && !entity.isRemoved()) { // Entity could have been removed by another entity's task
+                    bukkitEntity.taskScheduler.executeTick();
+                }
+            });
+
+            region.tickTasks();
             region.forEach(chunk -> _tickChunk(level, chunk, spawnercreature_d));
 
             region.forEachTickingEntity(ShreddedPaperEntityTicker::tickEntity);
 
+            while (region.getInternalTaskQueue().executeTask()) ;
+
             if (region.isEmpty()) {
                 level.chunkSource.tickingRegions.remove(region.getRegionPos());
             }
diff --git a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionLocker.java b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionLocker.java
index 0d0fb9030a66b62b42fc090778ec791a386fa987..3b0fac25a8279bad8cc54cd48535409bc5245b44 100644
--- a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionLocker.java
+++ b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionLocker.java
@@ -25,7 +25,7 @@ import java.util.function.Supplier;
  */
 public class ShreddedPaperRegionLocker {
 
-    private static final int REGION_LOCK_RADIUS = 1;
+    public static final int REGION_LOCK_RADIUS = 1;
 
     private final ConcurrentHashMap<RegionPos, Thread> lockedRegions = new ConcurrentHashMap<>();
 
@@ -65,6 +65,13 @@ public class ShreddedPaperRegionLocker {
         return Collections.unmodifiableSet(lockedRegions.entrySet());
     }
 
+    /**
+     * Returns whether any regions are currently locked.
+     */
+    public boolean areAnyLocked() {
+        return !lockedRegions.isEmpty();
+    }
+
     /**
      * Lock the region and run the runnable. If the region is already locked, wait until it is unlocked.
      * Can be called recursively and will respect existing locks created by the same thread.
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index e1ffd62f4ebceecb9bc5471df3da406cffea0483..bb31681d91f54c7d4e242579081f64dfcf481340 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -37,6 +37,9 @@ import net.minecraft.util.Unit;
 import net.minecraft.world.level.ChunkPos;
 import org.bukkit.plugin.Plugin;
 import org.slf4j.Logger;
+import io.multipaper.shreddedpaper.ShreddedPaper;
+import io.multipaper.shreddedpaper.util.SimpleStampedLock;
+
 import java.io.IOException;
 import java.text.DecimalFormat;
 import java.util.ArrayDeque;
@@ -113,6 +116,7 @@ public final class ChunkHolderManager {
     private long currentTick;
 
     private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
+    private final SimpleStampedLock autoSaveQueueLock = new SimpleStampedLock(); // ShreddedPaper - multithread-safe auto save queue
     private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
         if (c1 == c2) {
             return 0;
@@ -204,9 +208,9 @@ public final class ChunkHolderManager {
     }
 
     void ensureInAutosave(final NewChunkHolder holder) {
-        if (!this.autoSaveQueue.contains(holder)) {
+        if (!this.autoSaveQueueLock.optimisticRead(() -> this.autoSaveQueue.contains(holder))) { // ShreddedPaper - multithread-safe auto save queue
             holder.lastAutoSave = MinecraftServer.currentTick;
-            this.autoSaveQueue.add(holder);
+            this.autoSaveQueueLock.write(() -> this.autoSaveQueue.add(holder)); // ShreddedPaper - multithread-safe auto save queue
         }
     }
 
@@ -214,30 +218,40 @@ public final class ChunkHolderManager {
         final List<NewChunkHolder> reschedule = new ArrayList<>();
         final long currentTick = MinecraftServer.currentTickLong;
         final long maxSaveTime = currentTick - this.world.paperConfig().chunks.autoSaveInterval.value();
-        for (int autoSaved = 0; autoSaved < this.world.paperConfig().chunks.maxAutoSaveChunksPerTick && !this.autoSaveQueue.isEmpty();) {
-            final NewChunkHolder holder = this.autoSaveQueue.first();
+        for (int autoSaved = 0; autoSaved < this.world.paperConfig().chunks.maxAutoSaveChunksPerTick;) { // ShreddedPaper - multithread-safe auto save queue
+            final NewChunkHolder holder = this.autoSaveQueueLock.optimisticRead(() -> this.autoSaveQueue.isEmpty() ? null : this.autoSaveQueue.first()); // ShreddedPaper - multithread-safe auto save queue
+
+            if (holder == null) break; // ShreddedPaper - multithread-safe auto save queue
 
             if (holder.lastAutoSave > maxSaveTime) {
                 break;
             }
 
-            this.autoSaveQueue.remove(holder);
+            this.autoSaveQueueLock.write(() -> this.autoSaveQueue.remove(holder)); // ShreddedPaper - multithread-safe auto save queue
 
             holder.lastAutoSave = currentTick;
-            if (holder.save(false, false) != null) {
-                ++autoSaved;
-            }
+            // ShreddedPaper start - run on chunk's thread
+            ShreddedPaper.runSync(holder.world, new ChunkPos(holder.chunkX, holder.chunkZ), () -> {
+                holder.save(false, false);
+            });
+            ++autoSaved;
+            // if (holder.save(false, false) != null) {
+            //    ++autoSaved;
+            // }
+            // ShreddedPaper end - run on chunk's thread
 
             if (holder.getChunkStatus().isOrAfter(FullChunkStatus.FULL)) {
                 reschedule.add(holder);
             }
         }
 
+        this.autoSaveQueueLock.write(() -> { // ShreddedPaper - multithread-safe auto save queue
         for (final NewChunkHolder holder : reschedule) {
             if (holder.getChunkStatus().isOrAfter(FullChunkStatus.FULL)) {
                 this.autoSaveQueue.add(holder);
             }
         }
+        }); // ShreddedPaper - multithread-safe auto save queue
     }
 
     public void saveAllChunks(final boolean flush, final boolean shutdown, final boolean logProgress) {
@@ -1024,6 +1038,16 @@ public final class ChunkHolderManager {
         if (changedFullStatus.isEmpty()) {
             return;
         }
+        // ShreddedPaper start
+        for (NewChunkHolder chunkHolder : changedFullStatus) {
+            this.taskScheduler.scheduleChunkTask(chunkHolder.chunkX, chunkHolder.chunkZ, () -> {
+                List<NewChunkHolder> newChangedFullStatus = new ArrayList<>();
+                chunkHolder.handleFullStatusChange(newChangedFullStatus);
+                addChangedStatuses(newChangedFullStatus);
+            });
+        }
+        if (true) return;
+        // ShreddedPaper end
         if (!TickThread.isTickThread()) {
             this.taskScheduler.scheduleChunkTask(() -> {
                 final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
@@ -1044,7 +1068,7 @@ public final class ChunkHolderManager {
     private void removeChunkHolder(final NewChunkHolder holder) {
         holder.killed = true;
         holder.vanillaChunkHolder.onChunkRemove();
-        this.autoSaveQueue.remove(holder);
+        this.autoSaveQueueLock.write(() -> this.autoSaveQueue.remove(holder)); // ShreddedPaper - multithread-safe auto save queue
         ChunkSystem.onChunkHolderDelete(this.world, holder.vanillaChunkHolder);
         synchronized (this.chunkHolders) {
             this.chunkHolders.remove(CoordinateUtils.getChunkKey(holder.chunkX, holder.chunkZ));
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
index 049e20407033073b06fcdeb46c38485f4926d778..2db01a0cdec0eb5c83d54736500d33d3c07851ff 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
@@ -11,6 +11,8 @@ import io.papermc.paper.chunk.system.scheduling.queue.RadiusAwarePrioritisedExec
 import io.papermc.paper.configuration.GlobalConfiguration;
 import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.TickThread;
+
+import java.util.Optional;
 import java.util.function.BooleanSupplier;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
@@ -27,6 +29,10 @@ import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.chunk.LevelChunk;
 import org.bukkit.Bukkit;
 import org.slf4j.Logger;
+import io.multipaper.shreddedpaper.region.LevelChunkRegion;
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperTickThread;
+
 import java.io.File;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -309,6 +315,36 @@ public final class ChunkTaskScheduler {
     }
 
     public boolean executeMainThreadTask() {
+        // ShreddedPaper start
+        boolean ret = false;
+        for (RegionPos regionPos : world.chunkScheduler.getRegionLocker().getLockedRegions()) {
+            LevelChunkRegion region = world.chunkSource.tickingRegions.get(regionPos);
+            if (region != null) {
+                ret |= region.getInternalTaskQueue().executeTask();
+            }
+        }
+        if (!ret) {
+            // Try bordering regions to our locked regions
+            for (RegionPos regionPos : world.chunkScheduler.getRegionLocker().getLockedRegions()) {
+                for (int x = -1; x <= 1; x++) {
+                    for (int z = -1; z <= 1; z++) {
+                        RegionPos borderRegionPos = new RegionPos(regionPos.x + x, regionPos.z + z);
+                        if (world.chunkScheduler.getRegionLocker().hasLock(borderRegionPos)) continue; // Don't bother trying regions we already have locked
+                        LevelChunkRegion region = world.chunkSource.tickingRegions.get(borderRegionPos);
+                        if (region != null && !region.getInternalTaskQueue().haveAllTasksExecuted()) {
+                            ret |= world.chunkScheduler.getRegionLocker().tryReadOnlyLockNow(regionPos, () -> {
+                                region.getInternalTaskQueue().executeTask();
+                            });
+                        }
+                    }
+                }
+            }
+        }
+        if (ret || ShreddedPaperTickThread.isShreddedPaperTickThread()) {
+            // Don't run the mainThreadExecutor tasks below if we're a ShreddedPaperTickThread
+            return ret;
+        }
+        // ShreddedPaper end
         TickThread.ensureTickThread("Cannot execute main thread task off-main");
         return this.mainThreadExecutor.executeTask();
     }
@@ -486,7 +522,7 @@ public final class ChunkTaskScheduler {
 
     public void scheduleChunkLoad(final int chunkX, final int chunkZ, final ChunkStatus toStatus, final boolean addTicket,
                                   final PrioritisedExecutor.Priority priority, final Consumer<ChunkAccess> onComplete) {
-        if (!TickThread.isTickThread()) {
+        if (!TickThread.isTickThreadFor(world, chunkX, chunkZ)) { // ShreddedPaper - ensure on chunk's thread
             this.scheduleChunkTask(chunkX, chunkZ, () -> {
                 ChunkTaskScheduler.this.scheduleChunkLoad(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
             }, priority);
@@ -774,16 +810,19 @@ public final class ChunkTaskScheduler {
 
     public PrioritisedExecutor.PrioritisedTask createChunkTask(final int chunkX, final int chunkZ, final Runnable run,
                                                                final PrioritisedExecutor.Priority priority) {
-        return this.mainThreadExecutor.createTask(run, priority);
+        return world.chunkSource.tickingRegions.getOrCreate(RegionPos.forChunk(new ChunkPos(chunkX, chunkZ))).getInternalTaskQueue().createTask(run, priority); // ShreddedPaper
+        // return this.mainThreadExecutor.createTask(run, priority); // ShreddedPaper
     }
 
     public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final int chunkX, final int chunkZ, final Runnable run) {
-        return this.mainThreadExecutor.queueRunnable(run);
+        return world.chunkSource.tickingRegions.getOrCreate(RegionPos.forChunk(new ChunkPos(chunkX, chunkZ))).getInternalTaskQueue().queueRunnable(run); // ShreddedPaper
+        // return this.mainThreadExecutor.queueRunnable(run); // ShreddedPaper
     }
 
     public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final int chunkX, final int chunkZ, final Runnable run,
                                                                  final PrioritisedExecutor.Priority priority) {
-        return this.mainThreadExecutor.queueRunnable(run, priority);
+        return world.chunkSource.tickingRegions.getOrCreate(RegionPos.forChunk(new ChunkPos(chunkX, chunkZ))).getInternalTaskQueue().queueRunnable(run); // ShreddedPaper
+        // return this.mainThreadExecutor.queueRunnable(run, priority); // ShreddedPaper
     }
 
     public void executeTasksUntil(final BooleanSupplier exit) {
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
index 604de7aed6db44c9c84d541765e57da48883cf00..47e9d18a4c4981e0b561eeaf52bf6e5bec102680 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
@@ -11,6 +11,9 @@ import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
 import com.mojang.logging.LogUtils;
+import io.multipaper.shreddedpaper.ShreddedPaper;
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperChunkTicker;
 import io.papermc.paper.chunk.system.io.RegionFileIOThread;
 import io.papermc.paper.chunk.system.poi.PoiChunk;
 import io.papermc.paper.util.CoordinateUtils;
@@ -22,6 +25,7 @@ import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ChunkLevel;
 import net.minecraft.server.level.FullChunkStatus;
@@ -1265,6 +1269,22 @@ public final class NewChunkHolder {
 
     private boolean processingFullStatus = false;
 
+    // ShreddedPaper start - ensure write lock
+    public boolean ensureFullStatusChangeWithWriteLock() {
+        // Upgrading to a full loaded chunk is just a chunk load task, which does not require the write lock
+        // However, upgrading to block ticking or entity ticking is more than just loading a chunk, and requires us to have the write lock
+        if (!MinecraftServer.getServer().forceTicks && !ShreddedPaperChunkTicker.isCurrentlyTickingRegion(this.world, RegionPos.forChunk(this.vanillaChunkHolder.pos))) {
+            ShreddedPaper.runSync(world, vanillaChunkHolder.pos, () -> {
+                List<NewChunkHolder> changedFullStatus2 = new ArrayList<>();
+                handleFullStatusChange(changedFullStatus2);
+                this.scheduler.chunkHolderManager.addChangedStatuses(changedFullStatus2);
+            });
+            return false;
+        }
+        return true;
+    }
+    // ShreddedPaper end - ensure write lock
+
     // only to be called on the main thread, no locks need to be held
     public boolean handleFullStatusChange(final List<NewChunkHolder> changedFullStatus) {
         TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot update full status thread off-main");
@@ -1342,6 +1362,7 @@ public final class NewChunkHolder {
                     }
 
                     if (!currState.isOrAfter(FullChunkStatus.BLOCK_TICKING) && nextState.isOrAfter(FullChunkStatus.BLOCK_TICKING)) {
+                        if (!ensureFullStatusChangeWithWriteLock()) return ret; // ShreddedPaper
                         nextState = this.updateCurrentState(FullChunkStatus.BLOCK_TICKING);
                         this.changeEntityChunkStatus(FullChunkStatus.BLOCK_TICKING);
                         chunk.onChunkTicking(this);
@@ -1349,6 +1370,7 @@ public final class NewChunkHolder {
                     }
 
                     if (!currState.isOrAfter(FullChunkStatus.ENTITY_TICKING) && nextState.isOrAfter(FullChunkStatus.ENTITY_TICKING)) {
+                        if (!ensureFullStatusChangeWithWriteLock()) return ret; // ShreddedPaper
                         nextState = this.updateCurrentState(FullChunkStatus.ENTITY_TICKING);
                         this.changeEntityChunkStatus(FullChunkStatus.ENTITY_TICKING);
                         chunk.onChunkEntityTicking(this);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index c617f12b7e44859a4edafc0deff844cd2148268d..975121cd07dd284bcbab65d6a679c2236897e0be 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -14,6 +14,7 @@ import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectArraySet;
@@ -1481,6 +1482,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return executed;
     }
 
+    public final ThreadLocal<Boolean> executingMidTickTasks = ThreadLocal.withInitial(() -> false); // ShreddedPaper
     public final void executeMidTickTasks() {
         org.spigotmc.AsyncCatcher.catchOp("mid tick chunk task execution");
         long startTime = System.nanoTime();
@@ -1491,6 +1493,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
         // co.aikar.timings.MinecraftTimings.midTickChunkTasks.startTiming(); // Purpur
+        executingMidTickTasks.set(true); // ShreddedPaper
         try {
             for (;;) {
                 boolean moreTasks = this.tickMidTickTasks();
@@ -1517,6 +1520,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 }
             }
         } finally {
+            executingMidTickTasks.set(false); // ShreddedPaper
             // co.aikar.timings.MinecraftTimings.midTickChunkTasks.stopTiming(); // Purpur
         }
     }
@@ -1738,17 +1742,17 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         //MinecraftTimings.bukkitSchedulerTimer.stopTiming(); // Spigot // Paper // Purpur
         // Paper start - Folia scheduler API
         ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) Bukkit.getGlobalRegionScheduler()).tick();
-        getAllLevels().forEach(level -> {
-            for (final Entity entity : level.getEntityLookup().getAllCopy()) { // Paper - rewrite chunk system
-                if (entity.isRemoved()) {
-                    continue;
-                }
-                final org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
-                if (bukkit != null) {
-                    bukkit.taskScheduler.executeTick();
-                }
-            }
-        });
+//        getAllLevels().forEach(level -> {
+//            for (final Entity entity : level.getEntityLookup().getAllCopy()) { // Paper - rewrite chunk system
+//                if (entity.isRemoved()) {
+//                    continue;
+//                }
+//                final org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
+//                if (bukkit != null) {
+//                    bukkit.taskScheduler.executeTick();
+//                }
+//            }
+//        });
         // Paper end - Folia scheduler API
         io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.CALLBACK_MANAGER.handleQueue(this.tickCount); // Paper
         //this.profiler.push("commandFunctions"); // Purpur
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index e1e023b6a6c088e2496af5265e5a2ec7f6eff0a3..bcba012eff482031f7160cd113753128ede85760 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -13,10 +13,14 @@ import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.papermc.paper.util.TickThread;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.util.VisibleForDebug;
 import net.minecraft.util.thread.BlockableEventLoop;
@@ -43,6 +47,7 @@ import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import io.multipaper.shreddedpaper.region.LevelChunkRegionMap;
 import io.multipaper.shreddedpaper.threading.ShreddedPaperChunkTicker;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperTickThread;
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -151,10 +156,12 @@ public class ServerChunkCache extends ChunkSource {
 
         long chunkKey = ChunkPos.asLong(x, z);
 
+        try { // ShreddedPaper - ignore exceptions caused by concurrent modification
         cachedChunk = this.loadedChunkMap.get(chunkKey);
         // Skipping a null check to avoid extra instructions to improve inline capability
         this.lastLoadedChunks[cacheKey] = cachedChunk;
         return cachedChunk;
+        } catch (Exception ignored) { return null; } // ShreddedPaper - ignore exceptions caused by concurrent modification
     }
 
     public final LevelChunk getChunkAtIfLoadedMainThreadNoCache(int x, int z) {
@@ -252,10 +259,12 @@ public class ServerChunkCache extends ChunkSource {
     @Override
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
         final int x1 = x; final int z1 = z; // Paper - conflict on variable change
-        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
-            return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
+        if (!io.papermc.paper.util.TickThread.isTickThreadFor(this.level, x, z)) { // Paper - rewrite chunk system // ShreddedPaper - regions
+            CompletableFuture<ChunkAccess> future = CompletableFuture.supplyAsync(() -> { // ShreddedPaper - regions
                 return this.getChunk(x, z, leastStatus, create);
-            }, this.mainThreadProcessor).join();
+            }, this.tickingRegions.executorFor(RegionPos.forChunk(x, z))); // ShreddedPaper - regions
+            if (TickThread.isTickThread()) this.mainThreadProcessor.managedBlock(future::isDone); // ShreddedPaper - run tick thread tasks (this might be one tick thread accessing a chunk in another tick thread)
+            return future.join(); // ShreddedPaper - regions
         } else {
             // Paper start - Perf: Optimise getChunkAt calls for loaded chunks
             LevelChunk ifLoaded = this.getChunkAtIfLoadedMainThread(x, z);
@@ -312,7 +321,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public CompletableFuture<ChunkResult<ChunkAccess>> getChunkFuture(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) {
-        boolean flag1 = io.papermc.paper.util.TickThread.isTickThread(); // Paper - rewrite chunk system
+        boolean flag1 = io.papermc.paper.util.TickThread.isTickThreadFor(this.level, chunkX, chunkZ); // Paper - rewrite chunk system // ShreddedPaper - regions
         CompletableFuture completablefuture;
 
         if (flag1) {
@@ -324,7 +333,7 @@ public class ServerChunkCache extends ChunkSource {
         } else {
             completablefuture = CompletableFuture.supplyAsync(() -> {
                 return this.getChunkFutureMainThread(chunkX, chunkZ, leastStatus, create);
-            }, this.mainThreadProcessor).thenCompose((completablefuture1) -> {
+            }, this.tickingRegions.executorFor(RegionPos.forChunk(chunkX, chunkZ))).thenCompose((completablefuture1) -> { // ShreddedPaper - regions
                 return completablefuture1;
             });
         }
@@ -779,7 +788,7 @@ public class ServerChunkCache extends ChunkSource {
 
     @Override
     public void onLightUpdate(LightLayer type, SectionPos pos) {
-        this.mainThreadProcessor.execute(() -> {
+        this.level.chunkTaskScheduler.scheduleChunkTask(pos.x(), pos.z(), () -> { // ShreddedPaper - run on chunk thread
             ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.chunk().toLong());
 
             if (playerchunk != null) {
@@ -903,7 +912,22 @@ public class ServerChunkCache extends ChunkSource {
             if (ServerChunkCache.this.runDistanceManagerUpdates()) {
                 return true;
             }
-            return super.pollTask() | ServerChunkCache.this.level.chunkTaskScheduler.executeMainThreadTask(); // Paper - rewrite chunk system
+            // ShreddedPaper start - run all region tasks cause the worker threads might be deadlocked and not get to them
+            if ((!MinecraftServer.getServer().executingMidTickTasks.get() && TickThread.isTickThread()) || TickThread.isShutdownThread()) {
+                level.getChunkSource().tickingRegions.forEach(region -> {
+                    if (TickThread.isShutdownThread()) {
+                        // We're trying to shut down the server, just execute all the tasks
+                        region.getInternalTaskQueue().executeTask();
+                    } else if (!region.getInternalTaskQueue().haveAllTasksExecuted()) {
+                        // We're the main thread, try executing chunk tasks for regions not being ticked
+                        level.chunkScheduler.getRegionLocker().tryReadOnlyLockNow(region.getRegionPos(), () -> {
+                            region.getInternalTaskQueue().executeTask();
+                        });
+                    }
+                });
+            }
+            // ShreddedPaper end
+            return (!ShreddedPaperTickThread.isShreddedPaperTickThread() && super.pollTask()) | ServerChunkCache.this.level.chunkTaskScheduler.executeMainThreadTask(); // Paper - rewrite chunk system // ShreddedPaper - don't run main thread tasks on workers
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index ae0f45317643724b6aa2eae04611f1edaeca0071..3198cc0eaad8e7d3e5daca8531d345951030e948 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -174,6 +174,7 @@ import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
+import io.multipaper.shreddedpaper.region.RegionPos;
 import io.multipaper.shreddedpaper.threading.ShreddedPaperRegionScheduler;
 // CraftBukkit end
 
@@ -2297,13 +2298,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
             BlockPos blockposition1 = pos.immutable();
 
             optional.ifPresent((holder) -> {
-                this.getServer().execute(() -> {
+                chunkSource.tickingRegions.execute(RegionPos.forChunk(new ChunkPos(pos)), () -> { // ShreddedPaper
                     this.getPoiManager().remove(blockposition1);
                     DebugPackets.sendPoiRemovedPacket(this, blockposition1);
                 });
             });
             optional1.ifPresent((holder) -> {
-                this.getServer().execute(() -> {
+                chunkSource.tickingRegions.execute(RegionPos.forChunk(new ChunkPos(pos)), () -> { // ShreddedPaper
                     // Paper start - Remove stale POIs
                     if (optional.isEmpty() && this.getPoiManager().exists(blockposition1, poiType -> true)) {
                         this.getPoiManager().remove(blockposition1);
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 43487a9ee202c5b0e5a416519939111f77b3059c..21d98fc8f006d1f445752f6ecd60e24dd6126272 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -4,6 +4,7 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Queues;
 import com.mojang.logging.LogUtils;
 import java.util.List;
+import java.util.NoSuchElementException;
 import java.util.Queue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -122,8 +123,15 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
         } else if (this.blockingCount == 0 && !this.shouldRun(runnable)) {
             return false;
         } else {
-            this.doRunTask(this.pendingRunnables.remove());
+            // ShreddedPaper start - concurrency fix
+            R task = this.pendingRunnables.poll();
+            if (task == null) {
+                return false;
+            }
+
+            this.doRunTask(task);
             return true;
+            // ShreddedPaper end - concurrency fix
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 9db7f7604af0a4f82867cfb63e4c3bb785d829ec..3304b486a0906dce96905d0fd63b4f87432ad646 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -263,6 +263,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     // Paper start
+    @org.jetbrains.annotations.Nullable // ShreddedPaper - the point of this is that it can be null
     public CraftEntity getBukkitEntityRaw() {
         return this.bukkitEntity;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 01472ee224ac91ec4fbffdf82a0d92e0d1ab69c1..0e0a098f543e19a41b4bae73156ece970b9f7d50 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -261,6 +261,7 @@ import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 import io.multipaper.shreddedpaper.permissions.ShreddedPaperPermissions;
+import io.multipaper.shreddedpaper.region.ShreddedPaperRegionSchedulerApiImpl;
 
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
@@ -310,7 +311,7 @@ public final class CraftServer implements Server {
     private final io.papermc.paper.potion.PaperPotionBrewer potionBrewer; // Paper - Custom Potion Mixes
 
     // Paper start - Folia region threading API
-    private final io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler regionizedScheduler = new io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler();
+    private final io.papermc.paper.threadedregions.scheduler.RegionScheduler regionizedScheduler = new ShreddedPaperRegionSchedulerApiImpl(); // ShreddedPaper
     private final io.papermc.paper.threadedregions.scheduler.FoliaAsyncScheduler asyncScheduler = new io.papermc.paper.threadedregions.scheduler.FoliaAsyncScheduler();
     private final io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler globalRegionScheduler = new io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler();
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 523a6afd7f1dcb0b4ddf5ede0415487c104296bc..38fd594b8184e4b2f11812f80e77a6d1d8df65ad 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -5,6 +5,9 @@ import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.mojang.datafixers.util.Pair;
+import io.multipaper.shreddedpaper.ShreddedPaper;
+import io.multipaper.shreddedpaper.region.RegionPos;
+import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
@@ -20,6 +23,7 @@ import java.util.Objects;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -392,10 +396,12 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public boolean isChunkGenerated(int x, int z) {
         // Paper start - Fix this method
-        if (!Bukkit.isPrimaryThread()) {
-            return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
+        if (!TickThread.isTickThreadFor(this.world, x, z)) { // ShreddedPaper - regions
+            CompletableFuture<Boolean> future = java.util.concurrent.CompletableFuture.supplyAsync(() -> { // ShreddedPaper - regions
                 return CraftWorld.this.isChunkGenerated(x, z);
-            }, world.getChunkSource().mainThreadProcessor).join();
+            }, world.getChunkSource().tickingRegions.executorFor(RegionPos.forChunk(x, z))); // ShreddedPaper - regions
+            if (TickThread.isTickThread()) this.getHandle().chunkSource.mainThreadProcessor.managedBlock(future::isDone); // ShreddedPaper - run tick thread tasks (this might be one tick thread accessing a chunk in another tick thread)
+            return future.join(); // ShreddedPaper - regions
         }
         ChunkAccess chunk = world.getChunkSource().getChunkAtImmediately(x, z);
         if (chunk == null) {
@@ -2579,7 +2585,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         java.util.concurrent.CompletableFuture<Chunk> ret = new java.util.concurrent.CompletableFuture<>();
 
         io.papermc.paper.chunk.system.ChunkSystem.scheduleChunkLoad(this.getHandle(), x, z, gen, ChunkStatus.FULL, true, priority, (c) -> {
-            net.minecraft.server.MinecraftServer.getServer().scheduleOnMain(() -> {
+            ShreddedPaper.ensureSync(this.getHandle(), c.getPos(), () -> { // ShreddedPaper - ensure on correct thread
                 net.minecraft.world.level.chunk.LevelChunk chunk = (net.minecraft.world.level.chunk.LevelChunk)c;
                 if (chunk != null) this.addTicket(x, z); // Paper
                 ret.complete(chunk == null ? null : new CraftChunk(chunk));
