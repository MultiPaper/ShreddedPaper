From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Thu, 17 Jul 2025 01:45:27 +0900
Subject: [PATCH] Optimization: Parallelization


diff --git a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
index 783ec3ddae8829237bfdb3a3b79f8bd83b16db34..32d0a50201d66731751a419149595384776a28b9 100644
--- a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
+++ b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
@@ -1,12 +1,15 @@
 package io.multipaper.shreddedpaper.threading;
 
+import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
+import io.multipaper.shreddedpaper.config.ShreddedPaperConfiguration;
 import io.multipaper.shreddedpaper.region.RegionPos;
 import io.papermc.paper.util.player.NearbyPlayers;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ChunkMap;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.Level;
@@ -23,6 +26,8 @@ public class ShreddedPaperChunkTicker {
 
     public static boolean tickingChunks = false;
 
+    private static final List<Entity> trackedEntitiesWorkerList = new ArrayList<>(); // Re-usable list for processing tracked entities in parallel
+
     public static void tickChunks(ServerLevel level, NaturalSpawner.SpawnState spawnercreature_d) {
         List<CompletableFuture<Void>> futures = new ArrayList<>();
 
@@ -34,15 +39,61 @@ public class ShreddedPaperChunkTicker {
                 region -> futures.add(tickRegion(level, region, spawnercreature_d))
         );
 
+        waitForFutures(level, futures);
+
+        if (ShreddedPaperConfiguration.get().optimizations.processTrackQueueInParallel) processTrackQueueInParallel(level);
+
+
+        if (ShreddedPaperConfiguration.get().optimizations.flushQueueInParallel) flushQueueInParallel(level);
+
+        tickingChunks = false;
+
+        MinecraftServer.getServer().executeMidTickTasks();
+    }
+
+    private static void waitForFutures(ServerLevel level, Iterable<CompletableFuture<Void>> futures) {
         for (CompletableFuture<Void> future : futures) {
             if (!future.isDone()) {
                 level.getChunkSource().mainThreadProcessor.managedBlock(future::isDone);
             }
+            if (future.isCompletedExceptionally()) {
+                throw new RuntimeException("Exception while ticking world %s".formatted(level.getWorld().getName()), future.exceptionNow());
+            }
         }
+    }
 
-        tickingChunks = false;
+    private static void processTrackQueueInParallel(ServerLevel level) {
+        level.getChunkSource().mainThreadProcessor.managedBlock(() -> level.chunkScheduler.getRegionLocker().globalLock().tryWriteLock() != 0);
+        try {
+            List<CompletableFuture<Void>> futures = new ArrayList<>();
 
-        MinecraftServer.getServer().executeMidTickTasks();
+            trackedEntitiesWorkerList.clear();
+            level.chunkSource.tickingRegions.forEach(
+                    region -> region.forEachTrackedEntity(trackedEntitiesWorkerList::add)
+            );
+
+            List<List<Entity>> trackedEntitiesTasks = Lists.partition(trackedEntitiesWorkerList, Math.max(1, trackedEntitiesWorkerList.size() / ShreddedPaperTickThread.THREAD_COUNT / 3));
+            for (List<Entity> trackedEntities : trackedEntitiesTasks) {
+                if (trackedEntities.isEmpty()) continue;
+                futures.add(CompletableFuture.runAsync(() -> trackedEntities.forEach(ShreddedPaperEntityTicker::processTrackQueue), ShreddedPaperTickThread.getExecutor()));
+            }
+
+            waitForFutures(level, futures);
+        } finally {
+            level.chunkScheduler.getRegionLocker().globalLock().tryUnlockWrite();
+        }
+    }
+
+    private static void flushQueueInParallel(ServerLevel level) {
+        List<CompletableFuture<Void>> futures = new ArrayList<>();
+
+        List<List<ServerPlayer>> playersTasks = Lists.partition(new ArrayList<>(level.players()), Math.max(1, level.players().size() / ShreddedPaperTickThread.THREAD_COUNT / 3));
+        for (List<ServerPlayer> players : playersTasks) {
+            if (players.isEmpty()) continue;
+            futures.add(CompletableFuture.runAsync(() -> players.forEach(player -> player.connection.connection.flushQueue()), ShreddedPaperTickThread.getExecutor()));
+        }
+
+        waitForFutures(level, futures);
     }
 
     public static CompletableFuture<Void> tickRegion(ServerLevel level, LevelChunkRegion region, NaturalSpawner.SpawnState spawnercreature_d) {
@@ -96,7 +147,7 @@ public class ShreddedPaperChunkTicker {
 
             region.forEachTickingEntity(ShreddedPaperEntityTicker::tickEntity);
 
-            region.forEachTrackedEntity(ShreddedPaperEntityTicker::processTrackQueue);
+            if (!ShreddedPaperConfiguration.get().optimizations.processTrackQueueInParallel) region.forEachTrackedEntity(ShreddedPaperEntityTicker::processTrackQueue);
 
             level.tickBlockEntities(region.tickingBlockEntities, region.pendingBlockEntityTickers);
 
diff --git a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionLocker.java b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionLocker.java
index b30147827ffa329c09703f48f01733c34f5e63e3..6af35c73c60eb5e9c6b4ef165727a28632219762 100644
--- a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionLocker.java
+++ b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperRegionLocker.java
@@ -14,6 +14,7 @@ import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.locks.LockSupport;
+import java.util.concurrent.locks.StampedLock;
 import java.util.function.Supplier;
 
 /**
@@ -31,6 +32,7 @@ public class ShreddedPaperRegionLocker {
     public static final int REGION_LOCK_RADIUS = 1;
 
     private final ConcurrentHashMap<RegionPos, LockedRegion> lockedRegions = new ConcurrentHashMap<>();
+    private final StampedLock globalLock = new StampedLock();
 
     private final ThreadLocal<Set<RegionPos>> localLocks = ThreadLocal.withInitial(ObjectOpenHashSet::new);
     private final ThreadLocal<Set<RegionPos>> readOnlyLocks = ThreadLocal.withInitial(ObjectOpenHashSet::new);
@@ -203,6 +205,13 @@ public class ShreddedPaperRegionLocker {
         return nextTask.get();
     }
 
+    /**
+     * globalLock.writeLock() will claim all regions
+     */
+    public StampedLock globalLock() {
+        return this.globalLock;
+    }
+
     public interface RegionLock {
         Collection<RegionPos> lockedRegions();
         Thread owner();
@@ -212,6 +221,7 @@ public class ShreddedPaperRegionLocker {
     public class ReadOnlyRegionLock implements RegionLock {
         private final List<LockedRegion> readLocks;
         private final Thread thread;
+        private long globalLockStamp = 0;
 
         private ReadOnlyRegionLock(int lockRadius) {
             this.thread = Thread.currentThread();
@@ -223,6 +233,10 @@ public class ShreddedPaperRegionLocker {
                 throw new IllegalStateException("Cannot lock a region from a different thread [expected=%s,got=%s]".formatted(thread, Thread.currentThread()));
             }
 
+            if (globalLockStamp == 0 && (globalLockStamp = ShreddedPaperRegionLocker.this.globalLock.tryReadLock()) == 0) {
+                return false;
+            }
+
             LockedRegion lockedRegion = ShreddedPaperRegionLocker.this.lockedRegions.compute(regionPos, (k, prevValue) -> {
                 if (prevValue == null) {
                     // This region is unlocked, let's lock it
@@ -262,6 +276,10 @@ public class ShreddedPaperRegionLocker {
             for (LockedRegion lockedRegion : this.readLocks) {
                 lockedRegion.complete();
             }
+
+            if (this.globalLockStamp != 0) {
+                ShreddedPaperRegionLocker.this.globalLock.unlockRead(this.globalLockStamp);
+            }
         }
 
     }
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 51f67289fcf62614a5fd610474ab423544f84ebe..d7374a603bd1d9a8dfc0fd1755a0c779e7e3b428 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -570,7 +570,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     // Paper start - Optimize network: Rewrite this to be safer if ran off main thread
-    private boolean flushQueue() {
+    public boolean flushQueue() { // ShreddedPaper - make public
         if (!this.isConnected()) {
             return true;
         }
@@ -627,7 +627,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static int tickSecond; // Purpur
     public void tick() {
         if (this.packetListener instanceof ServerGamePacketListenerImpl serverGamePacketListener && !TickThread.isTickThreadFor(serverGamePacketListener.player)) return; // ShreddedPaper
-        this.flushQueue();
+        if (!ShreddedPaperConfiguration.get().optimizations.flushQueueInParallel) this.flushQueue(); // ShreddedPaper - Add option to flush queue in parallel
         // Paper start - Buffer joins to world
         if (Connection.currTick != net.minecraft.server.MinecraftServer.currentTick) {
             Connection.currTick = net.minecraft.server.MinecraftServer.currentTick;
